var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$8 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$6 = Symbol.for("react.provider"), u$5 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$5 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$4(a2) {
  if (a2 === null || typeof a2 !== "object")
    return null;
  a2 = z$2 && a2[z$2] || a2["@@iterator"];
  return typeof a2 === "function" ? a2 : null;
}
var B = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$5(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B;
}
E$5.prototype.isReactComponent = {};
E$5.prototype.setState = function(a2, b2) {
  if (typeof a2 !== "object" && typeof a2 !== "function" && a2 != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$5.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$3() {
}
F$3.prototype = E$5.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B;
}
var H$1 = G$1.prototype = new F$3();
H$1.constructor = G$1;
C$3(H$1, E$5.prototype);
H$1.isPureReactComponent = true;
var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
function M$3(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (b2 != null)
    for (d2 in b2.ref !== void 0 && (h2 = b2.ref), b2.key !== void 0 && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (g2 === 1)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      c2[d2] === void 0 && (c2[d2] = g2[d2]);
  return { $$typeof: l$7, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$7, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === l$7;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$3 = /\/+/g;
function Q$1(a2, b2) {
  return typeof a2 === "object" && a2 !== null && a2.key != null ? escape("" + a2.key) : b2.toString(36);
}
function R$6(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if (k2 === "undefined" || k2 === "boolean")
    a2 = null;
  var h2 = false;
  if (a2 === null)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$7:
          case n$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = d2 === "" ? "." + Q$1(h2, 0) : d2, I$2(c2) ? (e2 = "", a2 != null && (e2 = a2.replace(P$3, "$&/") + "/"), R$6(c2, b2, e2, "", function(a3) {
      return a3;
    })) : c2 != null && (O$3(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = d2 === "" ? "." : d2 + ":";
  if (I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$6(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), typeof f2 === "function")
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$6(k2, b2, e2, f2, c2);
  else if (k2 === "object")
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + (b2 === "[object Object]" ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$3(a2, b2, e2) {
  if (a2 == null)
    return a2;
  var d2 = [], c2 = 0;
  R$6(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (a2._status === -1) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (a2._status === 0 || a2._status === -1)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (a2._status === 0 || a2._status === -1)
        a2._status = 2, a2._result = b3;
    });
    a2._status === -1 && (a2._status = 0, a2._result = b2);
  }
  if (a2._status === 1)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e2) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$3(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$5;
react_production_min.Fragment = p$8;
react_production_min.Profiler = r$6;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$5;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (a2 === null || a2 === void 0)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (b2 != null) {
    b2.ref !== void 0 && (k2 = b2.ref, h2 = K$2.current);
    b2.key !== void 0 && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L.hasOwnProperty(f2) && (d2[f2] = b2[f2] === void 0 && g2 !== void 0 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (f2 === 1)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$7, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$5, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$6, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a2) {
  var b2 = M$3.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$5, type: a2, compare: b2 === void 0 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.0.0-fc46dba67-20220329";
{
  react.exports = react_production_min;
}
var e$3 = react.exports;
var React = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  "default": e$3
}, [react.exports]);
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return a2.length === 0 ? null : a2[0];
  }
  function k2(a2) {
    if (a2.length === 0)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a2.id - b2.id;
  }
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = typeof setTimeout === "function" ? setTimeout : null, E2 = typeof clearTimeout === "function" ? clearTimeout : null, F2 = typeof setImmediate !== "undefined" ? setImmediate : null;
  typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); b2 !== null; ) {
      if (b2.callback === null)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (h2(r2) !== null)
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        b2 !== null && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); v2 !== null && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if (typeof d2 === "function") {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          typeof e2 === "function" ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (v2 !== null)
        var w2 = true;
      else {
        var m2 = h2(t2);
        m2 !== null && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (O2 !== null) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if (typeof F2 === "function")
    S2 = function() {
      F2(R2);
    };
  else if (typeof MessageChannel !== "undefined") {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    typeof c2 === "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 === "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), h2(r2) === null && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ba = scheduler.exports;
function p$7(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var ca = /* @__PURE__ */ new Set(), da = {};
function ea(a2, b2) {
  fa(a2, b2);
  fa(a2 + "Capture", b2);
}
function fa(a2, b2) {
  da[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    ca.add(b2[a2]);
}
var ha = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), ia = Object.prototype.hasOwnProperty, ja = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ka = {}, la = {};
function ma(a2) {
  if (ia.call(la, a2))
    return true;
  if (ia.call(ka, a2))
    return false;
  if (ja.test(a2))
    return la[a2] = true;
  ka[a2] = true;
  return false;
}
function na(a2, b2, c2, d2) {
  if (c2 !== null && c2.type === 0)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (c2 !== null)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return a2 !== "data-" && a2 !== "aria-";
    default:
      return false;
  }
}
function oa(a2, b2, c2, d2) {
  if (b2 === null || typeof b2 === "undefined" || na(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (c2 !== null)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return b2 === false;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function q$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = b2 === 2 || b2 === 3 || b2 === 4;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$1[a2] = new q$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$1[b2] = new q$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$1[a2] = new q$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var pa = /[\-:]([a-z])/g;
function qa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(pa, qa);
  z$1[b2] = new q$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(pa, qa);
  z$1[b2] = new q$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(pa, qa);
  z$1[b2] = new q$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new q$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$1[a2] = new q$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ra(a2, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (e2 !== null ? e2.type !== 0 : d2 || !(2 < b2.length) || b2[0] !== "o" && b2[0] !== "O" || b2[1] !== "n" && b2[1] !== "N")
    oa(b2, c2, e2, d2) && (c2 = null), d2 || e2 === null ? ma(b2) && (c2 === null ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = c2 === null ? e2.type === 3 ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, c2 === null ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = e2 === 3 || e2 === 4 && c2 === true ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var sa = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ta = Symbol.for("react.element"), ua = Symbol.for("react.portal"), va = Symbol.for("react.fragment"), wa = Symbol.for("react.strict_mode"), xa = Symbol.for("react.profiler"), ya = Symbol.for("react.provider"), Aa = Symbol.for("react.context"), Ba = Symbol.for("react.forward_ref"), Ca = Symbol.for("react.suspense"), Da = Symbol.for("react.suspense_list"), Ea = Symbol.for("react.memo"), Fa = Symbol.for("react.lazy");
var Ga = Symbol.for("react.offscreen");
var Ha = Symbol.iterator;
function Ia(a2) {
  if (a2 === null || typeof a2 !== "object")
    return null;
  a2 = Ha && a2[Ha] || a2["@@iterator"];
  return typeof a2 === "function" ? a2 : null;
}
var A$3 = Object.assign, Ja;
function Ka(a2) {
  if (Ja === void 0)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      Ja = b2 && b2[1] || "";
    }
  return "\n" + Ja + a2;
}
var La = false;
function Ma(a2, b2) {
  if (!a2 || La)
    return "";
  La = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && typeof l2.stack === "string") {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    La = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ka(a2) : "";
}
function Na(a2) {
  switch (a2.tag) {
    case 5:
      return Ka(a2.type);
    case 16:
      return Ka("Lazy");
    case 13:
      return Ka("Suspense");
    case 19:
      return Ka("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Ma(a2.type, false), a2;
    case 11:
      return a2 = Ma(a2.type.render, false), a2;
    case 1:
      return a2 = Ma(a2.type, true), a2;
    default:
      return "";
  }
}
function Oa(a2) {
  if (a2 == null)
    return null;
  if (typeof a2 === "function")
    return a2.displayName || a2.name || null;
  if (typeof a2 === "string")
    return a2;
  switch (a2) {
    case va:
      return "Fragment";
    case ua:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ca:
      return "Suspense";
    case Da:
      return "SuspenseList";
  }
  if (typeof a2 === "object")
    switch (a2.$$typeof) {
      case Aa:
        return (a2.displayName || "Context") + ".Consumer";
      case ya:
        return (a2._context.displayName || "Context") + ".Provider";
      case Ba:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ea:
        return b2 = a2.displayName || null, b2 !== null ? b2 : Oa(a2.type) || "Memo";
      case Fa:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Oa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Pa(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || (a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Oa(b2);
    case 8:
      return b2 === wa ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof b2 === "function")
        return b2.displayName || b2.name || null;
      if (typeof b2 === "string")
        return b2;
  }
  return null;
}
function Qa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ra(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && a2.toLowerCase() === "input" && (b2 === "checkbox" || b2 === "radio");
}
function Sa(a2) {
  var b2 = Ra(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && typeof c2 !== "undefined" && typeof c2.get === "function" && typeof c2.set === "function") {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Ta(a2) {
  a2._valueTracker || (a2._valueTracker = Sa(a2));
}
function Ua(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ra(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Va(a2) {
  a2 = a2 || (typeof document !== "undefined" ? document : void 0);
  if (typeof a2 === "undefined")
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Wa(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c2 != null ? c2 : a2._wrapperState.initialChecked });
}
function Xa(a2, b2) {
  var c2 = b2.defaultValue == null ? "" : b2.defaultValue, d2 = b2.checked != null ? b2.checked : b2.defaultChecked;
  c2 = Qa(b2.value != null ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: b2.type === "checkbox" || b2.type === "radio" ? b2.checked != null : b2.value != null };
}
function Ya(a2, b2) {
  b2 = b2.checked;
  b2 != null && ra(a2, "checked", b2, false);
}
function Za(a2, b2) {
  Ya(a2, b2);
  var c2 = Qa(b2.value), d2 = b2.type;
  if (c2 != null)
    if (d2 === "number") {
      if (c2 === 0 && a2.value === "" || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if (d2 === "submit" || d2 === "reset") {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? $a(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && $a(a2, b2.type, Qa(b2.defaultValue));
  b2.checked == null && b2.defaultChecked != null && (a2.defaultChecked = !!b2.defaultChecked);
}
function ab(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!(d2 !== "submit" && d2 !== "reset" || b2.value !== void 0 && b2.value !== null))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  c2 !== "" && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  c2 !== "" && (a2.name = c2);
}
function $a(a2, b2, c2) {
  if (b2 !== "number" || Va(a2.ownerDocument) !== a2)
    c2 == null ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var bb = Array.isArray;
function cb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Qa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      b2 !== null || a2[e2].disabled || (b2 = a2[e2]);
    }
    b2 !== null && (b2.selected = true);
  }
}
function db(a2, b2) {
  if (b2.dangerouslySetInnerHTML != null)
    throw Error(p$7(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function eb(a2, b2) {
  var c2 = b2.value;
  if (c2 == null) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (c2 != null) {
      if (b2 != null)
        throw Error(p$7(92));
      if (bb(c2)) {
        if (1 < c2.length)
          throw Error(p$7(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    b2 == null && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Qa(c2) };
}
function fb(a2, b2) {
  var c2 = Qa(b2.value), d2 = Qa(b2.defaultValue);
  c2 != null && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), b2.defaultValue == null && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  d2 != null && (a2.defaultValue = "" + d2);
}
function gb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && b2 !== "" && b2 !== null && (a2.value = b2);
}
function hb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function ib(a2, b2) {
  return a2 == null || a2 === "http://www.w3.org/1999/xhtml" ? hb(b2) : a2 === "http://www.w3.org/2000/svg" && b2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a2;
}
var jb, kb = function(a2) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if (a2.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    jb = jb || document.createElement("div");
    jb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = jb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function lb(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && c2.nodeType === 3) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var mb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, nb = ["Webkit", "ms", "Moz", "O"];
Object.keys(mb).forEach(function(a2) {
  nb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    mb[b2] = mb[a2];
  });
});
function ob(a2, b2, c2) {
  return b2 == null || typeof b2 === "boolean" || b2 === "" ? "" : c2 || typeof b2 !== "number" || b2 === 0 || mb.hasOwnProperty(a2) && mb[a2] ? ("" + b2).trim() : b2 + "px";
}
function pb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = c2.indexOf("--") === 0, e2 = ob(c2, b2[c2], d2);
      c2 === "float" && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var qb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function rb(a2, b2) {
  if (b2) {
    if (qb[a2] && (b2.children != null || b2.dangerouslySetInnerHTML != null))
      throw Error(p$7(137, a2));
    if (b2.dangerouslySetInnerHTML != null) {
      if (b2.children != null)
        throw Error(p$7(60));
      if (typeof b2.dangerouslySetInnerHTML !== "object" || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$7(61));
    }
    if (b2.style != null && typeof b2.style !== "object")
      throw Error(p$7(62));
  }
}
function sb(a2, b2) {
  if (a2.indexOf("-") === -1)
    return typeof b2.is === "string";
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var tb = null;
function ub(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return a2.nodeType === 3 ? a2.parentNode : a2;
}
var vb = null, wb = null, xb = null;
function yb(a2) {
  if (a2 = zb(a2)) {
    if (typeof vb !== "function")
      throw Error(p$7(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Ab(b2), vb(a2.stateNode, a2.type, b2));
  }
}
function Bb(a2) {
  wb ? xb ? xb.push(a2) : xb = [a2] : wb = a2;
}
function Cb() {
  if (wb) {
    var a2 = wb, b2 = xb;
    xb = wb = null;
    yb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        yb(b2[a2]);
  }
}
function Db(a2, b2) {
  return a2(b2);
}
function Eb() {
}
var Fb = false;
function Gb(a2, b2, c2) {
  if (Fb)
    return a2(b2, c2);
  Fb = true;
  try {
    return Db(a2, b2, c2);
  } finally {
    if (Fb = false, wb !== null || xb !== null)
      Eb(), Cb();
  }
}
function Hb(a2, b2) {
  var c2 = a2.stateNode;
  if (c2 === null)
    return null;
  var d2 = Ab(c2);
  if (d2 === null)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !(a2 === "button" || a2 === "input" || a2 === "select" || a2 === "textarea"));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && typeof c2 !== "function")
    throw Error(p$7(231, b2, typeof c2));
  return c2;
}
var Ib = false;
if (ha)
  try {
    var Jb = {};
    Object.defineProperty(Jb, "passive", { get: function() {
      Ib = true;
    } });
    window.addEventListener("test", Jb, Jb);
    window.removeEventListener("test", Jb, Jb);
  } catch (a2) {
    Ib = false;
  }
function Kb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Lb = false, Mb = null, Nb = false, Ob = null, Pb = { onError: function(a2) {
  Lb = true;
  Mb = a2;
} };
function Qb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Lb = false;
  Mb = null;
  Kb.apply(Pb, arguments);
}
function Rb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Qb.apply(this, arguments);
  if (Lb) {
    if (Lb) {
      var l2 = Mb;
      Lb = false;
      Mb = null;
    } else
      throw Error(p$7(198));
    Nb || (Nb = true, Ob = l2);
  }
}
function Sb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, (b2.flags & 4098) !== 0 && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return b2.tag === 3 ? c2 : null;
}
function Tb(a2) {
  if (a2.tag === 13) {
    var b2 = a2.memoizedState;
    b2 === null && (a2 = a2.alternate, a2 !== null && (b2 = a2.memoizedState));
    if (b2 !== null)
      return b2.dehydrated;
  }
  return null;
}
function Ub(a2) {
  if (Sb(a2) !== a2)
    throw Error(p$7(188));
}
function Vb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Sb(a2);
    if (b2 === null)
      throw Error(p$7(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (e2 === null)
      break;
    var f2 = e2.alternate;
    if (f2 === null) {
      d2 = e2.return;
      if (d2 !== null) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Ub(e2), a2;
        if (f2 === d2)
          return Ub(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$7(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$7(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$7(190));
  }
  if (c2.tag !== 3)
    throw Error(p$7(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Wb(a2) {
  a2 = Vb(a2);
  return a2 !== null ? Xb(a2) : null;
}
function Xb(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2;
  for (a2 = a2.child; a2 !== null; ) {
    var b2 = Xb(a2);
    if (b2 !== null)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var Yb = ba.unstable_scheduleCallback, Zb = ba.unstable_cancelCallback, $b = ba.unstable_shouldYield, ac = ba.unstable_requestPaint, D$2 = ba.unstable_now, bc = ba.unstable_getCurrentPriorityLevel, cc = ba.unstable_ImmediatePriority, dc = ba.unstable_UserBlockingPriority, ec = ba.unstable_NormalPriority, fc = ba.unstable_LowPriority, gc = ba.unstable_IdlePriority, hc = null, ic = null;
function jc(a2) {
  if (ic && typeof ic.onCommitFiberRoot === "function")
    try {
      ic.onCommitFiberRoot(hc, a2, void 0, (a2.current.flags & 128) === 128);
    } catch (b2) {
    }
}
var lc = Math.clz32 ? Math.clz32 : kc, mc = Math.log, nc = Math.LN2;
function kc(a2) {
  a2 >>>= 0;
  return a2 === 0 ? 32 : 31 - (mc(a2) / nc | 0) | 0;
}
var oc = 64, pc = 4194304;
function qc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function rc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (c2 === 0)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (g2 !== 0) {
    var h2 = g2 & ~e2;
    h2 !== 0 ? d2 = qc(h2) : (f2 &= g2, f2 !== 0 && (d2 = qc(f2)));
  } else
    g2 = c2 & ~e2, g2 !== 0 ? d2 = qc(g2) : f2 !== 0 && (d2 = qc(f2));
  if (d2 === 0)
    return 0;
  if (b2 !== 0 && b2 !== d2 && (b2 & e2) === 0 && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || e2 === 16 && (f2 & 4194240) !== 0))
    return b2;
  (d2 & 4) !== 0 && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (b2 !== 0)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - lc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function sc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function tc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - lc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (k2 === -1) {
      if ((h2 & c2) === 0 || (h2 & d2) !== 0)
        e2[g2] = sc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function uc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function vc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function wc(a2, b2, c2) {
  a2.pendingLanes |= b2;
  b2 !== 536870912 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - lc(b2);
  a2[b2] = c2;
}
function xc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - lc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function yc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - lc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var E$4 = 0;
function zc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? (a2 & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
}
var Ac, Bc, Cc, Dc, Ec, Fc = false, Gc = [], Hc = null, Ic = null, Jc = null, Kc = /* @__PURE__ */ new Map(), Lc = /* @__PURE__ */ new Map(), Mc = [], Nc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Oc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Hc = null;
      break;
    case "dragenter":
    case "dragleave":
      Ic = null;
      break;
    case "mouseover":
    case "mouseout":
      Jc = null;
      break;
    case "pointerover":
    case "pointerout":
      Kc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Lc.delete(b2.pointerId);
  }
}
function Pc(a2, b2, c2, d2, e2, f2) {
  if (a2 === null || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, b2 !== null && (b2 = zb(b2), b2 !== null && Bc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  e2 !== null && b2.indexOf(e2) === -1 && b2.push(e2);
  return a2;
}
function Qc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Hc = Pc(Hc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Ic = Pc(Ic, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Jc = Pc(Jc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Kc.set(f2, Pc(Kc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Lc.set(f2, Pc(Lc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Rc(a2) {
  var b2 = Sc(a2.target);
  if (b2 !== null) {
    var c2 = Sb(b2);
    if (c2 !== null) {
      if (b2 = c2.tag, b2 === 13) {
        if (b2 = Tb(c2), b2 !== null) {
          a2.blockedOn = b2;
          Ec(a2.priority, function() {
            Cc(c2);
          });
          return;
        }
      } else if (b2 === 3 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = c2.tag === 3 ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Tc(a2) {
  if (a2.blockedOn !== null)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Uc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (c2 === null) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      tb = d2;
      c2.target.dispatchEvent(d2);
      tb = null;
    } else
      return b2 = zb(c2), b2 !== null && Bc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Vc(a2, b2, c2) {
  Tc(a2) && c2.delete(b2);
}
function Wc() {
  Fc = false;
  Hc !== null && Tc(Hc) && (Hc = null);
  Ic !== null && Tc(Ic) && (Ic = null);
  Jc !== null && Tc(Jc) && (Jc = null);
  Kc.forEach(Vc);
  Lc.forEach(Vc);
}
function Xc(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Fc || (Fc = true, ba.unstable_scheduleCallback(ba.unstable_NormalPriority, Wc)));
}
function Yc(a2) {
  function b2(b3) {
    return Xc(b3, a2);
  }
  if (0 < Gc.length) {
    Xc(Gc[0], a2);
    for (var c2 = 1; c2 < Gc.length; c2++) {
      var d2 = Gc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  Hc !== null && Xc(Hc, a2);
  Ic !== null && Xc(Ic, a2);
  Jc !== null && Xc(Jc, a2);
  Kc.forEach(b2);
  Lc.forEach(b2);
  for (c2 = 0; c2 < Mc.length; c2++)
    d2 = Mc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Mc.length && (c2 = Mc[0], c2.blockedOn === null); )
    Rc(c2), c2.blockedOn === null && Mc.shift();
}
var Zc = sa.ReactCurrentBatchConfig;
function $c(a2, b2, c2, d2) {
  var e2 = E$4, f2 = Zc.transition;
  Zc.transition = null;
  try {
    E$4 = 1, ad(a2, b2, c2, d2);
  } finally {
    E$4 = e2, Zc.transition = f2;
  }
}
function bd(a2, b2, c2, d2) {
  var e2 = E$4, f2 = Zc.transition;
  Zc.transition = null;
  try {
    E$4 = 4, ad(a2, b2, c2, d2);
  } finally {
    E$4 = e2, Zc.transition = f2;
  }
}
function ad(a2, b2, c2, d2) {
  var e2 = Uc(a2, b2, c2, d2);
  if (e2 === null)
    cd(a2, b2, d2, dd, c2), Oc(a2, d2);
  else if (Qc(e2, a2, b2, c2, d2))
    d2.stopPropagation();
  else if (Oc(a2, d2), b2 & 4 && -1 < Nc.indexOf(a2)) {
    for (; e2 !== null; ) {
      var f2 = zb(e2);
      f2 !== null && Ac(f2);
      f2 = Uc(a2, b2, c2, d2);
      f2 === null && cd(a2, b2, d2, dd, c2);
      if (f2 === e2)
        break;
      e2 = f2;
    }
    e2 !== null && d2.stopPropagation();
  } else
    cd(a2, b2, d2, null, c2);
}
var dd = null;
function Uc(a2, b2, c2, d2) {
  dd = null;
  a2 = ub(d2);
  a2 = Sc(a2);
  if (a2 !== null)
    if (b2 = Sb(a2), b2 === null)
      a2 = null;
    else if (c2 = b2.tag, c2 === 13) {
      a2 = Tb(b2);
      if (a2 !== null)
        return a2;
      a2 = null;
    } else if (c2 === 3) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return b2.tag === 3 ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  dd = a2;
  return null;
}
function ed(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (bc()) {
        case cc:
          return 1;
        case dc:
          return 4;
        case ec:
        case fc:
          return 16;
        case gc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var fd = null, gd = null, hd = null;
function id() {
  if (hd)
    return hd;
  var a2, b2 = gd, c2 = b2.length, d2, e2 = "value" in fd ? fd.value : fd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return hd = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function jd(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, a2 === 0 && b2 === 13 && (a2 = 13)) : a2 = b2;
  a2 === 10 && (a2 = 13);
  return 32 <= a2 || a2 === 13 ? a2 : 0;
}
function kd() {
  return true;
}
function ld() {
  return false;
}
function md(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === false) ? kd : ld;
    this.isPropagationStopped = ld;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : typeof a3.returnValue !== "unknown" && (a3.returnValue = false), this.isDefaultPrevented = kd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : typeof a3.cancelBubble !== "unknown" && (a3.cancelBubble = true), this.isPropagationStopped = kd);
  }, persist: function() {
  }, isPersistent: kd });
  return b2;
}
var nd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, od = md(nd), pd = A$3({}, nd, { view: 0, detail: 0 }), qd = md(pd), rd, sd, td, vd = A$3({}, pd, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ud, button: 0, buttons: 0, relatedTarget: function(a2) {
  return a2.relatedTarget === void 0 ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== td && (td && a2.type === "mousemove" ? (rd = a2.screenX - td.screenX, sd = a2.screenY - td.screenY) : sd = rd = 0, td = a2);
  return rd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : sd;
} }), wd = md(vd), xd = A$3({}, vd, { dataTransfer: 0 }), yd = md(xd), zd = A$3({}, pd, { relatedTarget: 0 }), Ad = md(zd), Bd = A$3({}, nd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Cd = md(Bd), Dd = A$3({}, nd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Ed = md(Dd), Fd = A$3({}, nd, { data: 0 }), Gd = md(Fd), Hd = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Id = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Jd = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Kd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Jd[a2]) ? !!b2[a2] : false;
}
function ud() {
  return Kd;
}
var Ld = A$3({}, pd, { key: function(a2) {
  if (a2.key) {
    var b2 = Hd[a2.key] || a2.key;
    if (b2 !== "Unidentified")
      return b2;
  }
  return a2.type === "keypress" ? (a2 = jd(a2), a2 === 13 ? "Enter" : String.fromCharCode(a2)) : a2.type === "keydown" || a2.type === "keyup" ? Id[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ud, charCode: function(a2) {
  return a2.type === "keypress" ? jd(a2) : 0;
}, keyCode: function(a2) {
  return a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
}, which: function(a2) {
  return a2.type === "keypress" ? jd(a2) : a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
} }), Md = md(Ld), Nd = A$3({}, vd, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Od = md(Nd), Pd = A$3({}, pd, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ud }), Qd = md(Pd), Rd = A$3({}, nd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Sd = md(Rd), Td = A$3({}, vd, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Ud = md(Td), Vd = [9, 13, 27, 32], Wd = ha && "CompositionEvent" in window, Xd = null;
ha && "documentMode" in document && (Xd = document.documentMode);
var Yd = ha && "TextEvent" in window && !Xd, Zd = ha && (!Wd || Xd && 8 < Xd && 11 >= Xd), $d = String.fromCharCode(32), ae$1 = false;
function be$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return Vd.indexOf(b2.keyCode) !== -1;
    case "keydown":
      return b2.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function ce$1(a2) {
  a2 = a2.detail;
  return typeof a2 === "object" && "data" in a2 ? a2.data : null;
}
var de$1 = false;
function ee(a2, b2) {
  switch (a2) {
    case "compositionend":
      return ce$1(b2);
    case "keypress":
      if (b2.which !== 32)
        return null;
      ae$1 = true;
      return $d;
    case "textInput":
      return a2 = b2.data, a2 === $d && ae$1 ? null : a2;
    default:
      return null;
  }
}
function fe$1(a2, b2) {
  if (de$1)
    return a2 === "compositionend" || !Wd && be$1(a2, b2) ? (a2 = id(), hd = gd = fd = null, de$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return Zd && b2.locale !== "ko" ? null : b2.data;
    default:
      return null;
  }
}
var ge$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function he$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 === "input" ? !!ge$1[a2.type] : b2 === "textarea" ? true : false;
}
function ie$3(a2, b2, c2, d2) {
  Bb(d2);
  b2 = je$1(b2, "onChange");
  0 < b2.length && (c2 = new od("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var ke$1 = null, le$1 = null;
function me$1(a2) {
  ne(a2, 0);
}
function oe(a2) {
  var b2 = pe$1(a2);
  if (Ua(b2))
    return a2;
}
function qe$1(a2, b2) {
  if (a2 === "change")
    return b2;
}
var re = false;
if (ha) {
  var se$1;
  if (ha) {
    var te$1 = "oninput" in document;
    if (!te$1) {
      var ue$1 = document.createElement("div");
      ue$1.setAttribute("oninput", "return;");
      te$1 = typeof ue$1.oninput === "function";
    }
    se$1 = te$1;
  } else
    se$1 = false;
  re = se$1 && (!document.documentMode || 9 < document.documentMode);
}
function ve$1() {
  ke$1 && (ke$1.detachEvent("onpropertychange", we$1), le$1 = ke$1 = null);
}
function we$1(a2) {
  if (a2.propertyName === "value" && oe(le$1)) {
    var b2 = [];
    ie$3(b2, le$1, a2, ub(a2));
    Gb(me$1, b2);
  }
}
function xe$1(a2, b2, c2) {
  a2 === "focusin" ? (ve$1(), ke$1 = b2, le$1 = c2, ke$1.attachEvent("onpropertychange", we$1)) : a2 === "focusout" && ve$1();
}
function ye$1(a2) {
  if (a2 === "selectionchange" || a2 === "keyup" || a2 === "keydown")
    return oe(le$1);
}
function ze$1(a2, b2) {
  if (a2 === "click")
    return oe(b2);
}
function Ae$1(a2, b2) {
  if (a2 === "input" || a2 === "change")
    return oe(b2);
}
function Be$1(a2, b2) {
  return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var Ce$1 = typeof Object.is === "function" ? Object.is : Be$1;
function De$1(a2, b2) {
  if (Ce$1(a2, b2))
    return true;
  if (typeof a2 !== "object" || a2 === null || typeof b2 !== "object" || b2 === null)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ia.call(b2, e2) || !Ce$1(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Ee$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Fe$1(a2, b2) {
  var c2 = Ee$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (c2.nodeType === 3) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Ee$1(c2);
  }
}
function Ge$1(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && a2.nodeType === 3 ? false : b2 && b2.nodeType === 3 ? Ge$1(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function He$1() {
  for (var a2 = window, b2 = Va(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = typeof b2.contentWindow.location.href === "string";
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Va(a2.document);
  }
  return b2;
}
function Ie$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && (b2 === "input" && (a2.type === "text" || a2.type === "search" || a2.type === "tel" || a2.type === "url" || a2.type === "password") || b2 === "textarea" || a2.contentEditable === "true");
}
function Je$1(a2) {
  var b2 = He$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Ge$1(c2.ownerDocument.documentElement, c2)) {
    if (d2 !== null && Ie$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, a2 === void 0 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = d2.end === void 0 ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Fe$1(c2, f2);
        var g2 = Fe$1(c2, d2);
        e2 && g2 && (a2.rangeCount !== 1 || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      a2.nodeType === 1 && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    typeof c2.focus === "function" && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Ke$1 = ha && "documentMode" in document && 11 >= document.documentMode, Le$1 = null, Me$1 = null, Ne$1 = null, Oe$1 = false;
function Pe$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : c2.nodeType === 9 ? c2 : c2.ownerDocument;
  Oe$1 || Le$1 == null || Le$1 !== Va(d2) || (d2 = Le$1, "selectionStart" in d2 && Ie$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Ne$1 && De$1(Ne$1, d2) || (Ne$1 = d2, d2 = je$1(Me$1, "onSelect"), 0 < d2.length && (b2 = new od("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Le$1)));
}
function Qe(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var Re$1 = { animationend: Qe("Animation", "AnimationEnd"), animationiteration: Qe("Animation", "AnimationIteration"), animationstart: Qe("Animation", "AnimationStart"), transitionend: Qe("Transition", "TransitionEnd") }, Se$1 = {}, Te$1 = {};
ha && (Te$1 = document.createElement("div").style, "AnimationEvent" in window || (delete Re$1.animationend.animation, delete Re$1.animationiteration.animation, delete Re$1.animationstart.animation), "TransitionEvent" in window || delete Re$1.transitionend.transition);
function Ue$1(a2) {
  if (Se$1[a2])
    return Se$1[a2];
  if (!Re$1[a2])
    return a2;
  var b2 = Re$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Te$1)
      return Se$1[a2] = b2[c2];
  return a2;
}
var Ve = Ue$1("animationend"), We$1 = Ue$1("animationiteration"), Xe$1 = Ue$1("animationstart"), Ye$1 = Ue$1("transitionend"), Ze$1 = /* @__PURE__ */ new Map(), $e$1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function af(a2, b2) {
  Ze$1.set(a2, b2);
  ea(b2, [a2]);
}
for (var bf = 0; bf < $e$1.length; bf++) {
  var cf = $e$1[bf], df = cf.toLowerCase(), ef = cf[0].toUpperCase() + cf.slice(1);
  af(df, "on" + ef);
}
af(Ve, "onAnimationEnd");
af(We$1, "onAnimationIteration");
af(Xe$1, "onAnimationStart");
af("dblclick", "onDoubleClick");
af("focusin", "onFocus");
af("focusout", "onBlur");
af(Ye$1, "onTransitionEnd");
fa("onMouseEnter", ["mouseout", "mouseover"]);
fa("onMouseLeave", ["mouseout", "mouseover"]);
fa("onPointerEnter", ["pointerout", "pointerover"]);
fa("onPointerLeave", ["pointerout", "pointerover"]);
ea("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
ea("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
ea("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ea("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
ea("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
ea("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ff = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), gf = new Set("cancel close invalid load scroll toggle".split(" ").concat(ff));
function hf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Rb(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function ne(a2, b2) {
  b2 = (b2 & 4) !== 0;
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          hf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          hf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Nb)
    throw a2 = Ob, Nb = false, Ob = null, a2;
}
function F$2(a2, b2) {
  var c2 = b2[jf];
  c2 === void 0 && (c2 = b2[jf] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (kf(b2, a2, 2, false), c2.add(d2));
}
function lf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  kf(c2, a2, d2, b2);
}
var mf = "_reactListening" + Math.random().toString(36).slice(2);
function nf(a2) {
  if (!a2[mf]) {
    a2[mf] = true;
    ca.forEach(function(b3) {
      b3 !== "selectionchange" && (gf.has(b3) || lf(b3, false, a2), lf(b3, true, a2));
    });
    var b2 = a2.nodeType === 9 ? a2 : a2.ownerDocument;
    b2 === null || b2[mf] || (b2[mf] = true, lf("selectionchange", false, b2));
  }
}
function kf(a2, b2, c2, d2) {
  switch (ed(b2)) {
    case 1:
      var e2 = $c;
      break;
    case 4:
      e2 = bd;
      break;
    default:
      e2 = ad;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Ib || b2 !== "touchstart" && b2 !== "touchmove" && b2 !== "wheel" || (e2 = true);
  d2 ? e2 !== void 0 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : e2 !== void 0 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function cd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if ((b2 & 1) === 0 && (b2 & 2) === 0 && d2 !== null)
    a:
      for (; ; ) {
        if (d2 === null)
          return;
        var g2 = d2.tag;
        if (g2 === 3 || g2 === 4) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || h2.nodeType === 8 && h2.parentNode === e2)
            break;
          if (g2 === 4)
            for (g2 = d2.return; g2 !== null; ) {
              var k2 = g2.tag;
              if (k2 === 3 || k2 === 4) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || k2.nodeType === 8 && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; h2 !== null; ) {
            g2 = Sc(h2);
            if (g2 === null)
              return;
            k2 = g2.tag;
            if (k2 === 5 || k2 === 6) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Gb(function() {
    var d3 = f2, e3 = ub(c2), g3 = [];
    a: {
      var h3 = Ze$1.get(a2);
      if (h3 !== void 0) {
        var k3 = od, n2 = a2;
        switch (a2) {
          case "keypress":
            if (jd(c2) === 0)
              break a;
          case "keydown":
          case "keyup":
            k3 = Md;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Ad;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Ad;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Ad;
            break;
          case "click":
            if (c2.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = wd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = yd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Qd;
            break;
          case Ve:
          case We$1:
          case Xe$1:
            k3 = Cd;
            break;
          case Ye$1:
            k3 = Sd;
            break;
          case "scroll":
            k3 = qd;
            break;
          case "wheel":
            k3 = Ud;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Ed;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Od;
        }
        var v2 = (b2 & 4) !== 0, C2 = !v2 && a2 === "scroll", t2 = v2 ? h3 !== null ? h3 + "Capture" : null : h3;
        v2 = [];
        for (var r2 = d3, x2; r2 !== null; ) {
          x2 = r2;
          var B2 = x2.stateNode;
          x2.tag === 5 && B2 !== null && (x2 = B2, t2 !== null && (B2 = Hb(r2, t2), B2 != null && v2.push(of(r2, B2, x2))));
          if (C2)
            break;
          r2 = r2.return;
        }
        0 < v2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: v2 }));
      }
    }
    if ((b2 & 7) === 0) {
      a: {
        h3 = a2 === "mouseover" || a2 === "pointerover";
        k3 = a2 === "mouseout" || a2 === "pointerout";
        if (h3 && c2 !== tb && (n2 = c2.relatedTarget || c2.fromElement) && (Sc(n2) || n2[pf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Sc(n2) : null, n2 !== null && (C2 = Sb(n2), n2 !== C2 || n2.tag !== 5 && n2.tag !== 6))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            v2 = wd;
            B2 = "onMouseLeave";
            t2 = "onMouseEnter";
            r2 = "mouse";
            if (a2 === "pointerout" || a2 === "pointerover")
              v2 = Od, B2 = "onPointerLeave", t2 = "onPointerEnter", r2 = "pointer";
            C2 = k3 == null ? h3 : pe$1(k3);
            x2 = n2 == null ? h3 : pe$1(n2);
            h3 = new v2(B2, r2 + "leave", k3, c2, e3);
            h3.target = C2;
            h3.relatedTarget = x2;
            B2 = null;
            Sc(e3) === d3 && (v2 = new v2(t2, r2 + "enter", n2, c2, e3), v2.target = x2, v2.relatedTarget = C2, B2 = v2);
            C2 = B2;
            if (k3 && n2)
              b: {
                v2 = k3;
                t2 = n2;
                r2 = 0;
                for (x2 = v2; x2; x2 = qf(x2))
                  r2++;
                x2 = 0;
                for (B2 = t2; B2; B2 = qf(B2))
                  x2++;
                for (; 0 < r2 - x2; )
                  v2 = qf(v2), r2--;
                for (; 0 < x2 - r2; )
                  t2 = qf(t2), x2--;
                for (; r2--; ) {
                  if (v2 === t2 || t2 !== null && v2 === t2.alternate)
                    break b;
                  v2 = qf(v2);
                  t2 = qf(t2);
                }
                v2 = null;
              }
            else
              v2 = null;
            k3 !== null && rf(g3, h3, k3, v2, false);
            n2 !== null && C2 !== null && rf(g3, C2, n2, v2, true);
          }
        }
      }
      a: {
        h3 = d3 ? pe$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if (k3 === "select" || k3 === "input" && h3.type === "file")
          var O2 = qe$1;
        else if (he$1(h3))
          if (re)
            O2 = Ae$1;
          else {
            O2 = ye$1;
            var T2 = xe$1;
          }
        else
          (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (O2 = ze$1);
        if (O2 && (O2 = O2(a2, d3))) {
          ie$3(g3, O2, c2, e3);
          break a;
        }
        T2 && T2(a2, h3, d3);
        a2 === "focusout" && (T2 = h3._wrapperState) && T2.controlled && h3.type === "number" && $a(h3, "number", h3.value);
      }
      T2 = d3 ? pe$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (he$1(T2) || T2.contentEditable === "true")
            Le$1 = T2, Me$1 = d3, Ne$1 = null;
          break;
        case "focusout":
          Ne$1 = Me$1 = Le$1 = null;
          break;
        case "mousedown":
          Oe$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Oe$1 = false;
          Pe$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Ke$1)
            break;
        case "keydown":
        case "keyup":
          Pe$1(g3, c2, e3);
      }
      var za;
      if (Wd)
        b: {
          switch (a2) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        de$1 ? be$1(a2, c2) && (L2 = "onCompositionEnd") : a2 === "keydown" && c2.keyCode === 229 && (L2 = "onCompositionStart");
      L2 && (Zd && c2.locale !== "ko" && (de$1 || L2 !== "onCompositionStart" ? L2 === "onCompositionEnd" && de$1 && (za = id()) : (fd = e3, gd = "value" in fd ? fd.value : fd.textContent, de$1 = true)), T2 = je$1(d3, L2), 0 < T2.length && (L2 = new Gd(L2, a2, null, c2, e3), g3.push({ event: L2, listeners: T2 }), za ? L2.data = za : (za = ce$1(c2), za !== null && (L2.data = za))));
      if (za = Yd ? ee(a2, c2) : fe$1(a2, c2))
        d3 = je$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Gd("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = za);
    }
    ne(g3, b2);
  });
}
function of(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function je$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; a2 !== null; ) {
    var e2 = a2, f2 = e2.stateNode;
    e2.tag === 5 && f2 !== null && (e2 = f2, f2 = Hb(a2, c2), f2 != null && d2.unshift(of(a2, f2, e2)), f2 = Hb(a2, b2), f2 != null && d2.push(of(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function qf(a2) {
  if (a2 === null)
    return null;
  do
    a2 = a2.return;
  while (a2 && a2.tag !== 5);
  return a2 ? a2 : null;
}
function rf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; c2 !== null && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (k2 !== null && k2 === d2)
      break;
    h2.tag === 5 && l2 !== null && (h2 = l2, e2 ? (k2 = Hb(c2, f2), k2 != null && g2.unshift(of(c2, k2, h2))) : e2 || (k2 = Hb(c2, f2), k2 != null && g2.push(of(c2, k2, h2))));
    c2 = c2.return;
  }
  g2.length !== 0 && a2.push({ event: b2, listeners: g2 });
}
var sf = /\r\n?/g, tf = /\u0000|\uFFFD/g;
function uf(a2) {
  return (typeof a2 === "string" ? a2 : "" + a2).replace(sf, "\n").replace(tf, "");
}
function vf(a2, b2, c2) {
  b2 = uf(b2);
  if (uf(a2) !== b2 && c2)
    throw Error(p$7(425));
}
function wf() {
}
var xf = null;
function yf(a2, b2) {
  return a2 === "textarea" || a2 === "noscript" || typeof b2.children === "string" || typeof b2.children === "number" || typeof b2.dangerouslySetInnerHTML === "object" && b2.dangerouslySetInnerHTML !== null && b2.dangerouslySetInnerHTML.__html != null;
}
var zf = typeof setTimeout === "function" ? setTimeout : void 0, Af = typeof clearTimeout === "function" ? clearTimeout : void 0, Bf = typeof Promise === "function" ? Promise : void 0, Df = typeof queueMicrotask === "function" ? queueMicrotask : typeof Bf !== "undefined" ? function(a2) {
  return Bf.resolve(null).then(a2).catch(Cf);
} : zf;
function Cf(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Ef(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && e2.nodeType === 8)
      if (c2 = e2.data, c2 === "/$") {
        if (d2 === 0) {
          a2.removeChild(e2);
          Yc(b2);
          return;
        }
        d2--;
      } else
        c2 !== "$" && c2 !== "$?" && c2 !== "$!" || d2++;
    c2 = e2;
  } while (c2);
  Yc(b2);
}
function Ff(a2) {
  for (; a2 != null; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (b2 === 1 || b2 === 3)
      break;
    if (b2 === 8) {
      b2 = a2.data;
      if (b2 === "$" || b2 === "$!" || b2 === "$?")
        break;
      if (b2 === "/$")
        return null;
    }
  }
  return a2;
}
function Gf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (a2.nodeType === 8) {
      var c2 = a2.data;
      if (c2 === "$" || c2 === "$!" || c2 === "$?") {
        if (b2 === 0)
          return a2;
        b2--;
      } else
        c2 === "/$" && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Hf = Math.random().toString(36).slice(2), If = "__reactFiber$" + Hf, Jf = "__reactProps$" + Hf, pf = "__reactContainer$" + Hf, jf = "__reactEvents$" + Hf, Kf = "__reactListeners$" + Hf, Lf = "__reactHandles$" + Hf;
function Sc(a2) {
  var b2 = a2[If];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[pf] || c2[If]) {
      c2 = b2.alternate;
      if (b2.child !== null || c2 !== null && c2.child !== null)
        for (a2 = Gf(a2); a2 !== null; ) {
          if (c2 = a2[If])
            return c2;
          a2 = Gf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function zb(a2) {
  a2 = a2[If] || a2[pf];
  return !a2 || a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 13 && a2.tag !== 3 ? null : a2;
}
function pe$1(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2.stateNode;
  throw Error(p$7(33));
}
function Ab(a2) {
  return a2[Jf] || null;
}
var Mf = [], Nf = -1;
function Of(a2) {
  return { current: a2 };
}
function G(a2) {
  0 > Nf || (a2.current = Mf[Nf], Mf[Nf] = null, Nf--);
}
function H(a2, b2) {
  Nf++;
  Mf[Nf] = a2.current;
  a2.current = b2;
}
var Pf = {}, I$1 = Of(Pf), Qf = Of(false), Rf = Pf;
function Sf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Pf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Tf(a2) {
  a2 = a2.childContextTypes;
  return a2 !== null && a2 !== void 0;
}
function Uf() {
  G(Qf);
  G(I$1);
}
function Vf(a2, b2, c2) {
  if (I$1.current !== Pf)
    throw Error(p$7(168));
  H(I$1, b2);
  H(Qf, c2);
}
function Wf(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if (typeof d2.getChildContext !== "function")
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$7(108, Pa(a2) || "Unknown", e2));
  return A$3({}, c2, d2);
}
function Xf(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Pf;
  Rf = I$1.current;
  H(I$1, a2);
  H(Qf, Qf.current);
  return true;
}
function Yf(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$7(169));
  c2 ? (a2 = Wf(a2, b2, Rf), d2.__reactInternalMemoizedMergedChildContext = a2, G(Qf), G(I$1), H(I$1, a2)) : G(Qf);
  H(Qf, c2);
}
var Zf = null, $f = false, ag = false;
function bg(a2) {
  Zf === null ? Zf = [a2] : Zf.push(a2);
}
function cg(a2) {
  $f = true;
  bg(a2);
}
function dg() {
  if (!ag && Zf !== null) {
    ag = true;
    var a2 = 0, b2 = E$4;
    try {
      var c2 = Zf;
      for (E$4 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (d2 !== null);
      }
      Zf = null;
      $f = false;
    } catch (e2) {
      throw Zf !== null && (Zf = Zf.slice(a2 + 1)), Yb(cc, dg), e2;
    } finally {
      E$4 = b2, ag = false;
    }
  }
  return null;
}
var eg = sa.ReactCurrentBatchConfig;
function fg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      b2[c2] === void 0 && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var gg = Of(null), hg = null, ig = null, jg = null;
function kg() {
  jg = ig = hg = null;
}
function lg(a2) {
  var b2 = gg.current;
  G(gg);
  a2._currentValue = b2;
}
function mg(a2, b2, c2) {
  for (; a2 !== null; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, d2 !== null && (d2.childLanes |= b2)) : d2 !== null && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function ng(a2, b2) {
  hg = a2;
  jg = ig = null;
  a2 = a2.dependencies;
  a2 !== null && a2.firstContext !== null && ((a2.lanes & b2) !== 0 && (og = true), a2.firstContext = null);
}
function pg(a2) {
  var b2 = a2._currentValue;
  if (jg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, ig === null) {
      if (hg === null)
        throw Error(p$7(308));
      ig = a2;
      hg.dependencies = { lanes: 0, firstContext: a2 };
    } else
      ig = ig.next = a2;
  return b2;
}
var qg = null, rg = false;
function sg(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function tg(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ug(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function vg(a2, b2) {
  var c2 = a2.updateQueue;
  c2 !== null && (c2 = c2.shared, J !== null && (a2.mode & 1) !== 0 && (K$1 & 2) === 0 ? (a2 = c2.interleaved, a2 === null ? (b2.next = b2, qg === null ? qg = [c2] : qg.push(c2)) : (b2.next = a2.next, a2.next = b2), c2.interleaved = b2) : (a2 = c2.pending, a2 === null ? b2.next = b2 : (b2.next = a2.next, a2.next = b2), c2.pending = b2));
}
function wg(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (b2 !== null && (b2 = b2.shared, (c2 & 4194240) !== 0)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    yc(a2, c2);
  }
}
function xg(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (d2 !== null && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (c2 !== null) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        f2 === null ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (c2 !== null);
      f2 === null ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  a2 === null ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function yg(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  rg = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (h2 !== null) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    g2 === null ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    m2 !== null && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (h2 === null ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (f2 !== null) {
    var w2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var u2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & u2) === u2) {
        m2 !== null && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, v2 = h2;
          u2 = b2;
          y2 = c2;
          switch (v2.tag) {
            case 1:
              n2 = v2.payload;
              if (typeof n2 === "function") {
                w2 = n2.call(y2, w2, u2);
                break a;
              }
              w2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = v2.payload;
              u2 = typeof n2 === "function" ? n2.call(y2, w2, u2) : n2;
              if (u2 === null || u2 === void 0)
                break a;
              w2 = A$3({}, w2, u2);
              break a;
            case 2:
              rg = true;
          }
        }
        h2.callback !== null && h2.lane !== 0 && (a2.flags |= 64, u2 = e2.effects, u2 === null ? e2.effects = [h2] : u2.push(h2));
      } else
        y2 = { eventTime: y2, lane: u2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, m2 === null ? (l2 = m2 = y2, k2 = w2) : m2 = m2.next = y2, g2 |= u2;
      h2 = h2.next;
      if (h2 === null)
        if (h2 = e2.shared.pending, h2 === null)
          break;
        else
          u2 = h2, h2 = u2.next, u2.next = null, e2.lastBaseUpdate = u2, e2.shared.pending = null;
    } while (1);
    m2 === null && (k2 = w2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (b2 !== null) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      f2 === null && (e2.shared.lanes = 0);
    zg |= g2;
    a2.lanes = g2;
    a2.memoizedState = w2;
  }
}
function Ag(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (a2 !== null)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (e2 !== null) {
        d2.callback = null;
        d2 = c2;
        if (typeof e2 !== "function")
          throw Error(p$7(191, e2));
        e2.call(d2);
      }
    }
}
var Bg = new aa.Component().refs;
function Cg(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = c2 === null || c2 === void 0 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  a2.lanes === 0 && (a2.updateQueue.baseState = c2);
}
var Fg = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Sb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = M$2(), e2 = Dg(a2), f2 = ug(d2, e2);
  f2.payload = b2;
  c2 !== void 0 && c2 !== null && (f2.callback = c2);
  vg(a2, f2);
  b2 = Eg(a2, e2, d2);
  b2 !== null && wg(b2, a2, e2);
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = M$2(), e2 = Dg(a2), f2 = ug(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  c2 !== void 0 && c2 !== null && (f2.callback = c2);
  vg(a2, f2);
  b2 = Eg(a2, e2, d2);
  b2 !== null && wg(b2, a2, e2);
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = M$2(), d2 = Dg(a2), e2 = ug(c2, d2);
  e2.tag = 2;
  b2 !== void 0 && b2 !== null && (e2.callback = b2);
  vg(a2, e2);
  b2 = Eg(a2, d2, c2);
  b2 !== null && wg(b2, a2, d2);
} };
function Gg(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return typeof a2.shouldComponentUpdate === "function" ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !De$1(c2, d2) || !De$1(e2, f2) : true;
}
function Hg(a2, b2, c2) {
  var d2 = false, e2 = Pf;
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? f2 = pg(f2) : (e2 = Tf(b2) ? Rf : I$1.current, d2 = b2.contextTypes, f2 = (d2 = d2 !== null && d2 !== void 0) ? Sf(a2, e2) : Pf);
  b2 = new b2(c2, f2);
  a2.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null;
  b2.updater = Fg;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Ig(a2, b2, c2, d2) {
  a2 = b2.state;
  typeof b2.componentWillReceiveProps === "function" && b2.componentWillReceiveProps(c2, d2);
  typeof b2.UNSAFE_componentWillReceiveProps === "function" && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Fg.enqueueReplaceState(b2, b2.state, null);
}
function Jg(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = Bg;
  sg(a2);
  var f2 = b2.contextType;
  typeof f2 === "object" && f2 !== null ? e2.context = pg(f2) : (f2 = Tf(b2) ? Rf : I$1.current, e2.context = Sf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  typeof f2 === "function" && (Cg(a2, b2, f2, c2), e2.state = a2.memoizedState);
  typeof b2.getDerivedStateFromProps === "function" || typeof e2.getSnapshotBeforeUpdate === "function" || typeof e2.UNSAFE_componentWillMount !== "function" && typeof e2.componentWillMount !== "function" || (b2 = e2.state, typeof e2.componentWillMount === "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount === "function" && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Fg.enqueueReplaceState(e2, e2.state, null), yg(a2, c2, e2, d2), e2.state = a2.memoizedState);
  typeof e2.componentDidMount === "function" && (a2.flags |= 4194308);
}
var Kg = [], Lg = 0, Mg = null, Ng = 0, Og = [], Pg = 0, Qg = null, Rg = 1, Sg = "";
function Tg(a2, b2) {
  Kg[Lg++] = Ng;
  Kg[Lg++] = Mg;
  Mg = a2;
  Ng = b2;
}
function Ug(a2, b2, c2) {
  Og[Pg++] = Rg;
  Og[Pg++] = Sg;
  Og[Pg++] = Qg;
  Qg = a2;
  var d2 = Rg;
  a2 = Sg;
  var e2 = 32 - lc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - lc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    Rg = 1 << 32 - lc(b2) + e2 | c2 << e2 | d2;
    Sg = f2 + a2;
  } else
    Rg = 1 << f2 | c2 << e2 | d2, Sg = a2;
}
function Vg(a2) {
  a2.return !== null && (Tg(a2, 1), Ug(a2, 1, 0));
}
function Wg(a2) {
  for (; a2 === Mg; )
    Mg = Kg[--Lg], Kg[Lg] = null, Ng = Kg[--Lg], Kg[Lg] = null;
  for (; a2 === Qg; )
    Qg = Og[--Pg], Og[Pg] = null, Sg = Og[--Pg], Og[Pg] = null, Rg = Og[--Pg], Og[Pg] = null;
}
var Xg = null, Yg = null, N = false, Zg = null;
function $g(a2, b2) {
  var c2 = ah(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  b2 === null ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function bh(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = b2.nodeType !== 1 || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return b2 !== null ? (a2.stateNode = b2, Xg = a2, Yg = Ff(b2.firstChild), true) : false;
    case 6:
      return b2 = a2.pendingProps === "" || b2.nodeType !== 3 ? null : b2, b2 !== null ? (a2.stateNode = b2, Xg = a2, Yg = null, true) : false;
    case 13:
      return b2 = b2.nodeType !== 8 ? null : b2, b2 !== null ? (c2 = Qg !== null ? { id: Rg, overflow: Sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = ah(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, Xg = a2, Yg = null, true) : false;
    default:
      return false;
  }
}
function ch(a2) {
  return (a2.mode & 1) !== 0 && (a2.flags & 128) === 0;
}
function dh(a2) {
  if (N) {
    var b2 = Yg;
    if (b2) {
      var c2 = b2;
      if (!bh(a2, b2)) {
        if (ch(a2))
          throw Error(p$7(418));
        b2 = Ff(c2.nextSibling);
        var d2 = Xg;
        b2 && bh(a2, b2) ? $g(d2, c2) : (a2.flags = a2.flags & -4097 | 2, N = false, Xg = a2);
      }
    } else {
      if (ch(a2))
        throw Error(p$7(418));
      a2.flags = a2.flags & -4097 | 2;
      N = false;
      Xg = a2;
    }
  }
}
function eh(a2) {
  for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
    a2 = a2.return;
  Xg = a2;
}
function fh(a2) {
  if (a2 !== Xg)
    return false;
  if (!N)
    return eh(a2), N = true, false;
  var b2;
  (b2 = a2.tag !== 3) && !(b2 = a2.tag !== 5) && (b2 = a2.type, b2 = b2 !== "head" && b2 !== "body" && !yf(a2.type, a2.memoizedProps));
  if (b2 && (b2 = Yg)) {
    if (ch(a2)) {
      for (a2 = Yg; a2; )
        a2 = Ff(a2.nextSibling);
      throw Error(p$7(418));
    }
    for (; b2; )
      $g(a2, b2), b2 = Ff(b2.nextSibling);
  }
  eh(a2);
  if (a2.tag === 13) {
    a2 = a2.memoizedState;
    a2 = a2 !== null ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$7(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (a2.nodeType === 8) {
          var c2 = a2.data;
          if (c2 === "/$") {
            if (b2 === 0) {
              Yg = Ff(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            c2 !== "$" && c2 !== "$!" && c2 !== "$?" || b2++;
        }
        a2 = a2.nextSibling;
      }
      Yg = null;
    }
  } else
    Yg = Xg ? Ff(a2.stateNode.nextSibling) : null;
  return true;
}
function gh() {
  Yg = Xg = null;
  N = false;
}
function hh(a2) {
  Zg === null ? Zg = [a2] : Zg.push(a2);
}
function ih(a2, b2, c2) {
  a2 = c2.ref;
  if (a2 !== null && typeof a2 !== "function" && typeof a2 !== "object") {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (c2.tag !== 1)
          throw Error(p$7(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$7(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (b2 !== null && b2.ref !== null && typeof b2.ref === "function" && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === Bg && (b3 = e2.refs = {});
        a3 === null ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if (typeof a2 !== "string")
      throw Error(p$7(284));
    if (!c2._owner)
      throw Error(p$7(290, a2));
  }
  return a2;
}
function jh(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$7(31, a2 === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function kh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function lh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      d3 === null ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; d3 !== null; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); b3 !== null; )
      b3.key !== null ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = mh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (d3 !== null)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && b3.alternate === null && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (b3 === null || b3.tag !== 6)
      return b3 = nh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === va)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (b3 !== null && (b3.elementType === f3 || typeof f3 === "object" && f3 !== null && f3.$$typeof === Fa && kh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = ih(a3, b3, c3), d3.return = a3, d3;
    d3 = oh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = ih(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = ph(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (b3 === null || b3.tag !== 7)
      return b3 = qh(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function w2(a3, b3, c3) {
    if (typeof b3 === "string" && b3 !== "" || typeof b3 === "number")
      return b3 = nh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if (typeof b3 === "object" && b3 !== null) {
      switch (b3.$$typeof) {
        case ta:
          return c3 = oh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = ih(a3, null, b3), c3.return = a3, c3;
        case ua:
          return b3 = ph(b3, a3.mode, c3), b3.return = a3, b3;
        case Fa:
          var d3 = b3._init;
          return w2(a3, d3(b3._payload), c3);
      }
      if (bb(b3) || Ia(b3))
        return b3 = qh(b3, a3.mode, c3, null), b3.return = a3, b3;
      jh(a3, b3);
    }
    return null;
  }
  function u2(a3, b3, c3, d3) {
    var e3 = b3 !== null ? b3.key : null;
    if (typeof c3 === "string" && c3 !== "" || typeof c3 === "number")
      return e3 !== null ? null : h2(a3, b3, "" + c3, d3);
    if (typeof c3 === "object" && c3 !== null) {
      switch (c3.$$typeof) {
        case ta:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case ua:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Fa:
          return e3 = c3._init, u2(a3, b3, e3(c3._payload), d3);
      }
      if (bb(c3) || Ia(c3))
        return e3 !== null ? null : m2(a3, b3, c3, d3, null);
      jh(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if (typeof d3 === "string" && d3 !== "" || typeof d3 === "number")
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if (typeof d3 === "object" && d3 !== null) {
      switch (d3.$$typeof) {
        case ta:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case ua:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Fa:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (bb(d3) || Ia(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      jh(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, n3 = null, m3 = g3, r2 = g3 = 0, x2 = null; m3 !== null && r2 < h3.length; r2++) {
      m3.index > r2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t2 = u2(e3, m3, h3[r2], k3);
      if (t2 === null) {
        m3 === null && (m3 = x2);
        break;
      }
      a2 && m3 && t2.alternate === null && b2(e3, m3);
      g3 = f2(t2, g3, r2);
      n3 === null ? l3 = t2 : n3.sibling = t2;
      n3 = t2;
      m3 = x2;
    }
    if (r2 === h3.length)
      return c2(e3, m3), N && Tg(e3, r2), l3;
    if (m3 === null) {
      for (; r2 < h3.length; r2++)
        m3 = w2(e3, h3[r2], k3), m3 !== null && (g3 = f2(m3, g3, r2), n3 === null ? l3 = m3 : n3.sibling = m3, n3 = m3);
      N && Tg(e3, r2);
      return l3;
    }
    for (m3 = d2(e3, m3); r2 < h3.length; r2++)
      x2 = y2(m3, e3, r2, h3[r2], k3), x2 !== null && (a2 && x2.alternate !== null && m3.delete(x2.key === null ? r2 : x2.key), g3 = f2(x2, g3, r2), n3 === null ? l3 = x2 : n3.sibling = x2, n3 = x2);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    N && Tg(e3, r2);
    return l3;
  }
  function v2(e3, g3, h3, k3) {
    var l3 = Ia(h3);
    if (typeof l3 !== "function")
      throw Error(p$7(150));
    h3 = l3.call(h3);
    if (h3 == null)
      throw Error(p$7(151));
    for (var m3 = l3 = null, n3 = g3, r2 = g3 = 0, x2 = null, t2 = h3.next(); n3 !== null && !t2.done; r2++, t2 = h3.next()) {
      n3.index > r2 ? (x2 = n3, n3 = null) : x2 = n3.sibling;
      var v3 = u2(e3, n3, t2.value, k3);
      if (v3 === null) {
        n3 === null && (n3 = x2);
        break;
      }
      a2 && n3 && v3.alternate === null && b2(e3, n3);
      g3 = f2(v3, g3, r2);
      m3 === null ? l3 = v3 : m3.sibling = v3;
      m3 = v3;
      n3 = x2;
    }
    if (t2.done)
      return c2(e3, n3), N && Tg(e3, r2), l3;
    if (n3 === null) {
      for (; !t2.done; r2++, t2 = h3.next())
        t2 = w2(e3, t2.value, k3), t2 !== null && (g3 = f2(t2, g3, r2), m3 === null ? l3 = t2 : m3.sibling = t2, m3 = t2);
      N && Tg(e3, r2);
      return l3;
    }
    for (n3 = d2(e3, n3); !t2.done; r2++, t2 = h3.next())
      t2 = y2(n3, e3, r2, t2.value, k3), t2 !== null && (a2 && t2.alternate !== null && n3.delete(t2.key === null ? r2 : t2.key), g3 = f2(t2, g3, r2), m3 === null ? l3 = t2 : m3.sibling = t2, m3 = t2);
    a2 && n3.forEach(function(a3) {
      return b2(e3, a3);
    });
    N && Tg(e3, r2);
    return l3;
  }
  function C2(a3, d3, f3, h3) {
    typeof f3 === "object" && f3 !== null && f3.type === va && f3.key === null && (f3 = f3.props.children);
    if (typeof f3 === "object" && f3 !== null) {
      switch (f3.$$typeof) {
        case ta:
          a: {
            for (var k3 = f3.key, l3 = d3; l3 !== null; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === va) {
                  if (l3.tag === 7) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || typeof k3 === "object" && k3 !== null && k3.$$typeof === Fa && kh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = ih(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === va ? (d3 = qh(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = oh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = ih(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case ua:
          a: {
            for (l3 = f3.key; d3 !== null; ) {
              if (d3.key === l3)
                if (d3.tag === 4 && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = ph(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Fa:
          return l3 = f3._init, C2(a3, d3, l3(f3._payload), h3);
      }
      if (bb(f3))
        return n2(a3, d3, f3, h3);
      if (Ia(f3))
        return v2(a3, d3, f3, h3);
      jh(a3, f3);
    }
    return typeof f3 === "string" && f3 !== "" || typeof f3 === "number" ? (f3 = "" + f3, d3 !== null && d3.tag === 6 ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = nh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return C2;
}
var rh = lh(true), sh = lh(false), th = {}, uh = Of(th), vh = Of(th), wh = Of(th);
function xh(a2) {
  if (a2 === th)
    throw Error(p$7(174));
  return a2;
}
function yh(a2, b2) {
  H(wh, b2);
  H(vh, a2);
  H(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : ib(null, "");
      break;
    default:
      a2 = a2 === 8 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = ib(b2, a2);
  }
  G(uh);
  H(uh, b2);
}
function zh() {
  G(uh);
  G(vh);
  G(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = ib(b2, a2.type);
  b2 !== c2 && (H(vh, a2), H(uh, c2));
}
function Bh(a2) {
  vh.current === a2 && (G(uh), G(vh));
}
var P$2 = Of(0);
function Ch(a2) {
  for (var b2 = a2; b2 !== null; ) {
    if (b2.tag === 13) {
      var c2 = b2.memoizedState;
      if (c2 !== null && (c2 = c2.dehydrated, c2 === null || c2.data === "$?" || c2.data === "$!"))
        return b2;
    } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
      if ((b2.flags & 128) !== 0)
        return b2;
    } else if (b2.child !== null) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; b2.sibling === null; ) {
      if (b2.return === null || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++)
    Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = sa.ReactCurrentDispatcher, Gh = sa.ReactCurrentBatchConfig, Hh = 0, Q = null, R$5 = null, S$2 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function U$1() {
  throw Error(p$7(321));
}
function Mh(a2, b2) {
  if (b2 === null)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!Ce$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  Q = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = a2 === null || a2.memoizedState === null ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2)
        throw Error(p$7(301));
      f2 += 1;
      S$2 = R$5 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = R$5 !== null && R$5.next !== null;
  Hh = 0;
  S$2 = R$5 = Q = null;
  Ih = false;
  if (b2)
    throw Error(p$7(300));
  return a2;
}
function Sh() {
  var a2 = Kh !== 0;
  Kh = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  S$2 === null ? Q.memoizedState = S$2 = a2 : S$2 = S$2.next = a2;
  return S$2;
}
function Uh() {
  if (R$5 === null) {
    var a2 = Q.alternate;
    a2 = a2 !== null ? a2.memoizedState : null;
  } else
    a2 = R$5.next;
  var b2 = S$2 === null ? Q.memoizedState : S$2.next;
  if (b2 !== null)
    S$2 = b2, R$5 = a2;
  else {
    if (a2 === null)
      throw Error(p$7(310));
    R$5 = a2;
    a2 = { memoizedState: R$5.memoizedState, baseState: R$5.baseState, baseQueue: R$5.baseQueue, queue: R$5.queue, next: null };
    S$2 === null ? Q.memoizedState = S$2 = a2 : S$2 = S$2.next = a2;
  }
  return S$2;
}
function Vh(a2, b2) {
  return typeof b2 === "function" ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = R$5, e2 = d2.baseQueue, f2 = c2.pending;
  if (f2 !== null) {
    if (e2 !== null) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (e2 !== null) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2)
        k2 !== null && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var w2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        k2 === null ? (h2 = k2 = w2, g2 = d2) : k2 = k2.next = w2;
        Q.lanes |= m2;
        zg |= m2;
      }
      l2 = l2.next;
    } while (l2 !== null && l2 !== f2);
    k2 === null ? g2 = d2 : k2.next = h2;
    Ce$1(d2, b2.memoizedState) || (og = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (a2 !== null) {
    e2 = a2;
    do
      f2 = e2.lane, Q.lanes |= f2, zg |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    e2 === null && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (e2 !== null) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    Ce$1(f2, b2.memoizedState) || (og = true);
    b2.memoizedState = f2;
    b2.baseQueue === null && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = Q, d2 = Uh(), e2 = b2(), f2 = !Ce$1(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, og = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || S$2 !== null && S$2.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (J === null)
      throw Error(p$7(349));
    (Hh & 30) !== 0 || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = Q.updateQueue;
  b2 === null ? (b2 = { lastEffect: null, stores: null }, Q.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, c2 === null ? b2.stores = [a2] : c2.push(a2));
}
function ci(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && Eg(a2, 1, -1);
}
function ai(a2, b2, c2) {
  return c2(function() {
    ei(b2) && Eg(a2, 1, -1);
  });
}
function ei(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !Ce$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = Th();
  typeof a2 === "function" && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = gi.bind(null, Q, a2);
  return [b2.memoizedState, a2];
}
function bi(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = Q.updateQueue;
  b2 === null ? (b2 = { lastEffect: null, stores: null }, Q.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, c2 === null ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function hi() {
  return Uh().memoizedState;
}
function ii(a2, b2, c2, d2) {
  var e2 = Th();
  Q.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, void 0, d2 === void 0 ? null : d2);
}
function ji(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = d2 === void 0 ? null : d2;
  var f2 = void 0;
  if (R$5 !== null) {
    var g2 = R$5.memoizedState;
    f2 = g2.destroy;
    if (d2 !== null && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  Q.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function ki(a2, b2) {
  return ii(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return ji(2048, 8, a2, b2);
}
function li(a2, b2) {
  return ji(4, 2, a2, b2);
}
function mi(a2, b2) {
  return ji(4, 4, a2, b2);
}
function ni(a2, b2) {
  if (typeof b2 === "function")
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (b2 !== null && b2 !== void 0)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function oi(a2, b2, c2) {
  c2 = c2 !== null && c2 !== void 0 ? c2.concat([a2]) : null;
  return ji(4, 4, ni.bind(null, b2, a2), c2);
}
function pi() {
}
function qi(a2, b2) {
  var c2 = Uh();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  if (d2 !== null && b2 !== null && Mh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ri(a2, b2) {
  var c2 = Uh();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  if (d2 !== null && b2 !== null && Mh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function si(a2, b2) {
  var c2 = E$4;
  E$4 = c2 !== 0 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    E$4 = c2, Gh.transition = d2;
  }
}
function ti() {
  return Uh().memoizedState;
}
function ui(a2, b2, c2) {
  var d2 = Dg(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  vi(a2) ? wi(b2, c2) : (xi(a2, b2, c2), c2 = M$2(), a2 = Eg(a2, d2, c2), a2 !== null && yi(a2, b2, d2));
}
function gi(a2, b2, c2) {
  var d2 = Dg(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (vi(a2))
    wi(b2, e2);
  else {
    xi(a2, b2, e2);
    var f2 = a2.alternate;
    if (a2.lanes === 0 && (f2 === null || f2.lanes === 0) && (f2 = b2.lastRenderedReducer, f2 !== null))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (Ce$1(h2, g2))
          return;
      } catch (k2) {
      } finally {
      }
    c2 = M$2();
    a2 = Eg(a2, d2, c2);
    a2 !== null && yi(a2, b2, d2);
  }
}
function vi(a2) {
  var b2 = a2.alternate;
  return a2 === Q || b2 !== null && b2 === Q;
}
function wi(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  c2 === null ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function xi(a2, b2, c2) {
  J !== null && (a2.mode & 1) !== 0 && (K$1 & 2) === 0 ? (a2 = b2.interleaved, a2 === null ? (c2.next = c2, qg === null ? qg = [b2] : qg.push(b2)) : (c2.next = a2.next, a2.next = c2), b2.interleaved = c2) : (a2 = b2.pending, a2 === null ? c2.next = c2 : (c2.next = a2.next, a2.next = c2), b2.pending = c2);
}
function yi(a2, b2, c2) {
  if ((c2 & 4194240) !== 0) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    yc(a2, c2);
  }
}
var Rh = { readContext: pg, useCallback: U$1, useContext: U$1, useEffect: U$1, useImperativeHandle: U$1, useInsertionEffect: U$1, useLayoutEffect: U$1, useMemo: U$1, useReducer: U$1, useRef: U$1, useState: U$1, useDebugValue: U$1, useDeferredValue: U$1, useTransition: U$1, useMutableSource: U$1, useSyncExternalStore: U$1, useId: U$1, unstable_isNewReconciler: false }, Oh = { readContext: pg, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, b2 === void 0 ? null : b2];
  return a2;
}, useContext: pg, useEffect: ki, useImperativeHandle: function(a2, b2, c2) {
  c2 = c2 !== null && c2 !== void 0 ? c2.concat([a2]) : null;
  return ii(4194308, 4, ni.bind(null, b2, a2), c2);
}, useLayoutEffect: function(a2, b2) {
  return ii(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ii(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = b2 === void 0 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = c2 !== void 0 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = ui.bind(null, Q, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: fi, useDebugValue: pi, useDeferredValue: function(a2) {
  var b2 = fi(a2), c2 = b2[0], d2 = b2[1];
  ki(function() {
    var b3 = Gh.transition;
    Gh.transition = {};
    try {
      d2(a2);
    } finally {
      Gh.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = fi(false), b2 = a2[0];
  a2 = si.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = Q, e2 = Th();
  if (N) {
    if (c2 === void 0)
      throw Error(p$7(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (J === null)
      throw Error(p$7(349));
    (Hh & 30) !== 0 || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  ki(ai.bind(null, d2, f2, a2), [a2]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = J.identifierPrefix;
  if (N) {
    var c2 = Sg;
    var d2 = Rg;
    c2 = (d2 & ~(1 << 32 - lc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: pg,
  useCallback: qi,
  useContext: pg,
  useEffect: $h,
  useImperativeHandle: oi,
  useInsertionEffect: li,
  useLayoutEffect: mi,
  useMemo: ri,
  useReducer: Wh,
  useRef: hi,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: pi,
  useDeferredValue: function(a2) {
    var b2 = Wh(Vh), c2 = b2[0], d2 = b2[1];
    $h(function() {
      var b3 = Gh.transition;
      Gh.transition = {};
      try {
        d2(a2);
      } finally {
        Gh.transition = b3;
      }
    }, [a2]);
    return c2;
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: ti,
  unstable_isNewReconciler: false
}, Qh = {
  readContext: pg,
  useCallback: qi,
  useContext: pg,
  useEffect: $h,
  useImperativeHandle: oi,
  useInsertionEffect: li,
  useLayoutEffect: mi,
  useMemo: ri,
  useReducer: Xh,
  useRef: hi,
  useState: function() {
    return Xh(Vh);
  },
  useDebugValue: pi,
  useDeferredValue: function(a2) {
    var b2 = Xh(Vh), c2 = b2[0], d2 = b2[1];
    $h(function() {
      var b3 = Gh.transition;
      Gh.transition = {};
      try {
        d2(a2);
      } finally {
        Gh.transition = b3;
      }
    }, [a2]);
    return c2;
  },
  useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: ti,
  unstable_isNewReconciler: false
};
function zi(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Na(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2 };
}
function Ai(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Bi = typeof WeakMap === "function" ? WeakMap : Map;
function Ci(a2, b2, c2) {
  c2 = ug(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Di || (Di = true, Ei = d2);
    Ai(a2, b2);
  };
  return c2;
}
function Fi(a2, b2, c2) {
  c2 = ug(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if (typeof d2 === "function") {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Ai(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  f2 !== null && typeof f2.componentDidCatch === "function" && (c2.callback = function() {
    Ai(a2, b2);
    typeof d2 !== "function" && (Gi === null ? Gi = /* @__PURE__ */ new Set([this]) : Gi.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: c3 !== null ? c3 : "" });
  });
  return c2;
}
function Hi(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (d2 === null) {
    d2 = a2.pingCache = new Bi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), e2 === void 0 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ii.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ji(a2) {
  do {
    var b2;
    if (b2 = a2.tag === 13)
      b2 = a2.memoizedState, b2 = b2 !== null ? b2.dehydrated !== null ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (a2 !== null);
  return null;
}
function Ki(a2, b2, c2, d2, e2) {
  if ((a2.mode & 1) === 0)
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, c2.tag === 1 && (c2.alternate === null ? c2.tag = 17 : (b2 = ug(-1, 1), b2.tag = 2, vg(c2, b2))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Li, Mi, Ni, Oi;
Li = function(a2, b2) {
  for (var c2 = b2.child; c2 !== null; ) {
    if (c2.tag === 5 || c2.tag === 6)
      a2.appendChild(c2.stateNode);
    else if (c2.tag !== 4 && c2.child !== null) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Mi = function() {
};
Ni = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Wa(a2, e2);
        d2 = Wa(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d2 = A$3({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = db(a2, e2);
        d2 = db(a2, d2);
        f2 = [];
        break;
      default:
        typeof e2.onClick !== "function" && typeof d2.onClick === "function" && (a2.onclick = wf);
    }
    rb(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && e2[l2] != null)
        if (l2 === "style") {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (da.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = e2 != null ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null))
        if (l2 === "style")
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
        else
          l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 !== "string" && typeof k2 !== "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (da.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && F$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Oi = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Pi(a2, b2) {
  if (!N)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; b2 !== null; )
          b2.alternate !== null && (c2 = b2), b2 = b2.sibling;
        c2 === null ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; c2 !== null; )
          c2.alternate !== null && (d2 = c2), c2 = c2.sibling;
        d2 === null ? b2 || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function V$1(a2) {
  var b2 = a2.alternate !== null && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Qi(a2, b2, c2) {
  var d2 = b2.pendingProps;
  Wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return V$1(b2), null;
    case 1:
      return Tf(b2.type) && Uf(), V$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      G(Qf);
      G(I$1);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (a2 === null || a2.child === null)
        fh(b2) ? b2.flags |= 4 : a2 === null || a2.memoizedState.isDehydrated && (b2.flags & 256) === 0 || (b2.flags |= 1024, Zg !== null && (Ri(Zg), Zg = null));
      Mi(a2, b2);
      V$1(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (a2 !== null && b2.stateNode != null)
        Ni(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (b2.stateNode === null)
            throw Error(p$7(166));
          V$1(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (fh(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[If] = b2;
          d2[Jf] = f2;
          a2 = (b2.mode & 1) !== 0;
          switch (c2) {
            case "dialog":
              F$2("cancel", d2);
              F$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              F$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < ff.length; e2++)
                F$2(ff[e2], d2);
              break;
            case "source":
              F$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              F$2("error", d2);
              F$2("load", d2);
              break;
            case "details":
              F$2("toggle", d2);
              break;
            case "input":
              Xa(d2, f2);
              F$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              F$2("invalid", d2);
              break;
            case "textarea":
              eb(d2, f2), F$2("invalid", d2);
          }
          rb(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              g2 === "children" ? typeof h2 === "string" ? d2.textContent !== h2 && (vf(d2.textContent, h2, a2), e2 = ["children", h2]) : typeof h2 === "number" && d2.textContent !== "" + h2 && (vf(d2.textContent, h2, a2), e2 = ["children", "" + h2]) : da.hasOwnProperty(g2) && h2 != null && g2 === "onScroll" && F$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Ta(d2);
              ab(d2, f2, true);
              break;
            case "textarea":
              Ta(d2);
              gb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f2.onClick === "function" && (d2.onclick = wf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          d2 !== null && (b2.flags |= 4);
        } else {
          g2 = e2.nodeType === 9 ? e2 : e2.ownerDocument;
          a2 === "http://www.w3.org/1999/xhtml" && (a2 = hb(c2));
          a2 === "http://www.w3.org/1999/xhtml" ? c2 === "script" ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : typeof d2.is === "string" ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), c2 === "select" && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[If] = b2;
          a2[Jf] = d2;
          Li(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = sb(c2, d2);
            switch (c2) {
              case "dialog":
                F$2("cancel", a2);
                F$2("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                F$2("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < ff.length; e2++)
                  F$2(ff[e2], a2);
                e2 = d2;
                break;
              case "source":
                F$2("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                F$2("error", a2);
                F$2("load", a2);
                e2 = d2;
                break;
              case "details":
                F$2("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Xa(a2, d2);
                e2 = Wa(a2, d2);
                F$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$3({}, d2, { value: void 0 });
                F$2("invalid", a2);
                break;
              case "textarea":
                eb(a2, d2);
                e2 = db(a2, d2);
                F$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            rb(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                f2 === "style" ? pb(a2, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && kb(a2, k2)) : f2 === "children" ? typeof k2 === "string" ? (c2 !== "textarea" || k2 !== "") && lb(a2, k2) : typeof k2 === "number" && lb(a2, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (da.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && F$2("scroll", a2) : k2 != null && ra(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Ta(a2);
                ab(a2, d2, false);
                break;
              case "textarea":
                Ta(a2);
                gb(a2);
                break;
              case "option":
                d2.value != null && a2.setAttribute("value", "" + Qa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                f2 != null ? cb(a2, !!d2.multiple, f2, false) : d2.defaultValue != null && cb(a2, !!d2.multiple, d2.defaultValue, true);
                break;
              default:
                typeof e2.onClick === "function" && (a2.onclick = wf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        b2.ref !== null && (b2.flags |= 512, b2.flags |= 2097152);
      }
      V$1(b2);
      return null;
    case 6:
      if (a2 && b2.stateNode != null)
        Oi(a2, b2, a2.memoizedProps, d2);
      else {
        if (typeof d2 !== "string" && b2.stateNode === null)
          throw Error(p$7(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (fh(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[If] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = Xg, a2 !== null)
              switch (g2 = (a2.mode & 1) !== 0, a2.tag) {
                case 3:
                  vf(d2.nodeValue, c2, g2);
                  break;
                case 5:
                  a2.memoizedProps[void 0] !== true && vf(d2.nodeValue, c2, g2);
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (c2.nodeType === 9 ? c2 : c2.ownerDocument).createTextNode(d2), d2[If] = b2, b2.stateNode = d2;
      }
      V$1(b2);
      return null;
    case 13:
      G(P$2);
      d2 = b2.memoizedState;
      if (N && Yg !== null && (b2.mode & 1) !== 0 && (b2.flags & 128) === 0) {
        for (d2 = Yg; d2; )
          d2 = Ff(d2.nextSibling);
        gh();
        b2.flags |= 98560;
        return b2;
      }
      if (d2 !== null && d2.dehydrated !== null) {
        d2 = fh(b2);
        if (a2 === null) {
          if (!d2)
            throw Error(p$7(318));
          d2 = b2.memoizedState;
          d2 = d2 !== null ? d2.dehydrated : null;
          if (!d2)
            throw Error(p$7(317));
          d2[If] = b2;
        } else
          gh(), (b2.flags & 128) === 0 && (b2.memoizedState = null), b2.flags |= 4;
        V$1(b2);
        return null;
      }
      Zg !== null && (Ri(Zg), Zg = null);
      if ((b2.flags & 128) !== 0)
        return b2.lanes = c2, b2;
      d2 = d2 !== null;
      c2 = false;
      a2 === null ? fh(b2) : c2 = a2.memoizedState !== null;
      d2 && !c2 && (b2.child.flags |= 8192, (b2.mode & 1) !== 0 && (a2 === null || (P$2.current & 1) !== 0 ? W === 0 && (W = 3) : Si()));
      b2.updateQueue !== null && (b2.flags |= 4);
      V$1(b2);
      return null;
    case 4:
      return zh(), Mi(a2, b2), a2 === null && nf(b2.stateNode.containerInfo), V$1(b2), null;
    case 10:
      return lg(b2.type._context), V$1(b2), null;
    case 17:
      return Tf(b2.type) && Uf(), V$1(b2), null;
    case 19:
      G(P$2);
      f2 = b2.memoizedState;
      if (f2 === null)
        return V$1(b2), null;
      d2 = (b2.flags & 128) !== 0;
      g2 = f2.rendering;
      if (g2 === null)
        if (d2)
          Pi(f2, false);
        else {
          if (W !== 0 || a2 !== null && (a2.flags & 128) !== 0)
            for (a2 = b2.child; a2 !== null; ) {
              g2 = Ch(a2);
              if (g2 !== null) {
                b2.flags |= 128;
                Pi(f2, false);
                d2 = g2.updateQueue;
                d2 !== null && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; c2 !== null; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = a2 === null ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                H(P$2, P$2.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          f2.tail !== null && D$2() > Ti && (b2.flags |= 128, d2 = true, Pi(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Ch(g2), a2 !== null) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, c2 !== null && (b2.updateQueue = c2, b2.flags |= 4), Pi(f2, true), f2.tail === null && f2.tailMode === "hidden" && !g2.alternate && !N)
              return V$1(b2), null;
          } else
            2 * D$2() - f2.renderingStartTime > Ti && c2 !== 1073741824 && (b2.flags |= 128, d2 = true, Pi(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, c2 !== null ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (f2.tail !== null)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = D$2(), b2.sibling = null, c2 = P$2.current, H(P$2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      V$1(b2);
      return null;
    case 22:
    case 23:
      return Ui(), d2 = b2.memoizedState !== null, a2 !== null && a2.memoizedState !== null !== d2 && (b2.flags |= 8192), d2 && (b2.mode & 1) !== 0 ? (Vi & 1073741824) !== 0 && (V$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : V$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$7(156, b2.tag));
}
var Wi = sa.ReactCurrentOwner, og = false;
function Xi(a2, b2, c2, d2) {
  b2.child = a2 === null ? sh(b2, null, c2, d2) : rh(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ng(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (a2 !== null && !og)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  N && c2 && Vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (a2 === null) {
    var f2 = c2.type;
    if (typeof f2 === "function" && !aj(f2) && f2.defaultProps === void 0 && c2.compare === null && c2.defaultProps === void 0)
      return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = oh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if ((a2.lanes & e2) === 0) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = c2 !== null ? c2 : De$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = mh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (a2 !== null && De$1(a2.memoizedProps, d2) && a2.ref === b2.ref)
    if (og = false, (a2.lanes & e2) !== 0)
      (a2.flags & 131072) !== 0 && (og = true);
    else
      return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = a2 !== null ? a2.memoizedState : null;
  if (d2.mode === "hidden")
    if ((b2.mode & 1) === 0)
      b2.memoizedState = { baseLanes: 0, cachePool: null }, H(ej, Vi), Vi |= c2;
    else if ((c2 & 1073741824) !== 0)
      b2.memoizedState = { baseLanes: 0, cachePool: null }, d2 = f2 !== null ? f2.baseLanes : c2, H(ej, Vi), Vi |= d2;
    else
      return a2 = f2 !== null ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null }, b2.updateQueue = null, H(ej, Vi), Vi |= a2, null;
  else
    f2 !== null ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, H(ej, Vi), Vi |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function fj(a2, b2) {
  var c2 = b2.ref;
  if (a2 === null && c2 !== null || a2 !== null && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Tf(c2) ? Rf : I$1.current;
  f2 = Sf(b2, f2);
  ng(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (a2 !== null && !og)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  N && d2 && Vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function gj(a2, b2, c2, d2, e2) {
  if (Tf(c2)) {
    var f2 = true;
    Xf(b2);
  } else
    f2 = false;
  ng(b2, e2);
  if (b2.stateNode === null)
    a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), Hg(b2, c2, d2), Jg(b2, c2, d2, e2), d2 = true;
  else if (a2 === null) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = pg(l2) : (l2 = Tf(c2) ? Rf : I$1.current, l2 = Sf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, w2 = typeof m2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function";
    w2 || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== d2 || k2 !== l2) && Ig(b2, g2, d2, l2);
    rg = false;
    var u2 = b2.memoizedState;
    g2.state = u2;
    yg(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || u2 !== k2 || Qf.current || rg ? (typeof m2 === "function" && (Cg(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = rg || Gg(b2, c2, h2, d2, u2, k2, l2)) ? (w2 || typeof g2.UNSAFE_componentWillMount !== "function" && typeof g2.componentWillMount !== "function" || (typeof g2.componentWillMount === "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount === "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount === "function" && (b2.flags |= 4194308)) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    tg(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : fg(b2.type, h2);
    g2.props = l2;
    w2 = b2.pendingProps;
    u2 = g2.context;
    k2 = c2.contextType;
    typeof k2 === "object" && k2 !== null ? k2 = pg(k2) : (k2 = Tf(c2) ? Rf : I$1.current, k2 = Sf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = typeof y2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function") || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== w2 || u2 !== k2) && Ig(b2, g2, d2, k2);
    rg = false;
    u2 = b2.memoizedState;
    g2.state = u2;
    yg(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== w2 || u2 !== n2 || Qf.current || rg ? (typeof y2 === "function" && (Cg(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = rg || Gg(b2, c2, l2, d2, u2, n2, k2) || false) ? (m2 || typeof g2.UNSAFE_componentWillUpdate !== "function" && typeof g2.componentWillUpdate !== "function" || (typeof g2.componentWillUpdate === "function" && g2.componentWillUpdate(d2, n2, k2), typeof g2.UNSAFE_componentWillUpdate === "function" && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), typeof g2.componentDidUpdate === "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate === "function" && (b2.flags |= 1024)) : (typeof g2.componentDidUpdate !== "function" || h2 === a2.memoizedProps && u2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && u2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : (typeof g2.componentDidUpdate !== "function" || h2 === a2.memoizedProps && u2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && u2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return hj(a2, b2, c2, d2, f2, e2);
}
function hj(a2, b2, c2, d2, e2, f2) {
  fj(a2, b2);
  var g2 = (b2.flags & 128) !== 0;
  if (!d2 && !g2)
    return e2 && Yf(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && typeof c2.getDerivedStateFromError !== "function" ? null : d2.render();
  b2.flags |= 1;
  a2 !== null && g2 ? (b2.child = rh(b2, a2.child, null, f2), b2.child = rh(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && Yf(b2, c2, true);
  return b2.child;
}
function ij(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? Vf(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Vf(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function jj(a2, b2, c2, d2, e2) {
  gh();
  hh(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var kj = { dehydrated: null, treeContext: null, retryLane: 0 };
function lj(a2) {
  return { baseLanes: a2, cachePool: null };
}
function mj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = P$2.current, f2 = false, g2 = (b2.flags & 128) !== 0, h2;
  (h2 = g2) || (h2 = a2 !== null && a2.memoizedState === null ? false : (e2 & 2) !== 0);
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (a2 === null || a2.memoizedState !== null)
    e2 |= 1;
  H(P$2, e2 & 1);
  if (a2 === null) {
    dh(b2);
    a2 = b2.memoizedState;
    if (a2 !== null && (a2 = a2.dehydrated, a2 !== null))
      return (b2.mode & 1) === 0 ? b2.lanes = 1 : a2.data === "$!" ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    e2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, e2 = { mode: "hidden", children: e2 }, (d2 & 1) === 0 && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = e2) : f2 = nj(e2, d2, 0, null), a2 = qh(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = lj(c2), b2.memoizedState = kj, a2) : oj(b2, e2);
  }
  e2 = a2.memoizedState;
  if (e2 !== null) {
    h2 = e2.dehydrated;
    if (h2 !== null) {
      if (g2) {
        if (b2.flags & 256)
          return b2.flags &= -257, pj(a2, b2, c2, Error(p$7(422)));
        if (b2.memoizedState !== null)
          return b2.child = a2.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = nj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = qh(f2, e2, c2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        (b2.mode & 1) !== 0 && rh(b2, a2.child, null, c2);
        b2.child.memoizedState = lj(c2);
        b2.memoizedState = kj;
        return f2;
      }
      if ((b2.mode & 1) === 0)
        b2 = pj(a2, b2, c2, null);
      else if (h2.data === "$!")
        b2 = pj(a2, b2, c2, Error(p$7(419)));
      else if (d2 = (c2 & a2.childLanes) !== 0, og || d2) {
        d2 = J;
        if (d2 !== null) {
          switch (c2 & -c2) {
            case 4:
              f2 = 2;
              break;
            case 16:
              f2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              f2 = 32;
              break;
            case 536870912:
              f2 = 268435456;
              break;
            default:
              f2 = 0;
          }
          d2 = (f2 & (d2.suspendedLanes | c2)) !== 0 ? 0 : f2;
          d2 !== 0 && d2 !== e2.retryLane && (e2.retryLane = d2, Eg(a2, d2, -1));
        }
        Si();
        b2 = pj(a2, b2, c2, Error(p$7(421)));
      } else
        h2.data === "$?" ? (b2.flags |= 128, b2.child = a2.child, b2 = qj.bind(null, a2), h2._reactRetry = b2, b2 = null) : (c2 = e2.treeContext, Yg = Ff(h2.nextSibling), Xg = b2, N = true, Zg = null, c2 !== null && (Og[Pg++] = Rg, Og[Pg++] = Sg, Og[Pg++] = Qg, Rg = c2.id, Sg = c2.overflow, Qg = b2), b2 = oj(b2, b2.pendingProps.children), b2.flags |= 4096);
      return b2;
    }
    if (f2)
      return d2 = rj(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = e2 === null ? lj(c2) : { baseLanes: e2.baseLanes | c2, cachePool: null }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = kj, d2;
    c2 = sj(a2, b2, d2.children, c2);
    b2.memoizedState = null;
    return c2;
  }
  if (f2)
    return d2 = rj(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = e2 === null ? lj(c2) : { baseLanes: e2.baseLanes | c2, cachePool: null }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = kj, d2;
  c2 = sj(a2, b2, d2.children, c2);
  b2.memoizedState = null;
  return c2;
}
function oj(a2, b2) {
  b2 = nj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  var e2 = a2.child;
  a2 = e2.sibling;
  c2 = mh(e2, { mode: "visible", children: c2 });
  (b2.mode & 1) === 0 && (c2.lanes = d2);
  c2.return = b2;
  c2.sibling = null;
  a2 !== null && (d2 = b2.deletions, d2 === null ? (b2.deletions = [a2], b2.flags |= 16) : d2.push(a2));
  return b2.child = c2;
}
function rj(a2, b2, c2, d2, e2) {
  var f2 = b2.mode;
  a2 = a2.child;
  var g2 = a2.sibling, h2 = { mode: "hidden", children: c2 };
  (f2 & 1) === 0 && b2.child !== a2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, b2.deletions = null) : (c2 = mh(a2, h2), c2.subtreeFlags = a2.subtreeFlags & 14680064);
  g2 !== null ? d2 = mh(g2, d2) : (d2 = qh(d2, f2, e2, null), d2.flags |= 2);
  d2.return = b2;
  c2.return = b2;
  c2.sibling = d2;
  b2.child = c2;
  return d2;
}
function pj(a2, b2, c2, d2) {
  d2 !== null && hh(d2);
  rh(b2, a2.child, null, c2);
  a2 = oj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function tj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  d2 !== null && (d2.lanes |= b2);
  mg(a2.return, b2, c2);
}
function uj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  f2 === null ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function vj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = P$2.current;
  if ((d2 & 2) !== 0)
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (a2 !== null && (a2.flags & 128) !== 0)
      a:
        for (a2 = b2.child; a2 !== null; ) {
          if (a2.tag === 13)
            a2.memoizedState !== null && tj(a2, c2, b2);
          else if (a2.tag === 19)
            tj(a2, c2, b2);
          else if (a2.child !== null) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; a2.sibling === null; ) {
            if (a2.return === null || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  H(P$2, d2);
  if ((b2.mode & 1) === 0)
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; c2 !== null; )
          a2 = c2.alternate, a2 !== null && Ch(a2) === null && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        c2 === null ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        uj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; e2 !== null; ) {
          a2 = e2.alternate;
          if (a2 !== null && Ch(a2) === null) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        uj(b2, true, c2, null, f2);
        break;
      case "together":
        uj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function Zi(a2, b2, c2) {
  a2 !== null && (b2.dependencies = a2.dependencies);
  zg |= b2.lanes;
  if ((c2 & b2.childLanes) === 0)
    return null;
  if (a2 !== null && b2.child !== a2.child)
    throw Error(p$7(153));
  if (b2.child !== null) {
    a2 = b2.child;
    c2 = mh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; a2.sibling !== null; )
      a2 = a2.sibling, c2 = c2.sibling = mh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function wj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      ij(b2);
      gh();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Tf(b2.type) && Xf(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      H(gg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (d2 !== null) {
        if (d2.dehydrated !== null)
          return H(P$2, P$2.current & 1), b2.flags |= 128, null;
        if ((c2 & b2.child.childLanes) !== 0)
          return mj(a2, b2, c2);
        H(P$2, P$2.current & 1);
        a2 = Zi(a2, b2, c2);
        return a2 !== null ? a2.sibling : null;
      }
      H(P$2, P$2.current & 1);
      break;
    case 19:
      d2 = (c2 & b2.childLanes) !== 0;
      if ((a2.flags & 128) !== 0) {
        if (d2)
          return vj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      H(P$2, P$2.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
function xj(a2, b2) {
  Wg(b2);
  switch (b2.tag) {
    case 1:
      return Tf(b2.type) && Uf(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), G(Qf), G(I$1), Eh(), a2 = b2.flags, (a2 & 65536) !== 0 && (a2 & 128) === 0 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      G(P$2);
      a2 = b2.memoizedState;
      if (a2 !== null && a2.dehydrated !== null) {
        if (b2.alternate === null)
          throw Error(p$7(340));
        gh();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return G(P$2), null;
    case 4:
      return zh(), null;
    case 10:
      return lg(b2.type._context), null;
    case 22:
    case 23:
      return Ui(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var yj = false, zj = false, Aj = typeof WeakSet === "function" ? WeakSet : Set, X = null;
function Bj(a2, b2) {
  var c2 = a2.ref;
  if (c2 !== null)
    if (typeof c2 === "function")
      try {
        c2(null);
      } catch (d2) {
        Cj(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Dj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    Cj(a2, b2, d2);
  }
}
var Ej = false;
function Fj(a2, b2) {
  a2 = He$1();
  if (Ie$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && d2.rangeCount !== 0) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (O2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, w2 = a2, u2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                w2 !== c2 || e2 !== 0 && w2.nodeType !== 3 || (h2 = g2 + e2);
                w2 !== f2 || d2 !== 0 && w2.nodeType !== 3 || (k2 = g2 + d2);
                w2.nodeType === 3 && (g2 += w2.nodeValue.length);
                if ((y2 = w2.firstChild) === null)
                  break;
                u2 = w2;
                w2 = y2;
              }
              for (; ; ) {
                if (w2 === a2)
                  break b;
                u2 === c2 && ++l2 === e2 && (h2 = g2);
                u2 === f2 && ++m2 === d2 && (k2 = g2);
                if ((y2 = w2.nextSibling) !== null)
                  break;
                w2 = u2;
                u2 = w2.parentNode;
              }
              w2 = y2;
            }
          c2 = h2 === -1 || k2 === -1 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  xf = { focusedElem: a2, selectionRange: c2 };
  for (X = b2; X !== null; )
    if (b2 = X, a2 = b2.child, (b2.subtreeFlags & 1028) !== 0 && a2 !== null)
      a2.return = b2, X = a2;
    else
      for (; X !== null; ) {
        b2 = X;
        try {
          var n2 = b2.alternate;
          if ((b2.flags & 1024) !== 0)
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (n2 !== null) {
                  var v2 = n2.memoizedProps, C2 = n2.memoizedState, t2 = b2.stateNode, r2 = t2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? v2 : fg(b2.type, v2), C2);
                  t2.__reactInternalSnapshotBeforeUpdate = r2;
                }
                break;
              case 3:
                var x2 = b2.stateNode.containerInfo;
                if (x2.nodeType === 1)
                  x2.textContent = "";
                else if (x2.nodeType === 9) {
                  var B2 = x2.body;
                  B2 != null && (B2.textContent = "");
                }
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$7(163));
            }
        } catch (O2) {
          Cj(b2, b2.return, O2);
        }
        a2 = b2.sibling;
        if (a2 !== null) {
          a2.return = b2.return;
          X = a2;
          break;
        }
        X = b2.return;
      }
  n2 = Ej;
  Ej = false;
  return n2;
}
function Gj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = d2 !== null ? d2.lastEffect : null;
  if (d2 !== null) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        f2 !== void 0 && Dj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Hj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = b2 !== null ? b2.lastEffect : null;
  if (b2 !== null) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Ij(a2) {
  var b2 = a2.ref;
  if (b2 !== null) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    typeof b2 === "function" ? b2(a2) : b2.current = a2;
  }
}
function Jj(a2, b2, c2) {
  if (ic && typeof ic.onCommitFiberUnmount === "function")
    try {
      ic.onCommitFiberUnmount(hc, b2);
    } catch (g2) {
    }
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      a2 = b2.updateQueue;
      if (a2 !== null && (a2 = a2.lastEffect, a2 !== null)) {
        var d2 = a2 = a2.next;
        do {
          var e2 = d2, f2 = e2.destroy;
          e2 = e2.tag;
          f2 !== void 0 && ((e2 & 2) !== 0 ? Dj(b2, c2, f2) : (e2 & 4) !== 0 && Dj(b2, c2, f2));
          d2 = d2.next;
        } while (d2 !== a2);
      }
      break;
    case 1:
      Bj(b2, c2);
      a2 = b2.stateNode;
      if (typeof a2.componentWillUnmount === "function")
        try {
          a2.props = b2.memoizedProps, a2.state = b2.memoizedState, a2.componentWillUnmount();
        } catch (g2) {
          Cj(b2, c2, g2);
        }
      break;
    case 5:
      Bj(b2, c2);
      break;
    case 4:
      Kj(a2, b2, c2);
  }
}
function Lj(a2) {
  var b2 = a2.alternate;
  b2 !== null && (a2.alternate = null, Lj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  a2.tag === 5 && (b2 = a2.stateNode, b2 !== null && (delete b2[If], delete b2[Jf], delete b2[jf], delete b2[Kf], delete b2[Lf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Mj(a2) {
  return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
}
function Nj(a2) {
  a:
    for (; ; ) {
      for (; a2.sibling === null; ) {
        if (a2.return === null || Mj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 18; ) {
        if (a2.flags & 2)
          continue a;
        if (a2.child === null || a2.tag === 4)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Oj(a2) {
  a: {
    for (var b2 = a2.return; b2 !== null; ) {
      if (Mj(b2))
        break a;
      b2 = b2.return;
    }
    throw Error(p$7(160));
  }
  var c2 = b2;
  switch (c2.tag) {
    case 5:
      b2 = c2.stateNode;
      c2.flags & 32 && (lb(b2, ""), c2.flags &= -33);
      c2 = Nj(a2);
      Pj(a2, c2, b2);
      break;
    case 3:
    case 4:
      b2 = c2.stateNode.containerInfo;
      c2 = Nj(a2);
      Qj(a2, c2, b2);
      break;
    default:
      throw Error(p$7(161));
  }
}
function Qj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.nodeType === 8 ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (c2.nodeType === 8 ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, c2 !== null && c2 !== void 0 || b2.onclick !== null || (b2.onclick = wf));
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Qj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Qj(a2, b2, c2), a2 = a2.sibling;
}
function Pj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Pj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Pj(a2, b2, c2), a2 = a2.sibling;
}
function Kj(a2, b2, c2) {
  for (var d2 = b2, e2 = false, f2, g2; ; ) {
    if (!e2) {
      e2 = d2.return;
      a:
        for (; ; ) {
          if (e2 === null)
            throw Error(p$7(160));
          f2 = e2.stateNode;
          switch (e2.tag) {
            case 5:
              g2 = false;
              break a;
            case 3:
              f2 = f2.containerInfo;
              g2 = true;
              break a;
            case 4:
              f2 = f2.containerInfo;
              g2 = true;
              break a;
          }
          e2 = e2.return;
        }
      e2 = true;
    }
    if (d2.tag === 5 || d2.tag === 6) {
      a:
        for (var h2 = a2, k2 = d2, l2 = c2, m2 = k2; ; )
          if (Jj(h2, m2, l2), m2.child !== null && m2.tag !== 4)
            m2.child.return = m2, m2 = m2.child;
          else {
            if (m2 === k2)
              break a;
            for (; m2.sibling === null; ) {
              if (m2.return === null || m2.return === k2)
                break a;
              m2 = m2.return;
            }
            m2.sibling.return = m2.return;
            m2 = m2.sibling;
          }
      g2 ? (h2 = f2, k2 = d2.stateNode, h2.nodeType === 8 ? h2.parentNode.removeChild(k2) : h2.removeChild(k2)) : f2.removeChild(d2.stateNode);
    } else if (d2.tag === 18)
      g2 ? (h2 = f2, k2 = d2.stateNode, h2.nodeType === 8 ? Ef(h2.parentNode, k2) : h2.nodeType === 1 && Ef(h2, k2), Yc(h2)) : Ef(f2, d2.stateNode);
    else if (d2.tag === 4) {
      if (d2.child !== null) {
        f2 = d2.stateNode.containerInfo;
        g2 = true;
        d2.child.return = d2;
        d2 = d2.child;
        continue;
      }
    } else if (Jj(a2, d2, c2), d2.child !== null) {
      d2.child.return = d2;
      d2 = d2.child;
      continue;
    }
    if (d2 === b2)
      break;
    for (; d2.sibling === null; ) {
      if (d2.return === null || d2.return === b2)
        return;
      d2 = d2.return;
      d2.tag === 4 && (e2 = false);
    }
    d2.sibling.return = d2.return;
    d2 = d2.sibling;
  }
}
function Rj(a2, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      Gj(3, b2, b2.return);
      Hj(3, b2);
      Gj(5, b2, b2.return);
      return;
    case 1:
      return;
    case 5:
      var c2 = b2.stateNode;
      if (c2 != null) {
        var d2 = b2.memoizedProps, e2 = a2 !== null ? a2.memoizedProps : d2;
        a2 = b2.type;
        var f2 = b2.updateQueue;
        b2.updateQueue = null;
        if (f2 !== null) {
          a2 === "input" && d2.type === "radio" && d2.name != null && Ya(c2, d2);
          sb(a2, e2);
          b2 = sb(a2, d2);
          for (e2 = 0; e2 < f2.length; e2 += 2) {
            var g2 = f2[e2], h2 = f2[e2 + 1];
            g2 === "style" ? pb(c2, h2) : g2 === "dangerouslySetInnerHTML" ? kb(c2, h2) : g2 === "children" ? lb(c2, h2) : ra(c2, g2, h2, b2);
          }
          switch (a2) {
            case "input":
              Za(c2, d2);
              break;
            case "textarea":
              fb(c2, d2);
              break;
            case "select":
              a2 = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, f2 != null ? cb(c2, !!d2.multiple, f2, false) : a2 !== !!d2.multiple && (d2.defaultValue != null ? cb(c2, !!d2.multiple, d2.defaultValue, true) : cb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
          }
          c2[Jf] = d2;
        }
      }
      return;
    case 6:
      if (b2.stateNode === null)
        throw Error(p$7(162));
      b2.stateNode.nodeValue = b2.memoizedProps;
      return;
    case 3:
      a2 !== null && a2.memoizedState.isDehydrated && Yc(b2.stateNode.containerInfo);
      return;
    case 12:
      return;
    case 13:
      Sj(b2);
      return;
    case 19:
      Sj(b2);
      return;
    case 17:
      return;
  }
  throw Error(p$7(163));
}
function Sj(a2) {
  var b2 = a2.updateQueue;
  if (b2 !== null) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    c2 === null && (c2 = a2.stateNode = new Aj());
    b2.forEach(function(b3) {
      var d2 = Tj.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function Uj(a2, b2) {
  for (X = b2; X !== null; ) {
    b2 = X;
    var c2 = b2.deletions;
    if (c2 !== null)
      for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        try {
          Kj(a2, e2, b2);
          var f2 = e2.alternate;
          f2 !== null && (f2.return = null);
          e2.return = null;
        } catch (L2) {
          Cj(e2, b2, L2);
        }
      }
    c2 = b2.child;
    if ((b2.subtreeFlags & 12854) !== 0 && c2 !== null)
      c2.return = b2, X = c2;
    else
      for (; X !== null; ) {
        b2 = X;
        try {
          var g2 = b2.flags;
          g2 & 32 && lb(b2.stateNode, "");
          if (g2 & 512) {
            var h2 = b2.alternate;
            if (h2 !== null) {
              var k2 = h2.ref;
              k2 !== null && (typeof k2 === "function" ? k2(null) : k2.current = null);
            }
          }
          if (g2 & 8192)
            switch (b2.tag) {
              case 13:
                if (b2.memoizedState !== null) {
                  var l2 = b2.alternate;
                  if (l2 === null || l2.memoizedState === null)
                    Vj = D$2();
                }
                break;
              case 22:
                var m2 = b2.memoizedState !== null, w2 = b2.alternate, u2 = w2 !== null && w2.memoizedState !== null;
                c2 = b2;
                a: {
                  d2 = c2;
                  e2 = m2;
                  for (var y2 = null, n2 = d2; ; ) {
                    if (n2.tag === 5) {
                      if (y2 === null) {
                        y2 = n2;
                        var v2 = n2.stateNode;
                        if (e2) {
                          var C2 = v2.style;
                          typeof C2.setProperty === "function" ? C2.setProperty("display", "none", "important") : C2.display = "none";
                        } else {
                          var t2 = n2.stateNode, r2 = n2.memoizedProps.style, x2 = r2 !== void 0 && r2 !== null && r2.hasOwnProperty("display") ? r2.display : null;
                          t2.style.display = ob("display", x2);
                        }
                      }
                    } else if (n2.tag === 6)
                      y2 === null && (n2.stateNode.nodeValue = e2 ? "" : n2.memoizedProps);
                    else if ((n2.tag !== 22 && n2.tag !== 23 || n2.memoizedState === null || n2 === d2) && n2.child !== null) {
                      n2.child.return = n2;
                      n2 = n2.child;
                      continue;
                    }
                    if (n2 === d2)
                      break;
                    for (; n2.sibling === null; ) {
                      if (n2.return === null || n2.return === d2)
                        break a;
                      y2 === n2 && (y2 = null);
                      n2 = n2.return;
                    }
                    y2 === n2 && (y2 = null);
                    n2.sibling.return = n2.return;
                    n2 = n2.sibling;
                  }
                }
                if (m2 && !u2 && (c2.mode & 1) !== 0) {
                  X = c2;
                  for (var B2 = c2.child; B2 !== null; ) {
                    for (c2 = X = B2; X !== null; ) {
                      d2 = X;
                      var O2 = d2.child;
                      switch (d2.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          Gj(4, d2, d2.return);
                          break;
                        case 1:
                          Bj(d2, d2.return);
                          var T2 = d2.stateNode;
                          if (typeof T2.componentWillUnmount === "function") {
                            var za = d2.return;
                            try {
                              T2.props = d2.memoizedProps, T2.state = d2.memoizedState, T2.componentWillUnmount();
                            } catch (L2) {
                              Cj(d2, za, L2);
                            }
                          }
                          break;
                        case 5:
                          Bj(d2, d2.return);
                          break;
                        case 22:
                          if (d2.memoizedState !== null) {
                            Wj(c2);
                            continue;
                          }
                      }
                      O2 !== null ? (O2.return = d2, X = O2) : Wj(c2);
                    }
                    B2 = B2.sibling;
                  }
                }
            }
          switch (g2 & 4102) {
            case 2:
              Oj(b2);
              b2.flags &= -3;
              break;
            case 6:
              Oj(b2);
              b2.flags &= -3;
              Rj(b2.alternate, b2);
              break;
            case 4096:
              b2.flags &= -4097;
              break;
            case 4100:
              b2.flags &= -4097;
              Rj(b2.alternate, b2);
              break;
            case 4:
              Rj(b2.alternate, b2);
          }
        } catch (L2) {
          Cj(b2, b2.return, L2);
        }
        c2 = b2.sibling;
        if (c2 !== null) {
          c2.return = b2.return;
          X = c2;
          break;
        }
        X = b2.return;
      }
  }
}
function Xj(a2, b2, c2) {
  X = a2;
  Yj(a2);
}
function Yj(a2, b2, c2) {
  for (var d2 = (a2.mode & 1) !== 0; X !== null; ) {
    var e2 = X, f2 = e2.child;
    if (e2.tag === 22 && d2) {
      var g2 = e2.memoizedState !== null || yj;
      if (!g2) {
        var h2 = e2.alternate, k2 = h2 !== null && h2.memoizedState !== null || zj;
        h2 = yj;
        var l2 = zj;
        yj = g2;
        if ((zj = k2) && !l2)
          for (X = e2; X !== null; )
            g2 = X, k2 = g2.child, g2.tag === 22 && g2.memoizedState !== null ? Zj(e2) : k2 !== null ? (k2.return = g2, X = k2) : Zj(e2);
        for (; f2 !== null; )
          X = f2, Yj(f2), f2 = f2.sibling;
        X = e2;
        yj = h2;
        zj = l2;
      }
      ak(a2);
    } else
      (e2.subtreeFlags & 8772) !== 0 && f2 !== null ? (f2.return = e2, X = f2) : ak(a2);
  }
}
function ak(a2) {
  for (; X !== null; ) {
    var b2 = X;
    if ((b2.flags & 8772) !== 0) {
      var c2 = b2.alternate;
      try {
        if ((b2.flags & 8772) !== 0)
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              zj || Hj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !zj)
                if (c2 === null)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : fg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              f2 !== null && Ag(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (g2 !== null) {
                c2 = null;
                if (b2.child !== null)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                Ag(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (c2 === null && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (b2.memoizedState === null) {
                var l2 = b2.alternate;
                if (l2 !== null) {
                  var m2 = l2.memoizedState;
                  if (m2 !== null) {
                    var w2 = m2.dehydrated;
                    w2 !== null && Yc(w2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
              break;
            default:
              throw Error(p$7(163));
          }
        zj || b2.flags & 512 && Ij(b2);
      } catch (u2) {
        Cj(b2, b2.return, u2);
      }
    }
    if (b2 === a2) {
      X = null;
      break;
    }
    c2 = b2.sibling;
    if (c2 !== null) {
      c2.return = b2.return;
      X = c2;
      break;
    }
    X = b2.return;
  }
}
function Wj(a2) {
  for (; X !== null; ) {
    var b2 = X;
    if (b2 === a2) {
      X = null;
      break;
    }
    var c2 = b2.sibling;
    if (c2 !== null) {
      c2.return = b2.return;
      X = c2;
      break;
    }
    X = b2.return;
  }
}
function Zj(a2) {
  for (; X !== null; ) {
    var b2 = X;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Hj(4, b2);
          } catch (k2) {
            Cj(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if (typeof d2.componentDidMount === "function") {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              Cj(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Ij(b2);
          } catch (k2) {
            Cj(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Ij(b2);
          } catch (k2) {
            Cj(b2, g2, k2);
          }
      }
    } catch (k2) {
      Cj(b2, b2.return, k2);
    }
    if (b2 === a2) {
      X = null;
      break;
    }
    var h2 = b2.sibling;
    if (h2 !== null) {
      h2.return = b2.return;
      X = h2;
      break;
    }
    X = b2.return;
  }
}
var bk = Math.ceil, ck = sa.ReactCurrentDispatcher, dk = sa.ReactCurrentOwner, ek = sa.ReactCurrentBatchConfig, K$1 = 0, J = null, Y = null, Z = 0, Vi = 0, ej = Of(0), W = 0, fk = null, zg = 0, gk = 0, hk = 0, ik = null, jk = null, Vj = 0, Ti = Infinity, Di = false, Ei = null, Gi = null, kk = false, lk = null, mk = 0, nk = 0, ok = null, pk = -1, qk = 0;
function M$2() {
  return (K$1 & 6) !== 0 ? D$2() : pk !== -1 ? pk : pk = D$2();
}
function Dg(a2) {
  if ((a2.mode & 1) === 0)
    return 1;
  if ((K$1 & 2) !== 0 && Z !== 0)
    return Z & -Z;
  if (eg.transition !== null)
    return qk === 0 && (a2 = oc, oc <<= 1, (oc & 4194240) === 0 && (oc = 64), qk = a2), qk;
  a2 = E$4;
  if (a2 !== 0)
    return a2;
  a2 = window.event;
  a2 = a2 === void 0 ? 16 : ed(a2.type);
  return a2;
}
function Eg(a2, b2, c2) {
  if (50 < nk)
    throw nk = 0, ok = null, Error(p$7(185));
  var d2 = rk(a2, b2);
  if (d2 === null)
    return null;
  wc(d2, b2, c2);
  if ((K$1 & 2) === 0 || d2 !== J)
    d2 === J && ((K$1 & 2) === 0 && (gk |= b2), W === 4 && sk(d2, Z)), tk(d2, c2), b2 === 1 && K$1 === 0 && (a2.mode & 1) === 0 && (Ti = D$2() + 500, $f && dg());
  return d2;
}
function rk(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  c2 !== null && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; a2 !== null; )
    a2.childLanes |= b2, c2 = a2.alternate, c2 !== null && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return c2.tag === 3 ? c2.stateNode : null;
}
function tk(a2, b2) {
  var c2 = a2.callbackNode;
  tc(a2, b2);
  var d2 = rc(a2, a2 === J ? Z : 0);
  if (d2 === 0)
    c2 !== null && Zb(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    c2 != null && Zb(c2);
    if (b2 === 1)
      a2.tag === 0 ? cg(uk.bind(null, a2)) : bg(uk.bind(null, a2)), Df(function() {
        K$1 === 0 && dg();
      }), c2 = null;
    else {
      switch (zc(d2)) {
        case 1:
          c2 = cc;
          break;
        case 4:
          c2 = dc;
          break;
        case 16:
          c2 = ec;
          break;
        case 536870912:
          c2 = gc;
          break;
        default:
          c2 = ec;
      }
      c2 = vk(c2, wk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function wk(a2, b2) {
  pk = -1;
  qk = 0;
  if ((K$1 & 6) !== 0)
    throw Error(p$7(327));
  var c2 = a2.callbackNode;
  if (xk() && a2.callbackNode !== c2)
    return null;
  var d2 = rc(a2, a2 === J ? Z : 0);
  if (d2 === 0)
    return null;
  if ((d2 & 30) !== 0 || (d2 & a2.expiredLanes) !== 0 || b2)
    b2 = yk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = zk();
    if (J !== a2 || Z !== b2)
      Ti = D$2() + 500, Ak(a2, b2);
    do
      try {
        Bk();
        break;
      } catch (h2) {
        Ck(a2, h2);
      }
    while (1);
    kg();
    ck.current = f2;
    K$1 = e2;
    Y !== null ? b2 = 0 : (J = null, Z = 0, b2 = W);
  }
  if (b2 !== 0) {
    b2 === 2 && (e2 = uc(a2), e2 !== 0 && (d2 = e2, b2 = Dk(a2, e2)));
    if (b2 === 1)
      throw c2 = fk, Ak(a2, 0), sk(a2, d2), tk(a2, D$2()), c2;
    if (b2 === 6)
      sk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if ((d2 & 30) === 0 && !Ek(e2) && (b2 = yk(a2, d2), b2 === 2 && (f2 = uc(a2), f2 !== 0 && (d2 = f2, b2 = Dk(a2, f2))), b2 === 1))
        throw c2 = fk, Ak(a2, 0), sk(a2, d2), tk(a2, D$2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$7(345));
        case 2:
          Fk(a2, jk);
          break;
        case 3:
          sk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = Vj + 500 - D$2(), 10 < b2)) {
            if (rc(a2, 0) !== 0)
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              M$2();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = zf(Fk.bind(null, a2, jk), b2);
            break;
          }
          Fk(a2, jk);
          break;
        case 4:
          sk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - lc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = D$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * bk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = zf(Fk.bind(null, a2, jk), d2);
            break;
          }
          Fk(a2, jk);
          break;
        case 5:
          Fk(a2, jk);
          break;
        default:
          throw Error(p$7(329));
      }
    }
  }
  tk(a2, D$2());
  return a2.callbackNode === c2 ? wk.bind(null, a2) : null;
}
function Dk(a2, b2) {
  var c2 = ik;
  a2.current.memoizedState.isDehydrated && (Ak(a2, b2).flags |= 256);
  a2 = yk(a2, b2);
  a2 !== 2 && (b2 = jk, jk = c2, b2 !== null && Ri(b2));
  return a2;
}
function Ri(a2) {
  jk === null ? jk = a2 : jk.push.apply(jk, a2);
}
function Ek(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (c2 !== null && (c2 = c2.stores, c2 !== null))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!Ce$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && c2 !== null)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; b2.sibling === null; ) {
        if (b2.return === null || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function sk(a2, b2) {
  b2 &= ~hk;
  b2 &= ~gk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - lc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function uk(a2) {
  if ((K$1 & 6) !== 0)
    throw Error(p$7(327));
  xk();
  var b2 = rc(a2, 0);
  if ((b2 & 1) === 0)
    return tk(a2, D$2()), null;
  var c2 = yk(a2, b2);
  if (a2.tag !== 0 && c2 === 2) {
    var d2 = uc(a2);
    d2 !== 0 && (b2 = d2, c2 = Dk(a2, d2));
  }
  if (c2 === 1)
    throw c2 = fk, Ak(a2, 0), sk(a2, b2), tk(a2, D$2()), c2;
  if (c2 === 6)
    throw Error(p$7(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Fk(a2, jk);
  tk(a2, D$2());
  return null;
}
function Gk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, K$1 === 0 && (Ti = D$2() + 500, $f && dg());
  }
}
function Hk(a2) {
  lk !== null && lk.tag === 0 && (K$1 & 6) === 0 && xk();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = ek.transition, d2 = E$4;
  try {
    if (ek.transition = null, E$4 = 1, a2)
      return a2();
  } finally {
    E$4 = d2, ek.transition = c2, K$1 = b2, (K$1 & 6) === 0 && dg();
  }
}
function Ui() {
  Vi = ej.current;
  G(ej);
}
function Ak(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  c2 !== -1 && (a2.timeoutHandle = -1, Af(c2));
  if (Y !== null)
    for (c2 = Y.return; c2 !== null; ) {
      var d2 = c2;
      Wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          d2 !== null && d2 !== void 0 && Uf();
          break;
        case 3:
          zh();
          G(Qf);
          G(I$1);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          G(P$2);
          break;
        case 19:
          G(P$2);
          break;
        case 10:
          lg(d2.type._context);
          break;
        case 22:
        case 23:
          Ui();
      }
      c2 = c2.return;
    }
  J = a2;
  Y = a2 = mh(a2.current, null);
  Z = Vi = b2;
  W = 0;
  fk = null;
  hk = gk = zg = 0;
  jk = ik = null;
  if (qg !== null) {
    for (b2 = 0; b2 < qg.length; b2++)
      if (c2 = qg[b2], d2 = c2.interleaved, d2 !== null) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (f2 !== null) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    qg = null;
  }
  return a2;
}
function Ck(a2, b2) {
  do {
    var c2 = Y;
    try {
      kg();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = Q.memoizedState; d2 !== null; ) {
          var e2 = d2.queue;
          e2 !== null && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      S$2 = R$5 = Q = null;
      Jh = false;
      Kh = 0;
      dk.current = null;
      if (c2 === null || c2.return === null) {
        W = 1;
        fk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (k2 !== null && typeof k2 === "object" && typeof k2.then === "function") {
          var l2 = k2, m2 = h2, w2 = m2.tag;
          if ((m2.mode & 1) === 0 && (w2 === 0 || w2 === 11 || w2 === 15)) {
            var u2 = m2.alternate;
            u2 ? (m2.updateQueue = u2.updateQueue, m2.memoizedState = u2.memoizedState, m2.lanes = u2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ji(g2);
          if (y2 !== null) {
            y2.flags &= -257;
            Ki(y2, g2, h2, f2, b2);
            y2.mode & 1 && Hi(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (n2 === null) {
              var v2 = /* @__PURE__ */ new Set();
              v2.add(k2);
              b2.updateQueue = v2;
            } else
              n2.add(k2);
            break a;
          } else {
            if ((b2 & 1) === 0) {
              Hi(f2, l2, b2);
              Si();
              break a;
            }
            k2 = Error(p$7(426));
          }
        } else if (N && h2.mode & 1) {
          var C2 = Ji(g2);
          if (C2 !== null) {
            (C2.flags & 65536) === 0 && (C2.flags |= 256);
            Ki(C2, g2, h2, f2, b2);
            hh(k2);
            break a;
          }
        }
        f2 = k2;
        W !== 4 && (W = 2);
        ik === null ? ik = [f2] : ik.push(f2);
        k2 = zi(k2, h2);
        h2 = g2;
        do {
          switch (h2.tag) {
            case 3:
              h2.flags |= 65536;
              b2 &= -b2;
              h2.lanes |= b2;
              var t2 = Ci(h2, k2, b2);
              xg(h2, t2);
              break a;
            case 1:
              f2 = k2;
              var r2 = h2.type, x2 = h2.stateNode;
              if ((h2.flags & 128) === 0 && (typeof r2.getDerivedStateFromError === "function" || x2 !== null && typeof x2.componentDidCatch === "function" && (Gi === null || !Gi.has(x2)))) {
                h2.flags |= 65536;
                b2 &= -b2;
                h2.lanes |= b2;
                var B2 = Fi(h2, f2, b2);
                xg(h2, B2);
                break a;
              }
          }
          h2 = h2.return;
        } while (h2 !== null);
      }
      Ik(c2);
    } catch (O2) {
      b2 = O2;
      Y === c2 && c2 !== null && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function zk() {
  var a2 = ck.current;
  ck.current = Rh;
  return a2 === null ? Rh : a2;
}
function Si() {
  if (W === 0 || W === 3 || W === 2)
    W = 4;
  J === null || (zg & 268435455) === 0 && (gk & 268435455) === 0 || sk(J, Z);
}
function yk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = zk();
  J === a2 && Z === b2 || Ak(a2, b2);
  do
    try {
      Jk();
      break;
    } catch (e2) {
      Ck(a2, e2);
    }
  while (1);
  kg();
  K$1 = c2;
  ck.current = d2;
  if (Y !== null)
    throw Error(p$7(261));
  J = null;
  Z = 0;
  return W;
}
function Jk() {
  for (; Y !== null; )
    Kk(Y);
}
function Bk() {
  for (; Y !== null && !$b(); )
    Kk(Y);
}
function Kk(a2) {
  var b2 = Lk(a2.alternate, a2, Vi);
  a2.memoizedProps = a2.pendingProps;
  b2 === null ? Ik(a2) : Y = b2;
  dk.current = null;
}
function Ik(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if ((b2.flags & 32768) === 0) {
      if (c2 = Qi(c2, b2, Vi), c2 !== null) {
        Y = c2;
        return;
      }
    } else {
      c2 = xj(c2, b2);
      if (c2 !== null) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (a2 !== null)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        W = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (b2 !== null) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (b2 !== null);
  W === 0 && (W = 5);
}
function Fk(a2, b2) {
  var c2 = E$4, d2 = ek.transition;
  try {
    ek.transition = null, E$4 = 1, Mk(a2, b2, c2);
  } finally {
    ek.transition = d2, E$4 = c2;
  }
  return null;
}
function Mk(a2, b2, c2) {
  do
    xk();
  while (lk !== null);
  if ((K$1 & 6) !== 0)
    throw Error(p$7(327));
  var d2 = a2.finishedWork, e2 = a2.finishedLanes;
  if (d2 === null)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (d2 === a2.current)
    throw Error(p$7(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = d2.lanes | d2.childLanes;
  xc(a2, f2);
  a2 === J && (Y = J = null, Z = 0);
  (d2.subtreeFlags & 2064) === 0 && (d2.flags & 2064) === 0 || kk || (kk = true, vk(ec, function() {
    xk();
    return null;
  }));
  f2 = (d2.flags & 15990) !== 0;
  if ((d2.subtreeFlags & 15990) !== 0 || f2) {
    f2 = ek.transition;
    ek.transition = null;
    var g2 = E$4;
    E$4 = 1;
    var h2 = K$1;
    K$1 |= 4;
    dk.current = null;
    Fj(a2, d2);
    Uj(a2, d2);
    Je$1(xf);
    xf = null;
    a2.current = d2;
    Xj(d2);
    ac();
    K$1 = h2;
    E$4 = g2;
    ek.transition = f2;
  } else
    a2.current = d2;
  kk && (kk = false, lk = a2, mk = e2);
  f2 = a2.pendingLanes;
  f2 === 0 && (Gi = null);
  jc(d2.stateNode);
  tk(a2, D$2());
  if (b2 !== null)
    for (c2 = a2.onRecoverableError, d2 = 0; d2 < b2.length; d2++)
      c2(b2[d2]);
  if (Di)
    throw Di = false, a2 = Ei, Ei = null, a2;
  (mk & 1) !== 0 && a2.tag !== 0 && xk();
  f2 = a2.pendingLanes;
  (f2 & 1) !== 0 ? a2 === ok ? nk++ : (nk = 0, ok = a2) : nk = 0;
  dg();
  return null;
}
function xk() {
  if (lk !== null) {
    var a2 = zc(mk), b2 = ek.transition, c2 = E$4;
    try {
      ek.transition = null;
      E$4 = 16 > a2 ? 16 : a2;
      if (lk === null)
        var d2 = false;
      else {
        a2 = lk;
        lk = null;
        mk = 0;
        if ((K$1 & 6) !== 0)
          throw Error(p$7(331));
        var e2 = K$1;
        K$1 |= 4;
        for (X = a2.current; X !== null; ) {
          var f2 = X, g2 = f2.child;
          if ((X.flags & 16) !== 0) {
            var h2 = f2.deletions;
            if (h2 !== null) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (X = l2; X !== null; ) {
                  var m2 = X;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Gj(8, m2, f2);
                  }
                  var w2 = m2.child;
                  if (w2 !== null)
                    w2.return = m2, X = w2;
                  else
                    for (; X !== null; ) {
                      m2 = X;
                      var u2 = m2.sibling, y2 = m2.return;
                      Lj(m2);
                      if (m2 === l2) {
                        X = null;
                        break;
                      }
                      if (u2 !== null) {
                        u2.return = y2;
                        X = u2;
                        break;
                      }
                      X = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (n2 !== null) {
                var v2 = n2.child;
                if (v2 !== null) {
                  n2.child = null;
                  do {
                    var C2 = v2.sibling;
                    v2.sibling = null;
                    v2 = C2;
                  } while (v2 !== null);
                }
              }
              X = f2;
            }
          }
          if ((f2.subtreeFlags & 2064) !== 0 && g2 !== null)
            g2.return = f2, X = g2;
          else
            b:
              for (; X !== null; ) {
                f2 = X;
                if ((f2.flags & 2048) !== 0)
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Gj(9, f2, f2.return);
                  }
                var t2 = f2.sibling;
                if (t2 !== null) {
                  t2.return = f2.return;
                  X = t2;
                  break b;
                }
                X = f2.return;
              }
        }
        var r2 = a2.current;
        for (X = r2; X !== null; ) {
          g2 = X;
          var x2 = g2.child;
          if ((g2.subtreeFlags & 2064) !== 0 && x2 !== null)
            x2.return = g2, X = x2;
          else
            b:
              for (g2 = r2; X !== null; ) {
                h2 = X;
                if ((h2.flags & 2048) !== 0)
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Hj(9, h2);
                    }
                  } catch (O2) {
                    Cj(h2, h2.return, O2);
                  }
                if (h2 === g2) {
                  X = null;
                  break b;
                }
                var B2 = h2.sibling;
                if (B2 !== null) {
                  B2.return = h2.return;
                  X = B2;
                  break b;
                }
                X = h2.return;
              }
        }
        K$1 = e2;
        dg();
        if (ic && typeof ic.onPostCommitFiberRoot === "function")
          try {
            ic.onPostCommitFiberRoot(hc, a2);
          } catch (O2) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      E$4 = c2, ek.transition = b2;
    }
  }
  return false;
}
function Nk(a2, b2, c2) {
  b2 = zi(c2, b2);
  b2 = Ci(a2, b2, 1);
  vg(a2, b2);
  b2 = M$2();
  a2 = rk(a2, 1);
  a2 !== null && (wc(a2, 1, b2), tk(a2, b2));
}
function Cj(a2, b2, c2) {
  if (a2.tag === 3)
    Nk(a2, a2, c2);
  else
    for (; b2 !== null; ) {
      if (b2.tag === 3) {
        Nk(b2, a2, c2);
        break;
      } else if (b2.tag === 1) {
        var d2 = b2.stateNode;
        if (typeof b2.type.getDerivedStateFromError === "function" || typeof d2.componentDidCatch === "function" && (Gi === null || !Gi.has(d2))) {
          a2 = zi(c2, a2);
          a2 = Fi(b2, a2, 1);
          vg(b2, a2);
          a2 = M$2();
          b2 = rk(b2, 1);
          b2 !== null && (wc(b2, 1, a2), tk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ii(a2, b2, c2) {
  var d2 = a2.pingCache;
  d2 !== null && d2.delete(b2);
  b2 = M$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  J === a2 && (Z & c2) === c2 && (W === 4 || W === 3 && (Z & 130023424) === Z && 500 > D$2() - Vj ? Ak(a2, 0) : hk |= c2);
  tk(a2, b2);
}
function Ok(a2, b2) {
  b2 === 0 && ((a2.mode & 1) === 0 ? b2 = 1 : (b2 = pc, pc <<= 1, (pc & 130023424) === 0 && (pc = 4194304)));
  var c2 = M$2();
  a2 = rk(a2, b2);
  a2 !== null && (wc(a2, b2, c2), tk(a2, c2));
}
function qj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  b2 !== null && (c2 = b2.retryLane);
  Ok(a2, c2);
}
function Tj(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      e2 !== null && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$7(314));
  }
  d2 !== null && d2.delete(b2);
  Ok(a2, c2);
}
var Lk;
Lk = function(a2, b2, c2) {
  if (a2 !== null)
    if (a2.memoizedProps !== b2.pendingProps || Qf.current)
      og = true;
    else {
      if ((a2.lanes & c2) === 0 && (b2.flags & 128) === 0)
        return og = false, wj(a2, b2, c2);
      og = (a2.flags & 131072) !== 0 ? true : false;
    }
  else
    og = false, N && (b2.flags & 1048576) !== 0 && Ug(b2, Ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
      a2 = b2.pendingProps;
      var e2 = Sf(b2, I$1.current);
      ng(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      typeof e2 === "object" && e2 !== null && typeof e2.render === "function" && e2.$$typeof === void 0 ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Tf(d2) ? (f2 = true, Xf(b2)) : f2 = false, b2.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null, sg(b2), e2.updater = Fg, b2.stateNode = e2, e2._reactInternals = b2, Jg(b2, d2, a2, c2), b2 = hj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, N && f2 && Vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Pk(d2);
        a2 = fg(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = gj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, fg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$7(306, d2, ""));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : fg(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : fg(d2, e2), gj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        ij(b2);
        if (a2 === null)
          throw Error(p$7(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        tg(a2, b2);
        yg(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = {
            element: d2,
            isDehydrated: false,
            cache: g2.cache,
            transitions: g2.transitions
          }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Error(p$7(423));
            b2 = jj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Error(p$7(424));
            b2 = jj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (Yg = Ff(b2.stateNode.containerInfo.firstChild), Xg = b2, N = true, Zg = null, c2 = sh(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          gh();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), a2 === null && dh(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = a2 !== null ? a2.memoizedProps : null, g2 = e2.children, yf(d2, e2) ? g2 = null : f2 !== null && yf(d2, f2) && (b2.flags |= 32), fj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return a2 === null && dh(b2), null;
    case 13:
      return mj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, a2 === null ? b2.child = rh(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : fg(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        H(gg, d2._currentValue);
        d2._currentValue = g2;
        if (f2 !== null)
          if (Ce$1(f2.value, g2)) {
            if (f2.children === e2.children && !Qf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, f2 !== null && (f2.return = b2); f2 !== null; ) {
              var h2 = f2.dependencies;
              if (h2 !== null) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; k2 !== null; ) {
                  if (k2.context === d2) {
                    if (f2.tag === 1) {
                      k2 = ug(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (l2 !== null) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        m2 === null ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    k2 !== null && (k2.lanes |= c2);
                    mg(f2.return, c2, b2);
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (f2.tag === 10)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (f2.tag === 18) {
                g2 = f2.return;
                if (g2 === null)
                  throw Error(p$7(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                h2 !== null && (h2.lanes |= c2);
                mg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (g2 !== null)
                g2.return = f2;
              else
                for (g2 = f2; g2 !== null; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (f2 !== null) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ng(b2, c2), e2 = pg(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = fg(d2, b2.pendingProps), e2 = fg(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : fg(d2, e2), a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Tf(d2) ? (a2 = true, Xf(b2)) : a2 = false, ng(b2, c2), Hg(b2, d2, e2), Jg(b2, d2, e2, c2), hj(null, b2, d2, true, a2, c2);
    case 19:
      return vj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$7(156, b2.tag));
};
function vk(a2, b2) {
  return Yb(a2, b2);
}
function Qk(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function ah(a2, b2, c2, d2) {
  return new Qk(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Pk(a2) {
  if (typeof a2 === "function")
    return aj(a2) ? 1 : 0;
  if (a2 !== void 0 && a2 !== null) {
    a2 = a2.$$typeof;
    if (a2 === Ba)
      return 11;
    if (a2 === Ea)
      return 14;
  }
  return 2;
}
function mh(a2, b2) {
  var c2 = a2.alternate;
  c2 === null ? (c2 = ah(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = b2 === null ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function oh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if (typeof a2 === "function")
    aj(a2) && (g2 = 1);
  else if (typeof a2 === "string")
    g2 = 5;
  else
    a:
      switch (a2) {
        case va:
          return qh(c2.children, e2, f2, b2);
        case wa:
          g2 = 8;
          e2 |= 8;
          break;
        case xa:
          return a2 = ah(12, c2, b2, e2 | 2), a2.elementType = xa, a2.lanes = f2, a2;
        case Ca:
          return a2 = ah(13, c2, b2, e2), a2.elementType = Ca, a2.lanes = f2, a2;
        case Da:
          return a2 = ah(19, c2, b2, e2), a2.elementType = Da, a2.lanes = f2, a2;
        case Ga:
          return nj(c2, e2, f2, b2);
        default:
          if (typeof a2 === "object" && a2 !== null)
            switch (a2.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case Aa:
                g2 = 9;
                break a;
              case Ba:
                g2 = 11;
                break a;
              case Ea:
                g2 = 14;
                break a;
              case Fa:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$7(130, a2 == null ? a2 : typeof a2, ""));
      }
  b2 = ah(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = ah(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function nj(a2, b2, c2, d2) {
  a2 = ah(22, a2, d2, b2);
  a2.elementType = Ga;
  a2.lanes = c2;
  a2.stateNode = {};
  return a2;
}
function nh(a2, b2, c2) {
  a2 = ah(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function ph(a2, b2, c2) {
  b2 = ah(4, a2.children !== null ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function Rk(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = vc(0);
  this.expirationTimes = vc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = vc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function Sk(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new Rk(a2, b2, c2, h2, k2);
  b2 === 1 ? (b2 = 1, f2 === true && (b2 |= 8)) : b2 = 0;
  f2 = ah(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null };
  sg(f2);
  return a2;
}
function Tk(a2, b2, c2) {
  var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: ua, key: d2 == null ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function Uk(a2) {
  if (!a2)
    return Pf;
  a2 = a2._reactInternals;
  a: {
    if (Sb(a2) !== a2 || a2.tag !== 1)
      throw Error(p$7(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Tf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (b2 !== null);
    throw Error(p$7(171));
  }
  if (a2.tag === 1) {
    var c2 = a2.type;
    if (Tf(c2))
      return Wf(a2, c2, b2);
  }
  return b2;
}
function Vk(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = Sk(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = Uk(null);
  c2 = a2.current;
  d2 = M$2();
  e2 = Dg(c2);
  f2 = ug(d2, e2);
  f2.callback = b2 !== void 0 && b2 !== null ? b2 : null;
  vg(c2, f2);
  a2.current.lanes = e2;
  wc(a2, e2, d2);
  tk(a2, d2);
  return a2;
}
function Wk(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = M$2(), g2 = Dg(e2);
  c2 = Uk(c2);
  b2.context === null ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ug(f2, g2);
  b2.payload = { element: a2 };
  d2 = d2 === void 0 ? null : d2;
  d2 !== null && (b2.callback = d2);
  vg(e2, b2);
  a2 = Eg(e2, g2, f2);
  a2 !== null && wg(a2, e2, g2);
  return g2;
}
function Xk(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function Yk(a2, b2) {
  a2 = a2.memoizedState;
  if (a2 !== null && a2.dehydrated !== null) {
    var c2 = a2.retryLane;
    a2.retryLane = c2 !== 0 && c2 < b2 ? c2 : b2;
  }
}
function Zk(a2, b2) {
  Yk(a2, b2);
  (a2 = a2.alternate) && Yk(a2, b2);
}
function $k() {
  return null;
}
var al = typeof reportError === "function" ? reportError : function(a2) {
  console.error(a2);
};
function bl(a2) {
  this._internalRoot = a2;
}
cl.prototype.render = bl.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (b2 === null)
    throw Error(p$7(409));
  Wk(a2, b2, null, null);
};
cl.prototype.unmount = bl.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (a2 !== null) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Hk(function() {
      Wk(null, a2, null, null);
    });
    b2[pf] = null;
  }
};
function cl(a2) {
  this._internalRoot = a2;
}
cl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Dc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Mc.length && b2 !== 0 && b2 < Mc[c2].priority; c2++)
      ;
    Mc.splice(c2, 0, a2);
    c2 === 0 && Rc(a2);
  }
};
function dl(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11);
}
function el(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11 && (a2.nodeType !== 8 || a2.nodeValue !== " react-mount-point-unstable "));
}
function fl() {
}
function gl(a2, b2, c2, d2, e2) {
  if (e2) {
    if (typeof d2 === "function") {
      var f2 = d2;
      d2 = function() {
        var a3 = Xk(g2);
        f2.call(a3);
      };
    }
    var g2 = Vk(b2, d2, a2, 0, null, false, false, "", fl);
    a2._reactRootContainer = g2;
    a2[pf] = g2.current;
    nf(a2.nodeType === 8 ? a2.parentNode : a2);
    Hk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if (typeof d2 === "function") {
    var h2 = d2;
    d2 = function() {
      var a3 = Xk(k2);
      h2.call(a3);
    };
  }
  var k2 = Sk(a2, 0, false, null, null, false, false, "", fl);
  a2._reactRootContainer = k2;
  a2[pf] = k2.current;
  nf(a2.nodeType === 8 ? a2.parentNode : a2);
  Hk(function() {
    Wk(b2, k2, c2, d2);
  });
  return k2;
}
function hl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if (typeof e2 === "function") {
      var h2 = e2;
      e2 = function() {
        var a3 = Xk(g2);
        h2.call(a3);
      };
    }
    Wk(b2, g2, a2, e2);
  } else
    g2 = gl(c2, b2, a2, e2, d2);
  return Xk(g2);
}
Ac = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = qc(b2.pendingLanes);
        c2 !== 0 && (yc(b2, c2 | 1), tk(b2, D$2()), (K$1 & 6) === 0 && (Ti = D$2() + 500, dg()));
      }
      break;
    case 13:
      var d2 = M$2();
      Hk(function() {
        return Eg(a2, 1, d2);
      });
      Zk(a2, 1);
  }
};
Bc = function(a2) {
  if (a2.tag === 13) {
    var b2 = M$2();
    Eg(a2, 134217728, b2);
    Zk(a2, 134217728);
  }
};
Cc = function(a2) {
  if (a2.tag === 13) {
    var b2 = M$2(), c2 = Dg(a2);
    Eg(a2, c2, b2);
    Zk(a2, c2);
  }
};
Dc = function() {
  return E$4;
};
Ec = function(a2, b2) {
  var c2 = E$4;
  try {
    return E$4 = a2, b2();
  } finally {
    E$4 = c2;
  }
};
vb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      Za(a2, c2);
      b2 = c2.name;
      if (c2.type === "radio" && b2 != null) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Ab(d2);
            if (!e2)
              throw Error(p$7(90));
            Ua(d2);
            Za(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      fb(a2, c2);
      break;
    case "select":
      b2 = c2.value, b2 != null && cb(a2, !!c2.multiple, b2, false);
  }
};
Db = Gk;
Eb = Hk;
var il = { usingClientEntryPoint: false, Events: [zb, pe$1, Ab, Bb, Cb, Gk] }, jl = { findFiberByHostInstance: Sc, bundleType: 0, version: "18.0.0-fc46dba67-20220329", rendererPackageName: "react-dom" };
var kl = { bundleType: jl.bundleType, version: jl.version, rendererPackageName: jl.rendererPackageName, rendererConfig: jl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: sa.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Wb(a2);
  return a2 === null ? null : a2.stateNode;
}, findFiberByHostInstance: jl.findFiberByHostInstance || $k, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  var ll = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!ll.isDisabled && ll.supportsFiber)
    try {
      hc = ll.inject(kl), ic = ll;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = il;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!dl(b2))
    throw Error(p$7(200));
  return Tk(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!dl(a2))
    throw Error(p$7(299));
  var c2 = false, d2 = "", e2 = al;
  b2 !== null && b2 !== void 0 && (b2.unstable_strictMode === true && (c2 = true), b2.identifierPrefix !== void 0 && (d2 = b2.identifierPrefix), b2.onRecoverableError !== void 0 && (e2 = b2.onRecoverableError));
  b2 = Sk(a2, 1, false, null, null, c2, false, d2, e2);
  a2[pf] = b2.current;
  nf(a2.nodeType === 8 ? a2.parentNode : a2);
  return new bl(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (a2 == null)
    return null;
  if (a2.nodeType === 1)
    return a2;
  var b2 = a2._reactInternals;
  if (b2 === void 0) {
    if (typeof a2.render === "function")
      throw Error(p$7(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$7(268, a2));
  }
  a2 = Wb(b2);
  a2 = a2 === null ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Hk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!el(b2))
    throw Error(p$7(200));
  return hl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!dl(a2))
    throw Error(p$7(405));
  var d2 = c2 != null && c2.hydratedSources || null, e2 = false, f2 = "", g2 = al;
  c2 !== null && c2 !== void 0 && (c2.unstable_strictMode === true && (e2 = true), c2.identifierPrefix !== void 0 && (f2 = c2.identifierPrefix), c2.onRecoverableError !== void 0 && (g2 = c2.onRecoverableError));
  b2 = Vk(b2, null, a2, 1, c2 != null ? c2 : null, e2, false, f2, g2);
  a2[pf] = b2.current;
  nf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), b2.mutableSourceEagerHydrationData == null ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(c2, e2);
  return new cl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!el(b2))
    throw Error(p$7(200));
  return hl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!el(a2))
    throw Error(p$7(40));
  return a2._reactRootContainer ? (Hk(function() {
    hl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[pf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Gk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!el(c2))
    throw Error(p$7(200));
  if (a2 == null || a2._reactInternals === void 0)
    throw Error(p$7(38));
  return hl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.0.0-fc46dba67-20220329";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err2) {
    console.error(err2);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var te = reactDom.exports;
var createRoot;
var m$8 = reactDom.exports;
{
  createRoot = m$8.createRoot;
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before2;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before2 = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before2 = _this.container.firstChild;
        } else {
          before2 = _this.before;
        }
      } else {
        before2 = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before2);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash$2(value, length2) {
  return (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
}
function trim(value) {
  return value.trim();
}
function match$2(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index3) {
  return value.charCodeAt(index3) | 0;
}
function substr(value, begin, end3) {
  return value.slice(begin, end3);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy$1(root, props) {
  return assign$1(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end3) {
  return substr(characters, begin, end3);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index3, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index3, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index3) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index3, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index3) {
  while (!token(peek()))
    next();
  return slice(index3, position);
}
function compile(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index3 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && characters2.charCodeAt(length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index3++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index3, offset3, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse$3(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$3(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index3 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index3, offset3, rules, points, type, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index3; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index3, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index3, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index3, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index3, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, { value: replace$1(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine$1(element.props, function(value) {
              switch (match$2(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, { props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")] })], callback);
                case "::placeholder":
                  return serialize([
                    copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }),
                    copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")] }),
                    copy$1(element, { props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")] })
                  ], callback);
              }
              return "";
            });
      }
  }
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
function memoize(fn3) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn3(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index3) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index3] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index3 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index3] = 1;
        }
        parsed[index3] += identifierWithPointTracking(position - 1, points, index3);
        break;
      case 2:
        parsed[index3] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index3] = peek() === 58 ? "&\f" : "";
          points[index3] = parsed[index3].length;
          break;
        }
      default:
        parsed[index3] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node5) {
      var dataEmotionAttribute = node5.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node5);
      node5.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + key + ' "]'), function(node5) {
      var attrib = node5.getAttribute("data-emotion").split(" ");
      for (var i2 = 1; i2 < attrib.length; i2++) {
        inserted[attrib[i2]] = true;
      }
      nodesToHydrate.push(node5);
    });
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$5 = typeof Symbol === "function" && Symbol.for, c$6 = b$5 ? Symbol.for("react.element") : 60103, d$7 = b$5 ? Symbol.for("react.portal") : 60106, e$2 = b$5 ? Symbol.for("react.fragment") : 60107, f$8 = b$5 ? Symbol.for("react.strict_mode") : 60108, g$4 = b$5 ? Symbol.for("react.profiler") : 60114, h$5 = b$5 ? Symbol.for("react.provider") : 60109, k$2 = b$5 ? Symbol.for("react.context") : 60110, l$6 = b$5 ? Symbol.for("react.async_mode") : 60111, m$7 = b$5 ? Symbol.for("react.concurrent_mode") : 60111, n$5 = b$5 ? Symbol.for("react.forward_ref") : 60112, p$6 = b$5 ? Symbol.for("react.suspense") : 60113, q$1 = b$5 ? Symbol.for("react.suspense_list") : 60120, r$5 = b$5 ? Symbol.for("react.memo") : 60115, t$5 = b$5 ? Symbol.for("react.lazy") : 60116, v$4 = b$5 ? Symbol.for("react.block") : 60121, w$4 = b$5 ? Symbol.for("react.fundamental") : 60117, x$4 = b$5 ? Symbol.for("react.responder") : 60118, y$2 = b$5 ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$6:
        switch (a2 = a2.type, a2) {
          case l$6:
          case m$7:
          case e$2:
          case g$4:
          case f$8:
          case p$6:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n$5:
              case t$5:
              case r$5:
              case h$5:
                return a2;
              default:
                return u2;
            }
        }
      case d$7:
        return u2;
    }
  }
}
function A$2(a2) {
  return z(a2) === m$7;
}
reactIs_production_min.AsyncMode = l$6;
reactIs_production_min.ConcurrentMode = m$7;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$5;
reactIs_production_min.Element = c$6;
reactIs_production_min.ForwardRef = n$5;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t$5;
reactIs_production_min.Memo = r$5;
reactIs_production_min.Portal = d$7;
reactIs_production_min.Profiler = g$4;
reactIs_production_min.StrictMode = f$8;
reactIs_production_min.Suspense = p$6;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$2(a2) || z(a2) === l$6;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h$5;
};
reactIs_production_min.isElement = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c$6;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n$5;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e$2;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t$5;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r$5;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d$7;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g$4;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f$8;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p$6;
};
reactIs_production_min.isValidElementType = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e$2 || a2 === m$7 || a2 === g$4 || a2 === f$8 || a2 === p$6 || a2 === q$1 || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t$5 || a2.$$typeof === r$5 || a2.$$typeof === h$5 || a2.$$typeof === k$2 || a2.$$typeof === n$5 || a2.$$typeof === w$4 || a2.$$typeof === x$4 || a2.$$typeof === y$2 || a2.$$typeof === v$4);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIs = reactIs$1.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$3 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser$3 === false) && cache.registered[className] === void 0) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result2 = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result2);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ react.exports.createContext(typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
  key: "css"
}) : null);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var cache = react.exports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ react.exports.createContext({});
var useInsertionEffect$2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : function useInsertionEffect(create6) {
  create6();
};
function useInsertionEffectMaybe$1(create6) {
  useInsertionEffect$2(create6);
}
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$2 = function Insertion(_ref2) {
  var cache = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectMaybe$1(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, react.exports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion$2, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ react.exports.createElement(WrappedComponent, newProps));
});
var useInsertionEffect$1 = React["useInsertionEffect"] ? React["useInsertionEffect"] : react.exports.useLayoutEffect;
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, react.exports.useContext(ThemeContext));
  var sheetRef = react.exports.useRef();
  useInsertionEffect$1(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node5 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node5 !== null) {
      rehydrating = true;
      node5.setAttribute("data-emotion", key);
      sheet.hydrate([node5]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffect$1(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString8() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames$1 = function classnames(args) {
  var len = args.length;
  var i2 = 0;
  var cls = "";
  for (; i2 < len; i2++) {
    var arg = args[i2];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames(arg);
        } else {
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion$1 = function Insertion2(_ref2) {
  var cache = _ref2.cache, serializedArr = _ref2.serializedArr;
  useInsertionEffectMaybe$1(function() {
    for (var i2 = 0; i2 < serializedArr.length; i2++) {
      insertStyles(cache, serializedArr[i2], false);
    }
  });
  return null;
};
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && false) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && false) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css2, classnames$1(args));
  };
  var content2 = {
    css: css2,
    cx,
    theme: react.exports.useContext(ThemeContext)
  };
  var ele = props.children(content2);
  hasRendered = true;
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion$1, {
    cache,
    serializedArr
  }), ele);
});
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(function(prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : function useInsertionEffect3(create6) {
  create6();
};
function useInsertionEffectMaybe(create6) {
  useInsertionEffect2(create6);
}
var Insertion3 = function Insertion4(_ref2) {
  var cache = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectMaybe(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      styles.push(args[0][0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = react.exports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion3, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ react.exports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
function useCombinedRefs(...refs) {
  return react.exports.useMemo(() => (node5) => {
    refs.forEach((ref) => ref(node5));
  }, refs);
}
const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode(node5) {
  return "nodeType" in node5;
}
function getWindow$1(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node5) {
  const {
    Document: Document2
  } = getWindow$1(node5);
  return node5 instanceof Document2;
}
function isHTMLElement$1(node5) {
  if (isWindow(node5)) {
    return false;
  }
  return node5 instanceof getWindow$1(node5).HTMLElement;
}
function isSVGElement(node5) {
  return node5 instanceof getWindow$1(node5).SVGElement;
}
function getOwnerDocument$1(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement$1(target)) {
    return target.ownerDocument;
  }
  return document;
}
const useIsomorphicLayoutEffect$3 = canUseDOM ? react.exports.useLayoutEffect : react.exports.useEffect;
function useInterval() {
  const intervalRef = react.exports.useRef(null);
  const set2 = react.exports.useCallback((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = react.exports.useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set2, clear];
}
function useLatestValue(value, dependencies = [value]) {
  const valueRef = react.exports.useRef(value);
  useIsomorphicLayoutEffect$3(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = react.exports.useRef();
  return react.exports.useMemo(() => {
    const newValue = callback(valueRef.current);
    valueRef.current = newValue;
    return newValue;
  }, [...dependencies]);
}
function useNodeRef(onChange) {
  const onChangeRef = useLatestValue(onChange);
  const node5 = react.exports.useRef(null);
  const setNodeRef = react.exports.useCallback((element) => {
    if (element !== node5.current) {
      onChangeRef.current == null ? void 0 : onChangeRef.current(element, node5.current);
    }
    node5.current = element;
  }, []);
  return [node5, setNodeRef];
}
let ids = {};
function useUniqueId(prefix2, value) {
  return react.exports.useMemo(() => {
    if (value) {
      return value;
    }
    const id2 = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
    ids[prefix2] = id2;
    return `${prefix2}-${id2}`;
  }, [prefix2, value]);
}
function createAdjustmentFn(modifier) {
  return (object, ...adjustments) => {
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key, valueAdjustment] of entries) {
        const value = accumulator[key];
        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, __spreadValues({}, object));
  };
}
const add = /* @__PURE__ */ createAdjustmentFn(1);
const subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent: KeyboardEvent2
  } = getWindow$1(event.target);
  return KeyboardEvent2 && event instanceof KeyboardEvent2;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow$1(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event.touches[0];
      return {
        x: x2,
        y: y2
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x2,
        clientY: y2
      } = event.changedTouches[0];
      return {
        x: x2,
        y: y2
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
const CSS = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x2,
        y: y2
      } = transform;
      return `translate3d(${x2 ? Math.round(x2) : 0}px, ${y2 ? Math.round(y2) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX: scaleX2,
        scaleY: scaleY2
      } = transform;
      return `scaleX(${scaleX2}) scaleY(${scaleY2})`;
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString({
      property,
      duration,
      easing
    }) {
      return `${property} ${duration}ms ${easing}`;
    }
  }
});
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$7 = react.exports, k$1 = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$6 = Object.prototype.hasOwnProperty, n$4 = f$7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  g2 !== void 0 && (e2 = "" + g2);
  a2.key !== void 0 && (e2 = "" + a2.key);
  a2.ref !== void 0 && (h2 = a2.ref);
  for (b2 in a2)
    m$6.call(a2, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      d2[b2] === void 0 && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx$1 = jsxRuntime.exports.jsx;
const jsxs$1 = jsxRuntime.exports.jsxs;
const Fragment$2 = jsxRuntime.exports.Fragment;
var Fragment$1 = Fragment$2;
function jsx(type, props, key) {
  if (!hasOwnProperty.call(props, "css")) {
    return jsx$1(type, props, key);
  }
  return jsx$1(Emotion, createEmotionProps(type, props), key);
}
function jsxs(type, props, key) {
  if (!hasOwnProperty.call(props, "css")) {
    return jsxs$1(type, props, key);
  }
  return jsxs$1(Emotion, createEmotionProps(type, props), key);
}
const hiddenStyles = {
  display: "none"
};
function HiddenText({
  id: id2,
  value
}) {
  return /* @__PURE__ */ jsx("div", {
    id: id2,
    style: hiddenStyles,
    children: value
  });
}
const visuallyHidden = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function LiveRegion({
  id: id2,
  announcement
}) {
  return /* @__PURE__ */ jsx("div", {
    id: id2,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true,
    children: announcement
  });
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = react.exports.useState("");
  const announce = react.exports.useCallback((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}
const screenReaderInstructions = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
};
const defaultAnnouncements = {
  onDragStart(id2) {
    return `Picked up draggable item ${id2}.`;
  },
  onDragOver(id2, overId) {
    if (overId) {
      return `Draggable item ${id2} was moved over droppable area ${overId}.`;
    }
    return `Draggable item ${id2} is no longer over a droppable area.`;
  },
  onDragEnd(id2, overId) {
    if (overId) {
      return `Draggable item ${id2} was dropped over droppable area ${overId}`;
    }
    return `Draggable item ${id2} was dropped.`;
  },
  onDragCancel(id2) {
    return `Dragging was cancelled. Draggable item ${id2} was dropped.`;
  }
};
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop$1(..._args) {
}
class DroppableContainersMap extends Map {
  get(id2) {
    var _super$get;
    return id2 != null ? (_super$get = super.get(id2)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter(({
      disabled
    }) => !disabled);
  }
  getNodeFor(id2) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id2)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
}
const Context$1 = /* @__PURE__ */ react.exports.createContext({
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  activeNodeClientRect: null,
  activators: [],
  ariaDescribedById: {
    draggable: ""
  },
  containerNodeRect: null,
  dispatch: noop$1,
  draggableNodes: {},
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop$1
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  recomputeLayouts: noop$1,
  windowRect: null,
  willRecomputeLayouts: false
});
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: {},
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return __spreadProps(__spreadValues({}, state), {
        draggable: __spreadProps(__spreadValues({}, state.draggable), {
          initialCoordinates: action.initialCoordinates,
          active: action.active
        })
      });
    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return __spreadProps(__spreadValues({}, state), {
        draggable: __spreadProps(__spreadValues({}, state.draggable), {
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        })
      });
    case Action.DragEnd:
    case Action.DragCancel:
      return __spreadProps(__spreadValues({}, state), {
        draggable: __spreadProps(__spreadValues({}, state.draggable), {
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        })
      });
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id: id2
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, element);
      return __spreadProps(__spreadValues({}, state), {
        droppable: __spreadProps(__spreadValues({}, state.droppable), {
          containers
        })
      });
    }
    case Action.SetDroppableDisabled: {
      const {
        id: id2,
        key,
        disabled
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, __spreadProps(__spreadValues({}, element), {
        disabled
      }));
      return __spreadProps(__spreadValues({}, state), {
        droppable: __spreadProps(__spreadValues({}, state.droppable), {
          containers
        })
      });
    }
    case Action.UnregisterDroppable: {
      const {
        id: id2,
        key
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id2);
      return __spreadProps(__spreadValues({}, state), {
        droppable: __spreadProps(__spreadValues({}, state.droppable), {
          containers
        })
      });
    }
    default: {
      return state;
    }
  }
}
const DndMonitorContext = /* @__PURE__ */ react.exports.createContext({
  type: null,
  event: null
});
function useDndMonitor({
  onDragStart,
  onDragMove,
  onDragOver,
  onDragEnd,
  onDragCancel
}) {
  const monitorState = react.exports.useContext(DndMonitorContext);
  const previousMonitorState = react.exports.useRef(monitorState);
  react.exports.useEffect(() => {
    if (monitorState !== previousMonitorState.current) {
      const {
        type,
        event
      } = monitorState;
      switch (type) {
        case Action.DragStart:
          onDragStart == null ? void 0 : onDragStart(event);
          break;
        case Action.DragMove:
          onDragMove == null ? void 0 : onDragMove(event);
          break;
        case Action.DragOver:
          onDragOver == null ? void 0 : onDragOver(event);
          break;
        case Action.DragCancel:
          onDragCancel == null ? void 0 : onDragCancel(event);
          break;
        case Action.DragEnd:
          onDragEnd == null ? void 0 : onDragEnd(event);
          break;
      }
      previousMonitorState.current = monitorState;
    }
  }, [monitorState, onDragStart, onDragMove, onDragOver, onDragEnd, onDragCancel]);
}
function Accessibility({
  announcements = defaultAnnouncements,
  hiddenTextDescribedById,
  screenReaderInstructions: screenReaderInstructions2
}) {
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId(`DndLiveRegion`);
  const [mounted, setMounted] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setMounted(true);
  }, []);
  useDndMonitor(react.exports.useMemo(() => ({
    onDragStart({
      active
    }) {
      announce(announcements.onDragStart(active.id));
    },
    onDragMove({
      active,
      over
    }) {
      if (announcements.onDragMove) {
        announce(announcements.onDragMove(active.id, over == null ? void 0 : over.id));
      }
    },
    onDragOver({
      active,
      over
    }) {
      announce(announcements.onDragOver(active.id, over == null ? void 0 : over.id));
    },
    onDragEnd({
      active,
      over
    }) {
      announce(announcements.onDragEnd(active.id, over == null ? void 0 : over.id));
    },
    onDragCancel({
      active
    }) {
      announce(announcements.onDragCancel(active.id));
    }
  }), [announce, announcements]));
  return mounted ? reactDom.exports.createPortal(/* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(HiddenText, {
      id: hiddenTextDescribedById,
      value: screenReaderInstructions2.draggable
    }), /* @__PURE__ */ jsx(LiveRegion, {
      id: liveRegionId,
      announcement
    })]
  }), document.body) : null;
}
const defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function centerOfRectangle(rect, left2 = rect.offsetLeft, top2 = rect.offsetTop) {
  return {
    x: left2 + rect.width * 0.5,
    y: top2 + rect.height * 0.5
  };
}
const closestCenter = ({
  collisionRect,
  droppableContainers
}) => {
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  let minDistanceToCenter = Infinity;
  let minDroppableContainer = null;
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      if (distBetween < minDistanceToCenter) {
        minDistanceToCenter = distBetween;
        minDroppableContainer = droppableContainer.id;
      }
    }
  }
  return minDroppableContainer;
};
function adjustScale(transform, rect1, rect2) {
  return __spreadProps(__spreadValues({}, transform), {
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  });
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustViewRect(viewRect, ...adjustments) {
    return adjustments.reduce((acc, adjustment) => __spreadProps(__spreadValues({}, acc), {
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x,
      offsetLeft: acc.offsetLeft + modifier * adjustment.x,
      offsetTop: acc.offsetTop + modifier * adjustment.y
    }), __spreadValues({}, viewRect));
  };
}
const getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function isFixed(node5, computedStyle = window.getComputedStyle(node5)) {
  return computedStyle.position === "fixed";
}
function isScrollable(node5, computedStyle = window.getComputedStyle(node5)) {
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.find((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  }) != null;
}
function getScrollableAncestors(element) {
  const scrollParents = [];
  function findScrollableAncestors(node5) {
    if (!node5) {
      return scrollParents;
    }
    if (isDocument(node5) && node5.scrollingElement != null && !scrollParents.includes(node5.scrollingElement)) {
      scrollParents.push(node5.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement$1(node5) || isSVGElement(node5)) {
      return scrollParents;
    }
    if (scrollParents.includes(node5)) {
      return scrollParents;
    }
    const computedStyle = window.getComputedStyle(node5);
    if (isScrollable(node5, computedStyle)) {
      scrollParents.push(node5);
    }
    if (isFixed(node5, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node5.parentNode);
  }
  return element ? findScrollableAncestors(element.parentNode) : scrollParents;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument$1(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement$1(element)) {
    return element;
  }
  return null;
}
function getScrollCoordinates(element) {
  if (isWindow(element)) {
    return {
      x: element.scrollX,
      y: element.scrollY
    };
  }
  return {
    x: element.scrollLeft,
    y: element.scrollTop
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - scrollingContainer.clientWidth,
    y: scrollingContainer.scrollHeight - scrollingContainer.clientHeight
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
const defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, {
  top: top2,
  left: left2,
  right: right2,
  bottom: bottom2
}, acceleration = 10, thresholdPercentage = defaultThreshold) {
  const {
    clientHeight,
    clientWidth
  } = scrollContainer;
  const finalScrollContainerRect = isDocumentScrollingElement(scrollContainer) ? {
    top: 0,
    left: 0,
    right: clientWidth,
    bottom: clientHeight,
    width: clientWidth,
    height: clientHeight
  } : scrollContainerRect;
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: finalScrollContainerRect.height * thresholdPercentage.y,
    width: finalScrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top2 <= finalScrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.top + threshold.height - top2) / threshold.height);
  } else if (!isBottom && bottom2 >= finalScrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.bottom - threshold.height - bottom2) / threshold.height);
  }
  if (!isRight && right2 >= finalScrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.right - threshold.width - right2) / threshold.width);
  } else if (!isLeft && left2 <= finalScrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.left + threshold.width - left2) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight: innerHeight2
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight2,
      width: innerWidth,
      height: innerHeight2
    };
  }
  const {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  } = element.getBoundingClientRect();
  return {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node5) => {
    return add(acc, getScrollCoordinates(node5));
  }, defaultCoordinates);
}
function getEdgeOffset(node5, parent, offset3 = defaultCoordinates) {
  if (!node5 || !isHTMLElement$1(node5)) {
    return offset3;
  }
  const nodeOffset = {
    x: offset3.x + node5.offsetLeft,
    y: offset3.y + node5.offsetTop
  };
  if (node5.offsetParent === parent) {
    return nodeOffset;
  }
  return getEdgeOffset(node5.offsetParent, parent, nodeOffset);
}
function getLayoutRect$1(element) {
  const {
    offsetWidth: width,
    offsetHeight: height
  } = element;
  const {
    x: offsetLeft,
    y: offsetTop2
  } = getEdgeOffset(element, null);
  return {
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function getBoundingClientRect$1(element) {
  if (isWindow(element)) {
    const width2 = window.innerWidth;
    const height2 = window.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width2,
      bottom: height2,
      width: width2,
      height: height2,
      offsetTop: 0,
      offsetLeft: 0
    };
  }
  const {
    offsetTop: offsetTop2,
    offsetLeft
  } = getLayoutRect$1(element);
  const {
    width,
    height,
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2
  } = element.getBoundingClientRect();
  return {
    width,
    height,
    top: top2,
    bottom: bottom2,
    right: right2,
    left: left2,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function getViewRect(element) {
  const {
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  } = getLayoutRect$1(element);
  const scrollableAncestors = getScrollableAncestors(element);
  const scrollOffsets = getScrollOffsets(scrollableAncestors);
  const top2 = offsetTop2 - scrollOffsets.y;
  const left2 = offsetLeft - scrollOffsets.x;
  return {
    width,
    height,
    top: top2,
    bottom: top2 + height,
    right: left2 + width,
    left: left2,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function isViewRect(entry) {
  return "top" in entry;
}
function cornersOfRectangle(rect, left2 = rect.offsetLeft, top2 = rect.offsetTop) {
  return [{
    x: left2,
    y: top2
  }, {
    x: left2 + rect.width,
    y: top2
  }, {
    x: left2,
    y: top2 + rect.height
  }, {
    x: left2 + rect.width,
    y: top2 + rect.height
  }];
}
const closestCorners = ({
  collisionRect,
  droppableContainers
}) => {
  let minDistanceToCorners = Infinity;
  let minDistanceContainer = null;
  const corners = cornersOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const rectCorners = cornersOfRectangle(rect, isViewRect(rect) ? rect.left : void 0, isViewRect(rect) ? rect.top : void 0);
      const distances = corners.reduce((accumulator, corner, index3) => {
        return accumulator + distanceBetween(rectCorners[index3], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      if (effectiveDistance < minDistanceToCorners) {
        minDistanceToCorners = effectiveDistance;
        minDistanceContainer = droppableContainer.id;
      }
    }
  }
  return minDistanceContainer;
};
function getIntersectionRatio(entry, target) {
  const top2 = Math.max(target.top, entry.offsetTop);
  const left2 = Math.max(target.left, entry.offsetLeft);
  const right2 = Math.min(target.left + target.width, entry.offsetLeft + entry.width);
  const bottom2 = Math.min(target.top + target.height, entry.offsetTop + entry.height);
  const width = right2 - left2;
  const height = bottom2 - top2;
  if (left2 < right2 && top2 < bottom2) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
const rectIntersection = ({
  collisionRect,
  droppableContainers
}) => {
  let maxIntersectionRatio = 0;
  let maxIntersectingDroppableContainer = null;
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > maxIntersectionRatio) {
        maxIntersectionRatio = intersectionRatio;
        maxIntersectingDroppableContainer = droppableContainer.id;
      }
    }
  }
  return maxIntersectingDroppableContainer;
};
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller({
  acceleration,
  activator = AutoScrollActivator.Pointer,
  canScroll,
  draggingRect,
  enabled,
  interval = 5,
  order: order2 = TraversalOrder.TreeOrder,
  pointerCoordinates,
  scrollableAncestors,
  scrollableAncestorRects,
  threshold
}) {
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = react.exports.useRef({
    x: 1,
    y: 1
  });
  const rect = react.exports.useMemo(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
    return null;
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollDirection = react.exports.useRef(defaultCoordinates);
  const scrollContainerRef = react.exports.useRef(null);
  const autoScroll = react.exports.useCallback(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = react.exports.useMemo(() => order2 === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order2, scrollableAncestors]);
  react.exports.useEffect(() => {
    if (!enabled || !scrollableAncestors.length || !rect) {
      clearAutoScrollInterval();
      return;
    }
    for (const scrollContainer of sortedScrollableAncestors) {
      if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
        continue;
      }
      const index3 = scrollableAncestors.indexOf(scrollContainer);
      const scrolllContainerRect = scrollableAncestorRects[index3];
      if (!scrolllContainerRect) {
        continue;
      }
      const {
        direction,
        speed
      } = getScrollDirectionAndSpeed(scrollContainer, scrolllContainerRect, rect, acceleration, threshold);
      if (speed.x > 0 || speed.y > 0) {
        clearAutoScrollInterval();
        scrollContainerRef.current = scrollContainer;
        setAutoScrollInterval(autoScroll, interval);
        scrollSpeed.current = speed;
        scrollDirection.current = direction;
        return;
      }
    }
    scrollSpeed.current = {
      x: 0,
      y: 0
    };
    scrollDirection.current = {
      x: 0,
      y: 0
    };
    clearAutoScrollInterval();
  }, [
    acceleration,
    autoScroll,
    canScroll,
    clearAutoScrollInterval,
    enabled,
    interval,
    JSON.stringify(rect),
    setAutoScrollInterval,
    scrollableAncestors,
    sortedScrollableAncestors,
    scrollableAncestorRects,
    JSON.stringify(threshold)
  ]);
}
function useCachedNode(draggableNodes, id2) {
  const draggableNode = id2 !== null ? draggableNodes[id2] : void 0;
  const node5 = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref2;
    if (id2 === null) {
      return null;
    }
    return (_ref2 = node5 != null ? node5 : cachedNode) != null ? _ref2 : null;
  }, [node5, id2]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return react.exports.useMemo(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
function useData$1(data) {
  const dataRef = react.exports.useRef(data);
  useIsomorphicLayoutEffect$3(() => {
    if (dataRef.current !== data) {
      dataRef.current = data;
    }
  }, [data]);
  return dataRef;
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = /* @__PURE__ */ new Map();
const defaultConfig = {
  measure: getLayoutRect$1,
  strategy: MeasuringStrategy.WhileDragging,
  frequency: MeasuringFrequency.Optimized
};
function useDroppableMeasuring(containers, {
  dragging,
  dependencies,
  config
}) {
  const [willRecomputeLayouts, setWillRecomputeLayouts] = react.exports.useState(false);
  const {
    frequency,
    measure,
    strategy
  } = __spreadValues(__spreadValues({}, defaultConfig), config);
  const containersRef = react.exports.useRef(containers);
  const recomputeLayouts = react.exports.useCallback(() => setWillRecomputeLayouts(true), []);
  const recomputeLayoutsTimeoutId = react.exports.useRef(null);
  const disabled = isDisabled();
  const layoutRectMap = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || willRecomputeLayouts) {
      for (let container of containers) {
        if (!container) {
          continue;
        }
        container.rect.current = container.node.current ? measure(container.node.current) : null;
      }
      return createLayoutRectMap(containers);
    }
    return previousValue;
  }, [containers, dragging, disabled, measure, willRecomputeLayouts]);
  react.exports.useEffect(() => {
    containersRef.current = containers;
  }, [containers]);
  react.exports.useEffect(() => {
    if (willRecomputeLayouts) {
      setWillRecomputeLayouts(false);
    }
  }, [willRecomputeLayouts]);
  react.exports.useEffect(function recompute() {
    if (disabled) {
      return;
    }
    requestAnimationFrame(recomputeLayouts);
  }, [dragging, disabled]);
  react.exports.useEffect(function forceRecomputeLayouts() {
    if (disabled || typeof frequency !== "number" || recomputeLayoutsTimeoutId.current !== null) {
      return;
    }
    recomputeLayoutsTimeoutId.current = setTimeout(() => {
      recomputeLayouts();
      recomputeLayoutsTimeoutId.current = null;
    }, frequency);
  }, [frequency, disabled, recomputeLayouts, ...dependencies]);
  return {
    layoutRectMap,
    recomputeLayouts,
    willRecomputeLayouts
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function createLayoutRectMap(containers) {
  const layoutRectMap = /* @__PURE__ */ new Map();
  if (containers) {
    for (const container of containers) {
      if (!container) {
        continue;
      }
      const {
        id: id2,
        rect
      } = container;
      if (rect.current == null) {
        continue;
      }
      layoutRectMap.set(id2, rect.current);
    }
  }
  return layoutRectMap;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = react.exports.useState(null);
  const prevElements = react.exports.useRef(elements);
  const handleScroll2 = react.exports.useCallback((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  react.exports.useEffect(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll2, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll2);
      });
    }
  }, [handleScroll2, elements]);
  return react.exports.useMemo(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
const defaultValue$1 = [];
function useScrollableAncestors(node5) {
  const previousNode = react.exports.useRef(node5);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node5) {
      return defaultValue$1;
    }
    if (previousValue && node5 && previousNode.current && node5.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node5);
  }, [node5]);
  react.exports.useEffect(() => {
    previousNode.current = node5;
  }, [node5]);
  return ancestors;
}
function useSensorSetup(sensors) {
  react.exports.useEffect(() => {
    if (!canUseDOM) {
      return;
    }
    const teardownFns = sensors.map(({
      sensor
    }) => sensor.setup == null ? void 0 : sensor.setup());
    return () => {
      for (const teardown of teardownFns) {
        teardown == null ? void 0 : teardown();
      }
    };
  }, sensors.map(({
    sensor
  }) => sensor));
}
function useSyntheticListeners(listeners, id2) {
  return react.exports.useMemo(() => {
    return listeners.reduce((acc, {
      eventName,
      handler
    }) => {
      acc[eventName] = (event) => {
        handler(event, id2);
      };
      return acc;
    }, {});
  }, [listeners, id2]);
}
const useClientRect = /* @__PURE__ */ createUseRectFn(getBoundingClientRect$1);
const useClientRects = /* @__PURE__ */ createUseRectsFn(getBoundingClientRect$1);
function useRect$1(element, getRect, forceRecompute) {
  const previousElement = react.exports.useRef(element);
  return useLazyMemo((previousValue) => {
    if (!element) {
      return null;
    }
    if (forceRecompute || !previousValue && element || element !== previousElement.current) {
      if (isHTMLElement$1(element) && element.parentNode == null) {
        return null;
      }
      return getRect(element);
    }
    return previousValue != null ? previousValue : null;
  }, [element, forceRecompute, getRect]);
}
function createUseRectFn(getRect) {
  return (element, forceRecompute) => useRect$1(element, getRect, forceRecompute);
}
function createUseRectsFn(getRect) {
  const defaultValue2 = [];
  return function useRects(elements, forceRecompute) {
    const previousElements = react.exports.useRef(elements);
    return useLazyMemo((previousValue) => {
      if (!elements.length) {
        return defaultValue2;
      }
      if (forceRecompute || !previousValue && elements.length || elements !== previousElements.current) {
        return elements.map((element) => getRect(element));
      }
      return previousValue != null ? previousValue : defaultValue2;
    }, [elements, forceRecompute]);
  };
}
function getMeasurableNode(node5) {
  if (!node5) {
    return null;
  }
  if (node5.children.length > 1) {
    return node5;
  }
  const firstChild = node5.children[0];
  return isHTMLElement$1(firstChild) ? firstChild : node5;
}
function getDragOverlayRect(element) {
  const {
    width,
    height,
    offsetLeft,
    offsetTop: offsetTop2
  } = getLayoutRect$1(element);
  return {
    top: offsetTop2,
    bottom: offsetTop2 + height,
    left: offsetLeft,
    right: offsetLeft + width,
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
const useDragOverlayRect = /* @__PURE__ */ createUseRectFn(getDragOverlayRect);
function useDragOverlayMeasuring({
  disabled,
  forceRecompute
}) {
  const [nodeRef, setRef3] = useNodeRef();
  const rect = useDragOverlayRect(disabled ? null : getMeasurableNode(nodeRef.current), forceRecompute);
  return react.exports.useMemo(() => ({
    nodeRef,
    rect,
    setRef: setRef3
  }), [rect, nodeRef, setRef3]);
}
function useSensor(sensor, options) {
  return react.exports.useMemo(() => ({
    sensor,
    options: options != null ? options : {}
  }), [sensor, options]);
}
function useSensors(...sensors) {
  return react.exports.useMemo(() => [...sensors].filter((sensor) => sensor != null), [...sensors]);
}
class Listeners {
  constructor(target) {
    this.target = target;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow$1(target);
  return target instanceof EventTarget ? target : getOwnerDocument$1(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation$1(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
})(KeyboardCode || (KeyboardCode = {}));
const defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};
const defaultKeyboardCoordinateGetter = (event, {
  currentCoordinates
}) => {
  switch (event.code) {
    case KeyboardCode.Right:
      return __spreadProps(__spreadValues({}, currentCoordinates), {
        x: currentCoordinates.x + 25
      });
    case KeyboardCode.Left:
      return __spreadProps(__spreadValues({}, currentCoordinates), {
        x: currentCoordinates.x - 25
      });
    case KeyboardCode.Down:
      return __spreadProps(__spreadValues({}, currentCoordinates), {
        y: currentCoordinates.y + 25
      });
    case KeyboardCode.Up:
      return __spreadProps(__spreadValues({}, currentCoordinates), {
        y: currentCoordinates.y - 25
      });
  }
  return void 0;
};
class KeyboardSensor {
  constructor(props) {
    this.props = props;
    this.autoScrollEnabled = false;
    this.coordinates = defaultCoordinates;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument$1(target));
    this.windowListeners = new Listeners(getWindow$1(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    if (!activeNode.node.current) {
      throw new Error("Active draggable node is undefined");
    }
    const activeNodeRect = getBoundingClientRect$1(activeNode.node.current);
    const coordinates = {
      x: activeNodeRect.left,
      y: activeNodeRect.top
    };
    this.coordinates = coordinates;
    onStart(coordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        coordinates
      } = this;
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates: coordinates
      });
      if (newCoordinates) {
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const coordinatesDelta = subtract(newCoordinates, coordinates);
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Right && scrollContainer.scrollLeft + coordinatesDelta.x <= maxScroll.x || direction === KeyboardCode.Left && scrollContainer.scrollLeft + coordinatesDelta.x >= minScroll.x;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                left: coordinatesDelta.x,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            scrollContainer.scrollBy({
              left: -scrollDelta.x,
              behavior: scrollBehavior
            });
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Down && scrollContainer.scrollTop + coordinatesDelta.y <= maxScroll.y || direction === KeyboardCode.Up && scrollContainer.scrollTop + coordinatesDelta.y >= minScroll.y;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                top: coordinatesDelta.y,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            scrollContainer.scrollBy({
              top: -scrollDelta.y,
              behavior: scrollBehavior
            });
            break;
          }
        }
        this.handleMove(event, add(newCoordinates, scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
    this.coordinates = coordinates;
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
}
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, {
    keyboardCodes = defaultKeyboardCodes,
    onActivation
  }) => {
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
class AbstractPointerSensor {
  constructor(props, events2, listenerTarget = getEventListenerTarget(props.event.target)) {
    this.props = props;
    this.events = events2;
    this.autoScrollEnabled = true;
    this.activated = false;
    this.timeoutId = null;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument$1(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow$1(target));
    this.initialCoordinates = getEventCoordinates(event);
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation$1, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = getEventCoordinates(event);
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
        return;
      }
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }
  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
}
const events = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument$1(event.target);
    super(props, events, listenerTarget);
  }
}
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument$1(props.event.target));
  }
}
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$2 = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
}
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    const {
      touches: touches2
    } = event;
    if (touches2.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
function applyModifiers(modifiers2, _a) {
  var _b = _a, {
    transform
  } = _b, args = __objRest(_b, [
    "transform"
  ]);
  return (modifiers2 == null ? void 0 : modifiers2.length) ? modifiers2.reduce((accumulator, modifier) => {
    return modifier(__spreadValues({
      transform: accumulator
    }, args));
  }, transform) : transform;
}
const defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
const defaultData = {
  current: {}
};
const ActiveDraggableContext = /* @__PURE__ */ react.exports.createContext(__spreadProps(__spreadValues({}, defaultCoordinates), {
  scaleX: 1,
  scaleY: 1
}));
const DndContext = /* @__PURE__ */ react.exports.memo(function DndContext2(_c) {
  var _d = _c, {
    id: id2,
    autoScroll = true,
    announcements,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers: modifiers2,
    screenReaderInstructions: screenReaderInstructions$1 = screenReaderInstructions
  } = _d, props = __objRest(_d, [
    "id",
    "autoScroll",
    "announcements",
    "children",
    "sensors",
    "collisionDetection",
    "measuring",
    "modifiers",
    "screenReaderInstructions"
  ]);
  var _measuring$draggable$, _measuring$draggable, _sensorContext$curren, _dragOverlay$rect, _over$rect;
  const store = react.exports.useReducer(reducer, void 0, getInitialState);
  const [state, dispatch2] = store;
  const [monitorState, setMonitorState] = react.exports.useState(() => ({
    type: null,
    event: null
  }));
  const [isDragging, setIsDragging] = react.exports.useState(false);
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node5 = activeId ? draggableNodes[activeId] : null;
  const activeRects = react.exports.useRef({
    initial: null,
    translated: null
  });
  const active = react.exports.useMemo(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      data: (_node$data = node5 == null ? void 0 : node5.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node5]);
  const activeRef = react.exports.useRef(null);
  const [activeSensor, setActiveSensor] = react.exports.useState(null);
  const [activatorEvent, setActivatorEvent] = react.exports.useState(null);
  const latestProps = react.exports.useRef(props);
  const draggableDescribedById = useUniqueId(`DndDescribedBy`, id2);
  const enabledDroppableContainers = react.exports.useMemo(() => {
    return droppableContainers.getEnabled();
  }, [droppableContainers]);
  const {
    layoutRectMap: droppableRects,
    recomputeLayouts,
    willRecomputeLayouts
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isDragging,
    dependencies: [translate.x, translate.y],
    config: measuring == null ? void 0 : measuring.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = activatorEvent ? getEventCoordinates(activatorEvent) : null;
  const activeNodeRect = useRect$1(activeNode, (_measuring$draggable$ = measuring == null ? void 0 : (_measuring$draggable = measuring.draggable) == null ? void 0 : _measuring$draggable.measure) != null ? _measuring$draggable$ : getViewRect);
  const activeNodeClientRect = useClientRect(activeNode);
  const initialActiveNodeRectRef = react.exports.useRef(null);
  const initialActiveNodeRect = initialActiveNodeRectRef.current;
  const sensorContext = react.exports.useRef({
    active: null,
    activeNode,
    collisionRect: null,
    droppableRects,
    draggableNodes,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null,
    translatedRect: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const windowRect2 = useClientRect(activeNode ? activeNode.ownerDocument.defaultView : null);
  const containerNodeRect = useClientRect(activeNode ? activeNode.parentElement : null);
  const scrollableAncestors = useScrollableAncestors(activeId ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useClientRects(scrollableAncestors);
  const dragOverlay = useDragOverlayMeasuring({
    disabled: activeId == null,
    forceRecompute: willRecomputeLayouts
  });
  const draggingNodeRect = (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect;
  const nodeRectDelta = draggingNodeRect === activeNodeRect ? getRectDelta(activeNodeRect, initialActiveNodeRect) : defaultCoordinates;
  const modifiedTranslate = applyModifiers(modifiers2, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect: activeNodeClientRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect: windowRect2
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollAdjustment = useScrollOffsets(scrollableAncestors);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const translatedRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisionRect = translatedRect ? getAdjustedRect(translatedRect, scrollAdjustment) : null;
  const overId = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableContainers: enabledDroppableContainers
  }) : null;
  const [over, setOver] = react.exports.useState(null);
  const transform = adjustScale(modifiedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const instantiateSensor = react.exports.useCallback((event, {
    sensor: Sensor,
    options
  }) => {
    if (!activeRef.current) {
      return;
    }
    const activeNode2 = draggableNodes[activeRef.current];
    if (!activeNode2) {
      return;
    }
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode: activeNode2,
      event: event.nativeEvent,
      options,
      context: sensorContext,
      onStart(initialCoordinates) {
        const id3 = activeRef.current;
        if (!id3) {
          return;
        }
        const node6 = draggableNodes[id3];
        if (!node6) {
          return;
        }
        const {
          onDragStart
        } = latestProps.current;
        const event2 = {
          active: {
            id: id3,
            data: node6.data,
            rect: activeRects
          }
        };
        reactDom.exports.unstable_batchedUpdates(() => {
          dispatch2({
            type: Action.DragStart,
            initialCoordinates,
            active: id3
          });
          setMonitorState({
            type: Action.DragStart,
            event: event2
          });
        });
        onDragStart == null ? void 0 : onDragStart(event2);
      },
      onMove(coordinates) {
        dispatch2({
          type: Action.DragMove,
          coordinates
        });
      },
      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    reactDom.exports.unstable_batchedUpdates(() => {
      setActiveSensor(sensorInstance);
      setActivatorEvent(event.nativeEvent);
    });
    function createHandler(type) {
      return async function handler() {
        const {
          active: active2,
          over: over2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        let event2 = null;
        if (active2 && scrollAdjustedTranslate2) {
          const {
            cancelDrop
          } = latestProps.current;
          event2 = {
            active: active2,
            delta: scrollAdjustedTranslate2,
            over: over2
          };
          if (type === Action.DragEnd && typeof cancelDrop === "function") {
            const shouldCancel = await Promise.resolve(cancelDrop(event2));
            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }
        activeRef.current = null;
        reactDom.exports.unstable_batchedUpdates(() => {
          dispatch2({
            type
          });
          setOver(null);
          setIsDragging(false);
          setActiveSensor(null);
          setActivatorEvent(null);
          if (event2) {
            setMonitorState({
              type,
              event: event2
            });
          }
        });
        if (event2) {
          const {
            onDragCancel,
            onDragEnd
          } = latestProps.current;
          const handler2 = type === Action.DragEnd ? onDragEnd : onDragCancel;
          handler2 == null ? void 0 : handler2(event2);
        }
      };
    }
  }, [dispatch2, draggableNodes]);
  const bindActivatorToSensorInstantiator = react.exports.useCallback((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      if (activeRef.current !== null || nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      if (handler(event, sensor.options) === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect$3(() => {
    latestProps.current = props;
  }, Object.values(props));
  react.exports.useEffect(() => {
    if (activeId != null) {
      setIsDragging(true);
    }
  }, [activeId]);
  react.exports.useEffect(() => {
    if (!active) {
      initialActiveNodeRectRef.current = null;
    }
    if (active && activeNodeRect && !initialActiveNodeRectRef.current) {
      initialActiveNodeRectRef.current = activeNodeRect;
    }
  }, [activeNodeRect, active]);
  react.exports.useEffect(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active: active2,
      over: over2
    } = sensorContext.current;
    if (!active2) {
      return;
    }
    const event = {
      active: active2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    setMonitorState({
      type: Action.DragMove,
      event
    });
    onDragMove == null ? void 0 : onDragMove(event);
  }, [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  react.exports.useEffect(() => {
    const {
      active: active2,
      droppableContainers: droppableContainers2,
      scrollAdjustedTranslate: scrollAdjustedTranslate2
    } = sensorContext.current;
    if (!active2 || !activeRef.current || !scrollAdjustedTranslate2) {
      return;
    }
    const {
      onDragOver
    } = latestProps.current;
    const overContainer = droppableContainers2.get(overId);
    const over2 = overContainer && overContainer.rect.current ? {
      id: overContainer.id,
      rect: overContainer.rect.current,
      data: overContainer.data,
      disabled: overContainer.disabled
    } : null;
    const event = {
      active: active2,
      delta: {
        x: scrollAdjustedTranslate2.x,
        y: scrollAdjustedTranslate2.y
      },
      over: over2
    };
    reactDom.exports.unstable_batchedUpdates(() => {
      setOver(over2);
      setMonitorState({
        type: Action.DragOver,
        event
      });
      onDragOver == null ? void 0 : onDragOver(event);
    });
  }, [overId]);
  useIsomorphicLayoutEffect$3(() => {
    sensorContext.current = {
      active,
      activeNode,
      collisionRect,
      droppableRects,
      draggableNodes,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate,
      translatedRect
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: translatedRect
    };
  }, [active, activeNode, collisionRect, draggableNodes, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate, translatedRect]);
  useAutoScroller(__spreadProps(__spreadValues({}, getAutoScrollerOptions()), {
    draggingRect: translatedRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  }));
  const contextValue = react.exports.useMemo(() => {
    const memoizedContext = {
      active,
      activeNode,
      activeNodeRect,
      activeNodeClientRect,
      activatorEvent,
      activators,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      containerNodeRect,
      dispatch: dispatch2,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      recomputeLayouts,
      scrollableAncestors,
      scrollableAncestorRects,
      willRecomputeLayouts,
      windowRect: windowRect2
    };
    return memoizedContext;
  }, [active, activeNode, activeNodeClientRect, activeNodeRect, activatorEvent, activators, containerNodeRect, dragOverlay, dispatch2, draggableNodes, draggableDescribedById, droppableContainers, droppableRects, over, recomputeLayouts, scrollableAncestors, scrollableAncestorRects, willRecomputeLayouts, windowRect2]);
  return /* @__PURE__ */ jsxs(DndMonitorContext.Provider, {
    value: monitorState,
    children: [/* @__PURE__ */ jsx(Context$1.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx(ActiveDraggableContext.Provider, {
        value: transform,
        children
      })
    }), /* @__PURE__ */ jsx(Accessibility, {
      announcements,
      hiddenTextDescribedById: draggableDescribedById,
      screenReaderInstructions: screenReaderInstructions$1
    })]
  });
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return __spreadProps(__spreadValues({}, autoScroll), {
        enabled
      });
    }
    return {
      enabled
    };
  }
});
const NullContext = /* @__PURE__ */ react.exports.createContext(null);
const defaultRole = "button";
const ID_PREFIX$1 = "Droppable";
function useDraggable({
  id: id2,
  data,
  disabled = false,
  attributes
}) {
  const key = useUniqueId(ID_PREFIX$1);
  const {
    active,
    activeNodeRect,
    activatorEvent,
    ariaDescribedById,
    draggableNodes,
    droppableRects,
    activators,
    over
  } = react.exports.useContext(Context$1);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id2;
  const transform = react.exports.useContext(isDragging ? ActiveDraggableContext : NullContext);
  const [node5, setNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id2);
  const dataRef = useData$1(data);
  react.exports.useEffect(() => {
    draggableNodes[id2] = {
      id: id2,
      key,
      node: node5,
      data: dataRef
    };
    return () => {
      const node6 = draggableNodes[id2];
      if (node6 && node6.key === key) {
        delete draggableNodes[id2];
      }
    };
  }, [draggableNodes, id2]);
  const memoizedAttributes = react.exports.useMemo(() => ({
    role,
    tabIndex,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activeNodeRect,
    activatorEvent,
    attributes: memoizedAttributes,
    droppableRects,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node: node5,
    over,
    setNodeRef,
    transform
  };
}
function useDndContext() {
  return react.exports.useContext(Context$1);
}
const ID_PREFIX$1$1 = "Droppable";
function useDroppable({
  data,
  disabled = false,
  id: id2
}) {
  const key = useUniqueId(ID_PREFIX$1$1);
  const {
    active,
    dispatch: dispatch2,
    over
  } = react.exports.useContext(Context$1);
  const rect = react.exports.useRef(null);
  const [nodeRef, setNodeRef] = useNodeRef();
  const dataRef = useData$1(data);
  useIsomorphicLayoutEffect$3(() => {
    dispatch2({
      type: Action.RegisterDroppable,
      element: {
        id: id2,
        key,
        disabled,
        node: nodeRef,
        rect,
        data: dataRef
      }
    });
    return () => dispatch2({
      type: Action.UnregisterDroppable,
      key,
      id: id2
    });
  }, [id2]);
  react.exports.useEffect(() => {
    dispatch2({
      type: Action.SetDroppableDisabled,
      id: id2,
      key,
      disabled
    });
  }, [disabled]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id2,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function restrictToBoundingRect(transform, rect, boundingRect) {
  const value = __spreadValues({}, transform);
  if (rect.top + transform.y <= boundingRect.top) {
    value.y = boundingRect.top - rect.top;
  } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
    value.y = boundingRect.top + boundingRect.height - rect.bottom;
  }
  if (rect.left + transform.x <= boundingRect.left) {
    value.x = boundingRect.left - rect.left;
  } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
    value.x = boundingRect.left + boundingRect.width - rect.right;
  }
  return value;
}
const restrictToParentElement = ({
  transform,
  activeNodeRect,
  containerNodeRect
}) => {
  if (!activeNodeRect || !containerNodeRect) {
    return transform;
  }
  return restrictToBoundingRect(transform, activeNodeRect, containerNodeRect);
};
const restrictToVerticalAxis = ({
  transform
}) => {
  return __spreadProps(__spreadValues({}, transform), {
    x: 0
  });
};
function arrayMove(array, from5, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from5, 1)[0]);
  return newArray;
}
function getSortedRects(items, layoutRects) {
  return items.reduce((accumulator, id2, index3) => {
    const layoutRect = layoutRects.get(id2);
    if (layoutRect) {
      accumulator[index3] = layoutRect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index3) {
  return index3 !== null && index3 >= 0;
}
const rectSortingStrategy = ({
  layoutRects,
  activeIndex,
  overIndex,
  index: index3
}) => {
  const newRects = arrayMove(layoutRects, overIndex, activeIndex);
  const oldRect = layoutRects[index3];
  const newRect = newRects[index3];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.offsetLeft - oldRect.offsetLeft,
    y: newRect.offsetTop - oldRect.offsetTop,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
const defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
const verticalListSortingStrategy = ({
  activeIndex,
  activeNodeRect: fallbackActiveRect,
  index: index3,
  layoutRects,
  overIndex
}) => {
  var _layoutRects$activeIn;
  const activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index3 === activeIndex) {
    const overIndexRect = layoutRects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return __spreadValues({
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.offsetTop + overIndexRect.height - (activeNodeRect.offsetTop + activeNodeRect.height) : overIndexRect.offsetTop - activeNodeRect.offsetTop
    }, defaultScale$1);
  }
  const itemGap = getItemGap$1(layoutRects, index3, activeIndex);
  if (index3 > activeIndex && index3 <= overIndex) {
    return __spreadValues({
      x: 0,
      y: -activeNodeRect.height - itemGap
    }, defaultScale$1);
  }
  if (index3 < activeIndex && index3 >= overIndex) {
    return __spreadValues({
      x: 0,
      y: activeNodeRect.height + itemGap
    }, defaultScale$1);
  }
  return __spreadValues({
    x: 0,
    y: 0
  }, defaultScale$1);
};
function getItemGap$1(layoutRects, index3, activeIndex) {
  const currentRect = layoutRects[index3];
  const previousRect = layoutRects[index3 - 1];
  const nextRect = layoutRects[index3 + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index3) {
    return previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : 0;
  }
  return nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : 0;
}
const ID_PREFIX = "Sortable";
const Context = /* @__PURE__ */ e$3.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  wasDragging: {
    current: false
  }
});
function SortableContext({
  children,
  id: id2,
  items: userDefinedItems,
  strategy = rectSortingStrategy
}) {
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    recomputeLayouts,
    willRecomputeLayouts
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX, id2);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = react.exports.useMemo(() => userDefinedItems.map((item) => typeof item === "string" ? item : item.id), [userDefinedItems]);
  const isDragging = active != null;
  const wasDragging = react.exports.useRef(false);
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const isSorting = activeIndex !== -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = react.exports.useRef(items);
  const sortedRects = getSortedRects(items, droppableRects);
  const itemsHaveChanged = !isEqual$1(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  useIsomorphicLayoutEffect$3(() => {
    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {
      recomputeLayouts();
    }
  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);
  react.exports.useEffect(() => {
    previousItemsRef.current = items;
  }, [items]);
  react.exports.useEffect(() => {
    const timeoutId = setTimeout(() => {
      wasDragging.current = isDragging;
    }, 100);
    return () => clearTimeout(timeoutId);
  }, [isDragging]);
  const contextValue = react.exports.useMemo(() => ({
    activeIndex,
    containerId,
    disableTransforms,
    items,
    overIndex,
    useDragOverlay,
    sortedRects,
    strategy,
    wasDragging
  }), [activeIndex, containerId, disableTransforms, items, overIndex, sortedRects, useDragOverlay, strategy, wasDragging]);
  return /* @__PURE__ */ jsx(Context.Provider, {
    value: contextValue,
    children
  });
}
function isEqual$1(arr1, arr2) {
  return arr1.join() === arr2.join();
}
const defaultNewIndexGetter = ({
  id: id2,
  items,
  activeIndex,
  overIndex
}) => arrayMove(items, activeIndex, overIndex).indexOf(id2);
const defaultAnimateLayoutChanges = ({
  containerId,
  isSorting,
  wasDragging,
  index: index3,
  items,
  newIndex,
  previousItems,
  previousContainerId,
  transition
}) => {
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index3 === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index3 && containerId === previousContainerId;
};
const defaultTransition = {
  duration: 200,
  easing: "ease"
};
const transitionProperty = "transform";
const disabledTransition = /* @__PURE__ */ CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
const defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform({
  disabled,
  index: index3,
  node: node5,
  rect
}) {
  const [derivedTransform, setDerivedtransform] = react.exports.useState(null);
  const previousIndex = react.exports.useRef(index3);
  useIsomorphicLayoutEffect$3(() => {
    if (!disabled && index3 !== previousIndex.current && node5.current) {
      const initial = rect.current;
      if (initial) {
        const current = getBoundingClientRect$1(node5.current);
        const delta = {
          x: initial.offsetLeft - current.offsetLeft,
          y: initial.offsetTop - current.offsetTop,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index3 !== previousIndex.current) {
      previousIndex.current = index3;
    }
  }, [disabled, index3, node5, rect]);
  react.exports.useEffect(() => {
    if (derivedTransform) {
      requestAnimationFrame(() => {
        setDerivedtransform(null);
      });
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable({
  animateLayoutChanges = defaultAnimateLayoutChanges,
  attributes: userDefinedAttributes,
  disabled,
  data: customData,
  getNewIndex = defaultNewIndexGetter,
  id: id2,
  strategy: localStrategy,
  transition = defaultTransition
}) {
  const {
    items,
    containerId,
    activeIndex,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy,
    wasDragging
  } = react.exports.useContext(Context);
  const index3 = items.indexOf(id2);
  const data = react.exports.useMemo(() => __spreadValues({
    sortable: {
      containerId,
      index: index3,
      items
    }
  }, customData), [containerId, customData, index3, items]);
  const {
    rect,
    node: node5,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id: id2,
    data
  });
  const {
    active,
    activeNodeRect,
    activatorEvent,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    transform
  } = useDraggable({
    id: id2,
    data,
    attributes: __spreadValues(__spreadValues({}, defaultAttributes), userDefinedAttributes),
    disabled
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && wasDragging.current && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    layoutRects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index3
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id: id2,
    items,
    activeIndex,
    overIndex
  }) : index3;
  const prevItems = react.exports.useRef(items);
  const itemsHaveChanged = items !== prevItems.current;
  const prevNewIndex = react.exports.useRef(newIndex);
  const previousContainerId = react.exports.useRef(containerId);
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id: id2,
    index: index3,
    items,
    newIndex: prevNewIndex.current,
    previousItems: prevItems.current,
    previousContainerId: previousContainerId.current,
    transition,
    wasDragging: wasDragging.current
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index3,
    node: node5,
    rect
  });
  react.exports.useEffect(() => {
    if (isSorting && prevNewIndex.current !== newIndex) {
      prevNewIndex.current = newIndex;
    }
    if (containerId !== previousContainerId.current) {
      previousContainerId.current = containerId;
    }
    if (items !== prevItems.current) {
      prevItems.current = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  return {
    active,
    attributes,
    activatorEvent,
    rect,
    index: index3,
    isSorting,
    isDragging,
    listeners,
    node: node5,
    overIndex,
    over,
    setNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (derivedTransform || itemsHaveChanged && prevNewIndex.current === index3) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS.Transition.toString(__spreadProps(__spreadValues({}, transition), {
        property: transitionProperty
      }));
    }
    return void 0;
  }
}
const directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
const sortableKeyboardCoordinates = (event, {
  context: {
    active,
    droppableContainers,
    translatedRect,
    scrollableAncestors
  }
}) => {
  if (directions.includes(event.code)) {
    event.preventDefault();
    if (!active || !translatedRect) {
      return;
    }
    const filteredContainers = [];
    droppableContainers.getEnabled().forEach((entry) => {
      if (!entry || (entry == null ? void 0 : entry.disabled)) {
        return;
      }
      const node5 = entry == null ? void 0 : entry.node.current;
      if (!node5) {
        return;
      }
      const rect = getViewRect(node5);
      const container = __spreadProps(__spreadValues({}, entry), {
        rect: {
          current: rect
        }
      });
      switch (event.code) {
        case KeyboardCode.Down:
          if (translatedRect.top + translatedRect.height <= rect.top) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Up:
          if (translatedRect.top >= rect.top + rect.height) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Left:
          if (translatedRect.left >= rect.left + rect.width) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Right:
          if (translatedRect.left + translatedRect.width <= rect.left) {
            filteredContainers.push(container);
          }
          break;
      }
    });
    const closestId = closestCorners({
      active,
      collisionRect: translatedRect,
      droppableContainers: filteredContainers
    });
    if (closestId) {
      var _droppableContainers$;
      const newNode = (_droppableContainers$ = droppableContainers.get(closestId)) == null ? void 0 : _droppableContainers$.node.current;
      if (newNode) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index3) => scrollableAncestors[index3] !== element);
        const newRect = getViewRect(newNode);
        const offset3 = hasDifferentScrollAncestors ? {
          x: 0,
          y: 0
        } : {
          x: translatedRect.width - newRect.width,
          y: translatedRect.height - newRect.height
        };
        const newCoordinates = {
          x: newRect.left - offset3.x,
          y: newRect.top - offset3.y
        };
        return newCoordinates;
      }
    }
  }
  return void 0;
};
function Button$7(_e2) {
  var _f = _e2, {
    children,
    icon: IconElement,
    size = "default",
    secondary = false,
    outline = false
  } = _f, props = __objRest(_f, [
    "children",
    "icon",
    "size",
    "secondary",
    "outline"
  ]);
  return /* @__PURE__ */ jsxs(BaseButton$1, __spreadProps(__spreadValues({
    css: [secondary && Secondary, size === "small" && Small, outline && Outline, "", ""]
  }, props), {
    children: [IconElement && /* @__PURE__ */ jsx(IconElement, {
      size: 20
    }), children]
  }));
}
const BaseButton$1 = createStyled("button", {
  target: "e19gho0r0"
})({
  name: "hpo54p",
  styles: "outline:none;display:flex;align-items:center;gap:0.5em;font-weight:700;background-color:var(--ve-primary);border:none;color:#fff;align-self:flex-end;font-size:0.9rem;height:48px;padding:0 1em;line-height:1.25rem;cursor:pointer;border-radius:4px;transition:background-color 0.3s;&:hover, &:focus{background-color:var(--ve-primary-hover);}"
});
const Secondary = {
  backgroundColor: "transparent",
  color: "var(--ve-primary)",
  "&:hover, &:focus": {
    backgroundColor: "var(--ve-primary-light)"
  }
};
const Small = {
  height: 40
};
const Outline = {
  border: "solid 1px var(--ve-primary)",
  background: "transparent",
  color: "var(--ve-primary)",
  "&:hover, &:focus": {
    backgroundColor: "var(--ve-primary)",
    color: "#FFF"
  }
};
const Input$2 = createStyled("input", {
  target: "e1iq43q60"
})({
  name: "164ykbl",
  styles: "color:var(--ve-color);background:transparent;padding:.5rem .75em;line-height:1.25rem;border-radius:.2rem;display:block;width:100%;border:1px solid var(--ve-field-border);box-shadow:var(--ve-field-shadow);&:focus{border-color:var(--ve-primary);outline:0;box-shadow:0 0 0 0.25rem rgb(23 113 230 / 25%);}"
});
const UnstyledButton = createStyled("button", {
  target: "e1bfqdcd0"
})({
  name: "ctsem8",
  styles: "background-color:transparent;border:none;padding:0;margin:0;color:inherit"
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node5) {
  if (node5 == null) {
    return window;
  }
  if (node5.toString() !== "[object Window]") {
    var ownerDocument = node5.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node5;
}
function isElement$1(node5) {
  var OwnElement = getWindow(node5).Element;
  return node5 instanceof OwnElement || node5 instanceof Element;
}
function isHTMLElement(node5) {
  var OwnElement = getWindow(node5).HTMLElement;
  return node5 instanceof OwnElement || node5 instanceof HTMLElement;
}
function isShadowRoot(node5) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node5).ShadowRoot;
  return node5 instanceof OwnElement || node5 instanceof ShadowRoot;
}
function applyStyles(_ref2) {
  var state = _ref2.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX2 = 1;
  var scaleY2 = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX2 = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY2 = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX2,
    height: rect.height / scaleY2,
    top: rect.top / scaleY2,
    right: rect.right / scaleX2,
    bottom: rect.bottom / scaleY2,
    left: rect.left / scaleX2,
    x: rect.left / scaleX2,
    y: rect.top / scaleY2
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child3) {
  var rootNode = child3.getRootNode && child3.getRootNode();
  if (parent.contains(child3)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child3;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min3, value, max3) {
  return max$1(min3, min$1(value, max3));
}
function withinMaxClamp(min3, value, max3) {
  var v2 = within(min3, value, max3);
  return v2 > max3 ? max3 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref2) {
  var _state$modifiersData$;
  var state = _ref2.state, name = _ref2.name, options = _ref2.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min3, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref2) {
  var x2 = _ref2.x, y2 = _ref2.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed2 = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref2) {
  var state = _ref2.state, instance = _ref2.instance, options = _ref2.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node5) {
  var win = getWindow(node5);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node5) {
  if (["html", "body", "#document"].indexOf(getNodeName(node5)) >= 0) {
    return node5.ownerDocument.body;
  }
  if (isHTMLElement(node5) && isScrollParent(node5)) {
    return node5;
  }
  return getScrollParent(getParentNode(node5));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref2) {
  var reference2 = _ref2.reference, element = _ref2.element, placement = _ref2.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply2 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply2;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref2 = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref2[0], distance = _ref2[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min3 = offset3 + overflow[mainSide];
    var max3 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min3, tetherMin) : min3, offset3, tether ? max$1(max3, tetherMax) : max3);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node5) {
  if (node5 === getWindow(node5) || !isHTMLElement(node5)) {
    return getWindowScroll(node5);
  } else {
    return getHTMLElementScroll(node5);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX2 = round(rect.width) / element.offsetWidth || 1;
  var scaleY2 = round(rect.height) / element.offsetHeight || 1;
  return scaleX2 !== 1 || scaleY2 !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed2) {
  if (isFixed2 === void 0) {
    isFixed2 = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map14 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result2 = [];
  modifiers2.forEach(function(modifier) {
    map14.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map14.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result2.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result2;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$2(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve6) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve6(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
          if (state.reset === true) {
            state.reset = false;
            index3 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index3], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$2(function() {
        return new Promise(function(resolve6) {
          instance.forceUpdate();
          resolve6(state);
        });
      }),
      destroy: function destroy4() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index3, defaultValue2) {
  if (Array.isArray(value)) {
    var v2 = value[index3];
    return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index3] : defaultValue2 : v2;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce$1(fn3, ms) {
  if (ms === 0) {
    return fn3;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn3(arg);
    }, ms);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index3) {
    return arr.indexOf(item) === index3;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el2) {
    if (el2) {
      el2.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el2) {
    if (el2) {
      el2.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref2) {
    var popperRect = _ref2.popperRect, popperState = _ref2.popperState, props = _ref2.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child3) {
  var target = child3;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser$2 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser$2 ? !!window.msCrypto : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue2 = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue2;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e2) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent$2(content2, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content2, "");
    content2.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content2, props.content);
    } else {
      content2.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node5) {
      return node5.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node5) {
      return node5.classList.contains(ARROW_CLASS) || node5.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node5) {
      return node5.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content2 = div();
  content2.className = CONTENT_CLASS;
  content2.setAttribute("data-state", "hidden");
  setContent$2(content2, instance.props);
  popper2.appendChild(box);
  box.appendChild(content2);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content3 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent$2(content3, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter$1 = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id2 = idCounter$1++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id: id2,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    clearDelayTimeouts,
    setProps: setProps2,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy: destroy4
  };
  if (!props.render) {
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id3 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node5) {
      var currentValue = node5.getAttribute(attr);
      if (instance.state.isVisible) {
        node5.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
      } else {
        var nextValue = currentValue && currentValue.replace(id3, "").trim();
        if (nextValue) {
          node5.setAttribute(attr, nextValue);
        } else {
          node5.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node5) {
      if (instance.props.interactive) {
        node5.setAttribute("aria-expanded", instance.state.isVisible && node5 === getCurrentTarget() ? "true" : "false");
      } else {
        node5.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el2) {
      return actualContains(el2, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on2(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node5) {
      node5.addEventListener(eventType, handler, options);
      listeners.push({
        node: node5,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref2) {
      var node5 = _ref2.node, eventType = _ref2.eventType, handler = _ref2.handler, options = _ref2.options;
      node5.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset3
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node5 = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node5.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node5]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps2(partialProps) {
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node5) {
        node5.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content2) {
    instance.setProps({
      content: content2
    });
  }
  function show() {
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content2 = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content2], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content2 = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content2], duration);
        setVisibilityState([box, content2], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i2) {
      return i2 !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy4() {
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
function preserveRef(ref, node5) {
  if (ref) {
    if (typeof ref === "function") {
      ref(node5);
    }
    if ({}.hasOwnProperty.call(ref, "current")) {
      ref.current = node5;
    }
  }
}
function ssrSafeCreateDiv() {
  return isBrowser$1 && document.createElement("div");
}
function toDataAttributes(attrs) {
  var dataAttrs = {
    "data-placement": attrs.placement
  };
  if (attrs.referenceHidden) {
    dataAttrs["data-reference-hidden"] = "";
  }
  if (attrs.escaped) {
    dataAttrs["data-escaped"] = "";
  }
  return dataAttrs;
}
function deepEqual(x2, y2) {
  if (x2 === y2) {
    return true;
  } else if (typeof x2 === "object" && x2 != null && typeof y2 === "object" && y2 != null) {
    if (Object.keys(x2).length !== Object.keys(y2).length) {
      return false;
    }
    for (var prop in x2) {
      if (y2.hasOwnProperty(prop)) {
        if (!deepEqual(x2[prop], y2[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function uniqueByShape(arr) {
  var output = [];
  arr.forEach(function(item) {
    if (!output.find(function(outputItem) {
      return deepEqual(item, outputItem);
    })) {
      output.push(item);
    }
  });
  return output;
}
function deepPreserveProps(instanceProps, componentProps) {
  var _instanceProps$popper, _componentProps$poppe;
  return Object.assign({}, componentProps, {
    popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
      modifiers: uniqueByShape([].concat(((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || [], ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || []))
    })
  });
}
var useIsomorphicLayoutEffect$2 = isBrowser$1 ? react.exports.useLayoutEffect : react.exports.useEffect;
function useMutableBox(initialValue) {
  var ref = react.exports.useRef();
  if (!ref.current) {
    ref.current = typeof initialValue === "function" ? initialValue() : initialValue;
  }
  return ref.current;
}
function updateClassName(box, action, classNames) {
  classNames.split(/\s+/).forEach(function(name) {
    if (name) {
      box.classList[action](name);
    }
  });
}
var classNamePlugin = {
  name: "className",
  defaultValue: "",
  fn: function fn2(instance) {
    var box = instance.popper.firstElementChild;
    var isDefaultRenderFn = function isDefaultRenderFn2() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    };
    function add3() {
      if (instance.props.className && !isDefaultRenderFn()) {
        return;
      }
      updateClassName(box, "add", instance.props.className);
    }
    function remove2() {
      if (isDefaultRenderFn()) {
        updateClassName(box, "remove", instance.props.className);
      }
    }
    return {
      onCreate: add3,
      onBeforeUpdate: remove2,
      onAfterUpdate: add3
    };
  }
};
function TippyGenerator(tippy2) {
  function Tippy2(_ref2) {
    var children = _ref2.children, content2 = _ref2.content, visible = _ref2.visible, singleton = _ref2.singleton, render2 = _ref2.render, reference2 = _ref2.reference, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, _ref$ignoreAttributes = _ref2.ignoreAttributes, ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes;
    _ref2.__source;
    _ref2.__self;
    var restOfNativeProps = _objectWithoutPropertiesLoose$1(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
    var isControlledMode = visible !== void 0;
    var isSingletonMode = singleton !== void 0;
    var _useState = react.exports.useState(false), mounted = _useState[0], setMounted = _useState[1];
    var _useState2 = react.exports.useState({}), attrs = _useState2[0], setAttrs = _useState2[1];
    var _useState3 = react.exports.useState(), singletonContent = _useState3[0], setSingletonContent = _useState3[1];
    var mutableBox = useMutableBox(function() {
      return {
        container: ssrSafeCreateDiv(),
        renders: 1
      };
    });
    var props = Object.assign({
      ignoreAttributes
    }, restOfNativeProps, {
      content: mutableBox.container
    });
    if (isControlledMode) {
      props.trigger = "manual";
      props.hideOnClick = false;
    }
    if (isSingletonMode) {
      disabled = true;
    }
    var computedProps = props;
    var plugins = props.plugins || [];
    if (render2) {
      computedProps = Object.assign({}, props, {
        plugins: isSingletonMode && singleton.data != null ? [].concat(plugins, [{
          fn: function fn3() {
            return {
              onTrigger: function onTrigger2(instance, event) {
                var node5 = singleton.data.children.find(function(_ref22) {
                  var instance2 = _ref22.instance;
                  return instance2.reference === event.currentTarget;
                });
                instance.state.$$activeSingletonInstance = node5.instance;
                setSingletonContent(node5.content);
              }
            };
          }
        }]) : plugins,
        render: function render3() {
          return {
            popper: mutableBox.container
          };
        }
      });
    }
    var deps = [reference2].concat(children ? [children.type] : []);
    useIsomorphicLayoutEffect$2(function() {
      var element = reference2;
      if (reference2 && reference2.hasOwnProperty("current")) {
        element = reference2.current;
      }
      var instance = tippy2(element || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
        plugins: [classNamePlugin].concat(props.plugins || [])
      }));
      mutableBox.instance = instance;
      if (disabled) {
        instance.disable();
      }
      if (visible) {
        instance.show();
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content: content2,
          props: computedProps,
          setSingletonContent
        });
      }
      setMounted(true);
      return function() {
        instance.destroy();
        singleton == null ? void 0 : singleton.cleanup(instance);
      };
    }, deps);
    useIsomorphicLayoutEffect$2(function() {
      var _instance$popperInsta;
      if (mutableBox.renders === 1) {
        mutableBox.renders++;
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps(deepPreserveProps(instance.props, computedProps));
      (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.forceUpdate();
      if (disabled) {
        instance.disable();
      } else {
        instance.enable();
      }
      if (isControlledMode) {
        if (visible) {
          instance.show();
        } else {
          instance.hide();
        }
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content: content2,
          props: computedProps,
          setSingletonContent
        });
      }
    });
    useIsomorphicLayoutEffect$2(function() {
      var _instance$props$poppe;
      if (!render2) {
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps({
        popperOptions: Object.assign({}, instance.props.popperOptions, {
          modifiers: [].concat((((_instance$props$poppe = instance.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || []).filter(function(_ref3) {
            var name = _ref3.name;
            return name !== "$$tippyReact";
          }), [{
            name: "$$tippyReact",
            enabled: true,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn: function fn3(_ref4) {
              var _state$modifiersData;
              var state = _ref4.state;
              var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;
              if (attrs.placement !== state.placement || attrs.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {
                setAttrs({
                  placement: state.placement,
                  referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,
                  escaped: hideData == null ? void 0 : hideData.hasPopperEscaped
                });
              }
              state.attributes.popper = {};
            }
          }])
        })
      });
    }, [attrs.placement, attrs.referenceHidden, attrs.escaped].concat(deps));
    return /* @__PURE__ */ jsxs(Fragment$1, {
      children: [children ? /* @__PURE__ */ react.exports.cloneElement(children, {
        ref: function ref(node5) {
          mutableBox.ref = node5;
          preserveRef(children.ref, node5);
        }
      }) : null, mounted && /* @__PURE__ */ reactDom.exports.createPortal(render2 ? render2(toDataAttributes(attrs), singletonContent, mutableBox.instance) : content2, mutableBox.container)]
    });
  }
  return Tippy2;
}
var forwardRef = function(Tippy2, defaultProps2) {
  return /* @__PURE__ */ react.exports.forwardRef(function TippyWrapper(_ref2, _ref22) {
    var children = _ref2.children, props = _objectWithoutPropertiesLoose$1(_ref2, ["children"]);
    return /* @__PURE__ */ jsx(Tippy2, __spreadProps(__spreadValues({}, Object.assign({}, defaultProps2, props)), {
      children: children ? /* @__PURE__ */ react.exports.cloneElement(children, {
        ref: function ref(node5) {
          preserveRef(_ref22, node5);
          preserveRef(children.ref, node5);
        }
      }) : null
    }));
  });
};
var index = /* @__PURE__ */ forwardRef(/* @__PURE__ */ TippyGenerator(tippy));
var Tippy = index;
function Tooltip$1({
  content: content2,
  children,
  visible,
  trigger
}) {
  const tippyProps = {};
  if (trigger === "click") {
    tippyProps.trigger = trigger;
    tippyProps.hideOnClick = true;
    tippyProps.interactive = true;
  }
  return /* @__PURE__ */ jsx(StyledTippy, __spreadProps(__spreadValues({
    content: content2,
    visible
  }, tippyProps), {
    children
  }));
}
const StyledTippy = /* @__PURE__ */ createStyled(Tippy, {
  target: "e1qucim10"
})({
  name: "t3ueh3",
  styles: 'background-color:#202227;color:#FFF;padding:.2em .5em;position:relative;border-radius:4px;font-size:.75em;line-height:1.4;box-shadow:rgba(0, 0, 0, 0.1) 0 10px 15px -3px, rgba(0, 0, 0, 0.05) 0 4px 6px -2px;outline:0;transition-property:transform, visibility, opacity;&[data-animation=fade][data-state=hidden]{transform:translateY(-5px);opacity:0;}&[data-placement^=top] > .tippy-arrow{bottom:0;}& .tippy-arrow{width:16px;height:16px;color:#202227;}&[data-placement^=top] > .tippy-arrow::before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top;}& .tippy-arrow::before{content:"";position:absolute;border-color:transparent;border-style:solid;}&[data-placement^=bottom] > .tippy-arrow::before{top:-19px;left:0;border-width:8px 8px 0;border-top-color:initial;transform:rotate(180deg);transform-origin:center top;}'
});
function ButtonIcon(_g) {
  var _h = _g, {
    danger,
    success,
    rotate,
    title
  } = _h, props = __objRest(_h, [
    "danger",
    "success",
    "rotate",
    "title"
  ]);
  const style2 = rotate ? {
    transform: `rotate(${rotate}deg)`
  } : void 0;
  const button = /* @__PURE__ */ jsx(BaseButton, __spreadProps(__spreadValues({}, props), {
    "aria-label": title,
    css: [danger && Danger, success && Success, "", ""],
    style: style2
  }));
  if (title) {
    return /* @__PURE__ */ jsx(Tooltip$1, {
      content: title,
      trigger: "focus",
      children: button
    });
  }
  return button;
}
const BaseButton = createStyled("button", {
  target: "e5qgoxu0"
})({
  name: "1dnnu7",
  styles: "flex:none;width:40px;height:40px;border-radius:40px;display:flex;align-items:center;justify-content:center;background-color:transparent;transition:background-color 0.3s, transform 0.3s;border:none;outline:none;cursor:pointer;color:var(--ve-color-light);background:var(--ve-background);&:hover, &:focus{background-color:var(--ve-hover);color:var(--ve-color);}"
});
const Danger = {
  color: "var(--ve-danger)",
  "&:hover, &:focus": {
    color: "var(--ve-danger)",
    backgroundColor: "var(--ve-danger-light)"
  }
};
const Success = {
  color: "#059669",
  "&:hover, &:focus": {
    color: "#059669",
    backgroundColor: "rgba(110, 231, 183, .2)"
  }
};
const DragHandle = createStyled("div", {
  target: "epzckle0"
})({
  name: "2ozjl7",
  styles: "width:10px;position:absolute;top:.5rem;left:3px;bottom:.5rem;cursor:move;background:radial-gradient(rgba(0,0,0,0.1), rgba(0,0,0,0.1) 30%, rgba(0,0,0,0) 31%, rgba(0,0,0,0.0)) left top / 5px 5px repeat"
});
const Label$1 = createStyled("label", {
  target: "e1d8sdpa0"
})({
  name: "2tu0gr",
  styles: "display:block;margin-bottom:.5em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis"
});
function Field$1(_i) {
  var _j = _i, {
    children,
    label,
    help,
    type = "text",
    options,
    tooltip,
    icon
  } = _j, props = __objRest(_j, [
    "children",
    "label",
    "help",
    "type",
    "options",
    "tooltip",
    "icon"
  ]);
  if (!children) {
    if (options) {
      children = /* @__PURE__ */ jsx(Select$1, __spreadProps(__spreadValues({}, props), {
        children: options.map((option, key) => {
          return /* @__PURE__ */ jsx("option", {
            value: option.value,
            children: option.label
          }, key);
        })
      }));
    } else if (["text", "number"].includes(type)) {
      children = /* @__PURE__ */ jsx(Input$2, __spreadValues({
        type
      }, props));
    } else if (type === "textarea") {
      children = /* @__PURE__ */ jsx(Input$2, __spreadValues({
        as: "textarea"
      }, props));
    } else {
      throw new Error("Cannot render this type of field : " + type);
    }
  }
  if (tooltip) {
    children = /* @__PURE__ */ jsx(Tooltip$1, {
      content: tooltip,
      children
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    children: [label && /* @__PURE__ */ jsx(Label$1, {
      htmlFor: props.id,
      children: label
    }), /* @__PURE__ */ jsxs(Wrapper$f, {
      children: [children, icon && /* @__PURE__ */ jsx(Icon, {
        children: icon
      })]
    }), help && /* @__PURE__ */ jsx(HelpMessage, {
      children: help
    })]
  });
}
const Select$1 = Input$2.withComponent("select", {
  target: "ensu7kp3"
});
const HelpMessage = createStyled("div", {
  target: "ensu7kp2"
})({
  name: "1vp9oxk",
  styles: "font-style:italic;margin-top:.5em;font-size:.8em"
});
const Wrapper$f = createStyled("div", {
  target: "ensu7kp1"
})({
  name: "bjn8wh",
  styles: "position:relative"
});
const Icon = createStyled("div", {
  target: "ensu7kp0"
})({
  name: "w3nkm3",
  styles: "display:flex;align-items:center;justify-content:center;bottom:0;color:var(--ve-field-border);cursor:pointer;height:100%;position:absolute;right:0;top:0;width:40px"
});
function composeRefs(...o2) {
  return (e2) => o2.forEach((o3) => function(o4, e3) {
    typeof o4 == "function" ? o4(e3) : o4 != null && (o4.current = e3);
  }(o3, e2));
}
function useComposedRefs(...e2) {
  return react.exports.useCallback(composeRefs(...e2), e2);
}
const Slot = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { children: a2 } = _a, s2 = __objRest(_a, ["children"]);
  return react.exports.Children.toArray(a2).some(l$4) ? /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, react.exports.Children.map(a2, (e3) => l$4(e3) ? /* @__PURE__ */ react.exports.createElement(n$3, _extends({}, s2, { ref: o2 }), e3.props.children) : e3)) : /* @__PURE__ */ react.exports.createElement(n$3, _extends({}, s2, { ref: o2 }), a2);
});
Slot.displayName = "Slot";
const n$3 = /* @__PURE__ */ react.exports.forwardRef((r2, n2) => {
  const _a = r2, { children: l2 } = _a, a2 = __objRest(_a, ["children"]);
  return react.exports.isValidElement(l2) ? /* @__PURE__ */ react.exports.cloneElement(l2, __spreadProps(__spreadValues({}, o$5(a2, l2.props)), { ref: composeRefs(n2, l2.ref) })) : react.exports.Children.count(l2) > 1 ? react.exports.Children.only(null) : null;
});
n$3.displayName = "SlotClone";
const Slottable = ({ children: e2 }) => /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, e2);
function l$4(e2) {
  return react.exports.isValidElement(e2) && e2.type === Slottable;
}
function o$5(e2, t2) {
  const r2 = __spreadValues({}, t2);
  for (const n2 in t2) {
    const l2 = e2[n2], o2 = t2[n2];
    /^on[A-Z]/.test(n2) ? r2[n2] = (...e3) => {
      o2 == null || o2(...e3), l2 == null || l2(...e3);
    } : n2 === "style" ? r2[n2] = __spreadValues(__spreadValues({}, l2), o2) : n2 === "className" && (r2[n2] = [l2, o2].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, e2), r2);
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (parentNode2 === void 0) {
    parentNode2 = getDefaultParent(originalTarget);
  }
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node5) {
      if (elementsToKeep.has(node5)) {
        deep(node5);
      } else {
        var attr = node5.getAttribute("aria-hidden");
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node5) || 0) + 1;
        var markerValue = (markerCounter.get(node5) || 0) + 1;
        counterMap.set(node5, counterValue);
        markerCounter.set(node5, markerValue);
        hiddenNodes.push(node5);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node5, true);
        }
        if (markerValue === 1) {
          node5.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node5.setAttribute("aria-hidden", "true");
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node5) {
      var counterValue = counterMap.get(node5) - 1;
      var markerValue = markerCounter.get(node5) - 1;
      counterMap.set(node5, counterValue);
      markerCounter.set(node5, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node5)) {
          node5.removeAttribute("aria-hidden");
        }
        uncontrolledNodes.delete(node5);
      }
      if (!markerValue) {
        node5.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return react.exports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = react.exports.useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue2) {
  return useCallbackRef$1(defaultValue2, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
var nothing$1 = function() {
  return;
};
var RemoveScroll = react.exports.forwardRef(function(props, parentRef) {
  var ref = react.exports.useRef(null);
  var _a = react.exports.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([
    ref,
    parentRef
  ]);
  var containerProps = __assign({}, rest, callbacks);
  return react.exports.createElement(react.exports.Fragment, null, enabled && react.exports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }), forwardProps ? react.exports.cloneElement(react.exports.Children.only(children), __assign({}, containerProps, { ref: containerRef })) : react.exports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles) {
    react.exports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, []);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles;
    useStyle(styles);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$2 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [
    parse$2(left2),
    parse$2(top2),
    parse$2(right2)
  ];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left2 = _a.left, top2 = _a.top, right2 = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  ." + noScrollbarsClassName + " {\n   overflow: hidden " + important + ";\n   padding-right: " + gap + "px " + important + ";\n  }\n  body {\n    overflow: hidden " + important + ";\n    " + [
    allowRelative && "position: relative " + important + ";",
    gapMode === "margin" && "\n    padding-left: " + left2 + "px;\n    padding-top: " + top2 + "px;\n    padding-right: " + right2 + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ",
    gapMode === "padding" && "padding-right: " + gap + "px " + important + ";"
  ].filter(Boolean).join("") + "\n  }\n  \n  ." + zeroRightClassName + " {\n    right: " + gap + "px " + important + ";\n  }\n  \n  ." + fullWidthClassName + " {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  ." + zeroRightClassName + " ." + zeroRightClassName + " {\n    right: 0 " + important + ";\n  }\n  \n  ." + fullWidthClassName + " ." + fullWidthClassName + " {\n    margin-right: 0 " + important + ";\n  }\n  \n  body {\n    " + removedBarSizeVariable + ": " + gap + "px;\n  }\n";
};
var RemoveScrollBar = function(props) {
  var _a = react.exports.useState(getGapWidth(props.gapMode)), gap = _a[0], setGap = _a[1];
  react.exports.useEffect(function() {
    setGap(getGapWidth(props.gapMode));
  }, [props.gapMode]);
  var noRelative = props.noRelative, noImportant = props.noImportant, _b = props.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  return react.exports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var elementCouldBeVScrolled = function(node5) {
  var styles = window.getComputedStyle(node5);
  return styles.overflowY !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node5) {
  var styles = window.getComputedStyle(node5);
  if (node5.type === "range") {
    return true;
  }
  return styles.overflowX !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node5) {
  var current = node5;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), s2 = _a[1], d2 = _a[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function(axis, node5) {
  return axis === "v" ? elementCouldBeVScrolled(node5) : elementCouldBeHScrolled(node5);
};
var getScrollVariables = function(axis, node5) {
  return axis === "v" ? getVScrollVariables(node5) : getHScrollVariables(node5);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err2) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-" + id2 + " {pointer-events: none;}\n  .allow-interactivity-" + id2 + " {pointer-events: all;}\n";
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = react.exports.useRef([]);
  var touchStartRef = react.exports.useRef([0, 0]);
  var activeAxis = react.exports.useRef();
  var id2 = react.exports.useState(idCounter++)[0];
  var Style2 = react.exports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = react.exports.useRef(props);
  react.exports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  react.exports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-" + id2);
      var allow_1 = [
        props.lockRef.current
      ].concat((props.shards || []).map(extractRef)).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-" + id2);
      });
      return function() {
        document.body.classList.remove("block-interactivity-" + id2);
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-" + id2);
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = react.exports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = react.exports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node5) {
        return node5.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = react.exports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = react.exports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = react.exports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = react.exports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  react.exports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return react.exports.createElement(react.exports.Fragment, null, inert ? react.exports.createElement(Style2, { styles: generateStyle(id2) }) : null, removeScrollBar ? react.exports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null);
}
var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = react.exports.forwardRef(function(props, ref) {
  return react.exports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var o$4 = ReactRemoveScroll;
let t$4 = 0;
function useFocusGuards() {
  react.exports.useEffect(() => {
    var e2, n2;
    const r2 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e2 = r2[0]) !== null && e2 !== void 0 ? e2 : o$3()), document.body.insertAdjacentElement("beforeend", (n2 = r2[1]) !== null && n2 !== void 0 ? n2 : o$3()), t$4++, () => {
      t$4 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e3) => e3.remove()), t$4--;
    };
  }, []);
}
function o$3() {
  const e2 = document.createElement("span");
  return e2.setAttribute("data-radix-focus-guard", ""), e2.tabIndex = 0, e2.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e2;
}
const Primitive = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce((o2, i2) => __spreadProps(__spreadValues({}, o2), { [i2]: /* @__PURE__ */ react.exports.forwardRef((o3, m2) => {
  const _a = o3, { asChild: a2 } = _a, s2 = __objRest(_a, ["asChild"]), n2 = a2 ? Slot : i2;
  return react.exports.useEffect(() => {
    window[Symbol.for("radix-ui")] = true;
  }, []), /* @__PURE__ */ react.exports.createElement(n2, _extends({}, s2, { ref: m2 }));
}) }), {});
const useLayoutEffect = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? react.exports.useLayoutEffect : () => {
};
const Presence = (u2) => {
  const { present: o2, children: i2 } = u2, s2 = function(n2) {
    const [u3, o3] = react.exports.useState(), i3 = react.exports.useRef({}), s3 = react.exports.useRef(n2), c3 = react.exports.useRef("none"), a3 = n2 ? "mounted" : "unmounted", [d2, m2] = function(e2, n3) {
      return react.exports.useReducer((e3, t2) => {
        const r2 = n3[e3][t2];
        return r2 != null ? r2 : e3;
      }, e2);
    }(a3, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } });
    return react.exports.useEffect(() => {
      const e2 = r$4(i3.current);
      c3.current = d2 === "mounted" ? e2 : "none";
    }, [d2]), useLayoutEffect(() => {
      const e2 = i3.current, t2 = s3.current;
      if (t2 !== n2) {
        const u4 = c3.current, o4 = r$4(e2);
        if (n2)
          m2("MOUNT");
        else if (o4 === "none" || (e2 == null ? void 0 : e2.display) === "none")
          m2("UNMOUNT");
        else {
          const e3 = u4 !== o4;
          m2(t2 && e3 ? "ANIMATION_OUT" : "UNMOUNT");
        }
        s3.current = n2;
      }
    }, [n2, m2]), useLayoutEffect(() => {
      if (u3) {
        const e2 = (e3) => {
          const n4 = r$4(i3.current).includes(e3.animationName);
          e3.target === u3 && n4 && m2("ANIMATION_END");
        }, n3 = (e3) => {
          e3.target === u3 && (c3.current = r$4(i3.current));
        };
        return u3.addEventListener("animationstart", n3), u3.addEventListener("animationcancel", e2), u3.addEventListener("animationend", e2), () => {
          u3.removeEventListener("animationstart", n3), u3.removeEventListener("animationcancel", e2), u3.removeEventListener("animationend", e2);
        };
      }
      m2("ANIMATION_END");
    }, [u3, m2]), { isPresent: ["mounted", "unmountSuspended"].includes(d2), ref: react.exports.useCallback((e2) => {
      e2 && (i3.current = getComputedStyle(e2)), o3(e2);
    }, []) };
  }(o2), c2 = typeof i2 == "function" ? i2({ present: s2.isPresent }) : react.exports.Children.only(i2), a2 = useComposedRefs(s2.ref, c2.ref);
  return typeof i2 == "function" || s2.isPresent ? /* @__PURE__ */ react.exports.cloneElement(c2, { ref: a2 }) : null;
};
function r$4(e2) {
  return (e2 == null ? void 0 : e2.animationName) || "none";
}
Presence.displayName = "Presence";
const Portal = /* @__PURE__ */ react.exports.forwardRef((a2, i2) => {
  var n2, d2;
  const _a = a2, { containerRef: s2, style: u2 } = _a, c2 = __objRest(_a, ["containerRef", "style"]), m2 = (n2 = s2 == null ? void 0 : s2.current) !== null && n2 !== void 0 ? n2 : globalThis === null || globalThis === void 0 || (d2 = globalThis.document) === null || d2 === void 0 ? void 0 : d2.body, [, f2] = react.exports.useState({});
  return useLayoutEffect(() => {
    f2({});
  }, []), m2 ? /* @__PURE__ */ te.createPortal(/* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ "data-radix-portal": "" }, c2, { ref: i2, style: m2 === document.body ? __spreadValues({ position: "absolute", top: 0, left: 0, zIndex: 2147483647 }, u2) : void 0 })), m2) : null;
});
function useCallbackRef(r2) {
  const t2 = react.exports.useRef(r2);
  return react.exports.useEffect(() => {
    t2.current = r2;
  }), react.exports.useMemo(() => (...e2) => {
    var r3;
    return (r3 = t2.current) === null || r3 === void 0 ? void 0 : r3.call(t2, ...e2);
  }, []);
}
const c$5 = { bubbles: false, cancelable: true };
const FocusScope = /* @__PURE__ */ react.exports.forwardRef((i2, f2) => {
  const _a = i2, { loop: l2 = false, trapped: m2 = false, onMountAutoFocus: p2, onUnmountAutoFocus: v2 } = _a, E2 = __objRest(_a, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]), [F2, S2] = react.exports.useState(null), b2 = useCallbackRef(p2), T2 = useCallbackRef(v2), y2 = react.exports.useRef(null), L2 = useComposedRefs(f2, (e2) => S2(e2)), h2 = react.exports.useRef({ paused: false, pause() {
    this.paused = true;
  }, resume() {
    this.paused = false;
  } }).current;
  react.exports.useEffect(() => {
    if (m2) {
      let e2 = function(e3) {
        if (h2.paused || !F2)
          return;
        const t3 = e3.target;
        F2.contains(t3) ? y2.current = t3 : a$2(y2.current, { select: true });
      }, t2 = function(e3) {
        !h2.paused && F2 && (F2.contains(e3.relatedTarget) || a$2(y2.current, { select: true }));
      };
      return document.addEventListener("focusin", e2), document.addEventListener("focusout", t2), () => {
        document.removeEventListener("focusin", e2), document.removeEventListener("focusout", t2);
      };
    }
  }, [m2, F2, h2.paused]), react.exports.useEffect(() => {
    if (F2) {
      d$6.add(h2);
      const t2 = document.activeElement;
      if (!F2.contains(t2)) {
        const n2 = new Event("focusScope.autoFocusOnMount", c$5);
        F2.addEventListener("focusScope.autoFocusOnMount", b2), F2.dispatchEvent(n2), n2.defaultPrevented || (!function(e3, { select: t3 = false } = {}) {
          const n3 = document.activeElement;
          for (const o2 of e3)
            if (a$2(o2, { select: t3 }), document.activeElement !== n3)
              return;
        }((e2 = r$3(F2), e2.filter((e3) => e3.tagName !== "A")), { select: true }), document.activeElement === t2 && a$2(F2));
      }
      return () => {
        F2.removeEventListener("focusScope.autoFocusOnMount", b2), setTimeout(() => {
          const e3 = new Event("focusScope.autoFocusOnUnmount", c$5);
          F2.addEventListener("focusScope.autoFocusOnUnmount", T2), F2.dispatchEvent(e3), e3.defaultPrevented || a$2(t2 != null ? t2 : document.body, { select: true }), F2.removeEventListener("focusScope.autoFocusOnUnmount", T2), d$6.remove(h2);
        }, 0);
      };
    }
    var e2;
  }, [F2, b2, T2, h2]);
  const N2 = react.exports.useCallback((e2) => {
    if (!l2 && !m2)
      return;
    if (h2.paused)
      return;
    const t2 = e2.key === "Tab" && !e2.altKey && !e2.ctrlKey && !e2.metaKey, n2 = document.activeElement;
    if (t2 && n2) {
      const t3 = e2.currentTarget, [o2, u2] = function(e3) {
        const t4 = r$3(e3), n3 = s$1(t4, e3), o3 = s$1(t4.reverse(), e3);
        return [n3, o3];
      }(t3);
      o2 && u2 ? e2.shiftKey || n2 !== u2 ? e2.shiftKey && n2 === o2 && (e2.preventDefault(), l2 && a$2(u2, { select: true })) : (e2.preventDefault(), l2 && a$2(o2, { select: true })) : n2 === t3 && e2.preventDefault();
    }
  }, [l2, m2, h2.paused]);
  return react.exports.createElement(Primitive.div, _extends({ tabIndex: -1 }, E2, { ref: L2, onKeyDown: N2 }));
});
function r$3(e2) {
  const t2 = [], n2 = document.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, { acceptNode: (e3) => {
    const t3 = e3.tagName === "INPUT" && e3.type === "hidden";
    return e3.disabled || e3.hidden || t3 ? NodeFilter.FILTER_SKIP : e3.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n2.nextNode(); )
    t2.push(n2.currentNode);
  return t2;
}
function s$1(e2, t2) {
  for (const n2 of e2)
    if (!i$2(n2, { upTo: t2 }))
      return n2;
}
function i$2(e2, { upTo: t2 }) {
  if (getComputedStyle(e2).visibility === "hidden")
    return true;
  for (; e2; ) {
    if (t2 !== void 0 && e2 === t2)
      return false;
    if (getComputedStyle(e2).display === "none")
      return true;
    e2 = e2.parentElement;
  }
  return false;
}
function a$2(e2, { select: t2 = false } = {}) {
  if (e2 && e2.focus) {
    const n2 = document.activeElement;
    e2.focus({ preventScroll: true }), e2 !== n2 && function(e3) {
      return e3 instanceof HTMLInputElement && "select" in e3;
    }(e2) && t2 && e2.select();
  }
}
const d$6 = function() {
  let e2 = [];
  return { add(t2) {
    const n2 = e2[0];
    t2 !== n2 && (n2 == null || n2.pause()), e2 = f$6(e2, t2), e2.unshift(t2);
  }, remove(t2) {
    var n2;
    e2 = f$6(e2, t2), (n2 = e2[0]) === null || n2 === void 0 || n2.resume();
  } };
}();
function f$6(e2, t2) {
  const n2 = [...e2], o2 = n2.indexOf(t2);
  return o2 !== -1 && n2.splice(o2, 1), n2;
}
function useEscapeKeydown(n2) {
  const o2 = useCallbackRef(n2);
  react.exports.useEffect(() => {
    const e2 = (e3) => {
      e3.key === "Escape" && o2(e3);
    };
    return document.addEventListener("keydown", e2), () => document.removeEventListener("keydown", e2);
  }, [o2]);
}
let n$2, o$2 = 0;
function useBodyPointerEvents({ disabled: r2 }) {
  const i2 = react.exports.useRef(false);
  useLayoutEffect(() => {
    if (r2) {
      let e2 = function() {
        o$2--, o$2 === 0 && (document.body.style.pointerEvents = n$2);
      }, t2 = function(e3) {
        i2.current = e3.pointerType !== "mouse";
      };
      return o$2 === 0 && (n$2 = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", o$2++, document.addEventListener("pointerup", t2), () => {
        i2.current ? document.addEventListener("click", e2, { once: true }) : e2(), document.removeEventListener("pointerup", t2);
      };
    }
  }, [r2]);
}
function composeEventHandlers(e2, n2, { checkForDefaultPrevented: t2 = true } = {}) {
  return function(r2) {
    if (e2 == null || e2(r2), t2 === false || !r2.defaultPrevented)
      return n2 == null ? void 0 : n2(r2);
  };
}
const u$4 = /* @__PURE__ */ react.exports.createContext({ layers: /* @__PURE__ */ new Set(), layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(), branches: /* @__PURE__ */ new Set() });
const DismissableLayer = /* @__PURE__ */ react.exports.forwardRef((l2, m2) => {
  const _a = l2, { disableOutsidePointerEvents: f2 = false, onEscapeKeyDown: p2, onPointerDownOutside: v2, onFocusOutside: b2, onInteractOutside: E2, onDismiss: y2 } = _a, w2 = __objRest(_a, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]), h2 = react.exports.useContext(u$4), [D2, x2] = react.exports.useState(null), [, C2] = react.exports.useState({}), L2 = useComposedRefs(m2, (e2) => x2(e2)), P2 = Array.from(h2.layers), [O2] = [...h2.layersWithOutsidePointerEventsDisabled].slice(-1), g2 = P2.indexOf(O2), B2 = D2 ? P2.indexOf(D2) : -1, R2 = h2.layersWithOutsidePointerEventsDisabled.size > 0, F2 = B2 >= g2, S2 = function(e2) {
    const n2 = useCallbackRef(e2), r2 = react.exports.useRef(false);
    return react.exports.useEffect(() => {
      const e3 = (e4) => {
        if (e4.target && !r2.current) {
          d$5("dismissableLayer.pointerDownOutside", n2, { originalEvent: e4 });
        }
        r2.current = false;
      }, t2 = window.setTimeout(() => {
        document.addEventListener("pointerdown", e3);
      }, 0);
      return () => {
        window.clearTimeout(t2), document.removeEventListener("pointerdown", e3);
      };
    }, [n2]), { onPointerDownCapture: () => r2.current = true };
  }((e2) => {
    const t2 = e2.target, n2 = [...h2.branches].some((e3) => e3.contains(t2));
    F2 && !n2 && (v2 == null || v2(e2), E2 == null || E2(e2), e2.defaultPrevented || y2 == null || y2());
  }), W2 = function(e2) {
    const n2 = useCallbackRef(e2), r2 = react.exports.useRef(false);
    return react.exports.useEffect(() => {
      const e3 = (e4) => {
        if (e4.target && !r2.current) {
          d$5("dismissableLayer.focusOutside", n2, { originalEvent: e4 });
        }
      };
      return document.addEventListener("focusin", e3), () => document.removeEventListener("focusin", e3);
    }, [n2]), { onFocusCapture: () => r2.current = true, onBlurCapture: () => r2.current = false };
  }((e2) => {
    const t2 = e2.target;
    [...h2.branches].some((e3) => e3.contains(t2)) || (b2 == null || b2(e2), E2 == null || E2(e2), e2.defaultPrevented || y2 == null || y2());
  });
  return useEscapeKeydown((e2) => {
    B2 === h2.layers.size - 1 && (p2 == null || p2(e2), e2.defaultPrevented || y2 == null || y2());
  }), useBodyPointerEvents({ disabled: f2 }), react.exports.useEffect(() => {
    D2 && (f2 && h2.layersWithOutsidePointerEventsDisabled.add(D2), h2.layers.add(D2), c$4());
  }, [D2, f2, h2]), react.exports.useEffect(() => () => {
    D2 && (h2.layers.delete(D2), h2.layersWithOutsidePointerEventsDisabled.delete(D2), c$4());
  }, [D2, h2]), react.exports.useEffect(() => {
    const e2 = () => C2({});
    return document.addEventListener("dismissableLayer.update", e2), () => document.removeEventListener("dismissableLayer.update", e2);
  }, []), /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({}, w2, { ref: L2, style: __spreadValues({ pointerEvents: R2 ? F2 ? "auto" : "none" : void 0 }, l2.style), onFocusCapture: composeEventHandlers(l2.onFocusCapture, W2.onFocusCapture), onBlurCapture: composeEventHandlers(l2.onBlurCapture, W2.onBlurCapture), onPointerDownCapture: composeEventHandlers(l2.onPointerDownCapture, S2.onPointerDownCapture) }));
});
function c$4() {
  const e2 = new Event("dismissableLayer.update");
  document.dispatchEvent(e2);
}
function d$5(e2, t2, n2) {
  const r2 = n2.originalEvent.target, s2 = new CustomEvent(e2, { bubbles: false, cancelable: true, detail: n2 });
  return t2 && r2.addEventListener(e2, t2, { once: true }), !r2.dispatchEvent(s2);
}
function useControllableState({ prop: o2, defaultProp: r2, onChange: n2 = () => {
} }) {
  const [a2, u2] = function({ defaultProp: o3, onChange: r3 }) {
    const n3 = react.exports.useState(o3), [a3] = n3, u3 = react.exports.useRef(a3), c3 = useCallbackRef(r3);
    return react.exports.useEffect(() => {
      u3.current !== a3 && (c3(a3), u3.current = a3);
    }, [a3, u3, c3]), n3;
  }({ defaultProp: r2, onChange: n2 }), c2 = o2 !== void 0, f2 = c2 ? o2 : a2, l2 = useCallbackRef(n2);
  return [f2, react.exports.useCallback((e2) => {
    if (c2) {
      const t2 = e2, r3 = typeof e2 == "function" ? t2(o2) : e2;
      r3 !== o2 && l2(r3);
    } else
      u2(e2);
  }, [c2, o2, u2, l2])];
}
const r$2 = React["useId".toString()] || (() => {
});
let n$1 = 0;
function useId(o2) {
  const [u2, i2] = react.exports.useState(r$2());
  return useLayoutEffect(() => {
    o2 || i2((t2) => t2 != null ? t2 : String(n$1++));
  }, [o2]), o2 || (u2 ? `radix-${u2}` : "");
}
function createContextScope(n2, o2 = []) {
  let r2 = [];
  const c2 = () => {
    const t2 = r2.map((t3) => /* @__PURE__ */ react.exports.createContext(t3));
    return function(o3) {
      const r3 = (o3 == null ? void 0 : o3[n2]) || t2;
      return react.exports.useMemo(() => ({ [`__scope${n2}`]: __spreadProps(__spreadValues({}, o3), { [n2]: r3 }) }), [o3, r3]);
    };
  };
  return c2.scopeName = n2, [function(t2, o3) {
    const c3 = /* @__PURE__ */ react.exports.createContext(o3), u2 = r2.length;
    function s2(t3) {
      const _a = t3, { scope: o4, children: r3 } = _a, s3 = __objRest(_a, ["scope", "children"]), i2 = (o4 == null ? void 0 : o4[n2][u2]) || c3, a2 = react.exports.useMemo(() => s3, Object.values(s3));
      return react.exports.createElement(i2.Provider, { value: a2 }, r3);
    }
    return r2 = [...r2, o3], s2.displayName = t2 + "Provider", [s2, function(r3, s3) {
      const i2 = (s3 == null ? void 0 : s3[n2][u2]) || c3, a2 = react.exports.useContext(i2);
      if (a2)
        return a2;
      if (o3 !== void 0)
        return o3;
      throw new Error(`\`${r3}\` must be used within \`${t2}\``);
    }];
  }, t$3(c2, ...o2)];
}
function t$3(...t2) {
  const n2 = t2[0];
  if (t2.length === 1)
    return n2;
  const o2 = () => {
    const o3 = t2.map((e2) => ({ useScope: e2(), scopeName: e2.scopeName }));
    return function(t3) {
      const r2 = o3.reduce((e2, { useScope: n3, scopeName: o4 }) => __spreadValues(__spreadValues({}, e2), n3(t3)[`__scope${o4}`]), {});
      return react.exports.useMemo(() => ({ [`__scope${n2.scopeName}`]: r2 }), [r2]);
    };
  };
  return o2.scopeName = n2.scopeName, o2;
}
const [x$3, C$2] = createContextScope("Dialog");
const [v$3, E$3] = x$3("Dialog");
const Dialog = (e2) => {
  const { __scopeDialog: o2, children: t2, open: r2, defaultOpen: n2, onOpenChange: a2, modal: i2 = true, allowPinchZoom: l2 } = e2, c2 = react.exports.useRef(null), p2 = react.exports.useRef(null), [d2 = false, f2] = useControllableState({ prop: r2, defaultProp: n2, onChange: a2 });
  return react.exports.createElement(v$3, { scope: o2, triggerRef: c2, contentRef: p2, contentId: useId(), titleId: useId(), descriptionId: useId(), open: d2, onOpenChange: f2, onOpenToggle: react.exports.useCallback(() => f2((e3) => !e3), [f2]), modal: i2, allowPinchZoom: l2 }, t2);
};
const DialogOverlay = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { forceMount: t2 } = _a, r2 = __objRest(_a, ["forceMount"]), n2 = E$3("DialogOverlay", e2.__scopeDialog);
  return n2.modal ? /* @__PURE__ */ react.exports.createElement(Presence, { present: t2 || n2.open }, /* @__PURE__ */ react.exports.createElement(R$4, _extends({}, r2, { ref: o2 }))) : null;
});
const R$4 = /* @__PURE__ */ react.exports.forwardRef((o2, r2) => {
  const _a = o2, { __scopeDialog: a2 } = _a, i2 = __objRest(_a, ["__scopeDialog"]), l2 = E$3("DialogOverlay", a2);
  return react.exports.createElement(o$4, { as: Slot, allowPinchZoom: l2.allowPinchZoom, shards: [l2.contentRef] }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ "data-state": b$4(l2.open) }, i2, { ref: r2, style: __spreadValues({ pointerEvents: "auto" }, i2.style) })));
});
const DialogContent = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { forceMount: t2 } = _a, r2 = __objRest(_a, ["forceMount"]), n2 = E$3("DialogContent", e2.__scopeDialog);
  return react.exports.createElement(Presence, { present: t2 || n2.open }, n2.modal ? /* @__PURE__ */ react.exports.createElement(_$2, _extends({}, r2, { ref: o2 })) : /* @__PURE__ */ react.exports.createElement(O$2, _extends({}, r2, { ref: o2 })));
});
const _$2 = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const r2 = E$3("DialogContent", e2.__scopeDialog), n2 = react.exports.useRef(null), a2 = useComposedRefs(t2, r2.contentRef, n2);
  return react.exports.useEffect(() => {
    const e3 = n2.current;
    if (e3)
      return hideOthers(e3);
  }, []), /* @__PURE__ */ react.exports.createElement(h$4, _extends({}, e2, { ref: a2, trapFocus: r2.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(e2.onCloseAutoFocus, (e3) => {
    var o2;
    e3.preventDefault(), (o2 = r2.triggerRef.current) === null || o2 === void 0 || o2.focus();
  }), onPointerDownOutside: composeEventHandlers(e2.onPointerDownOutside, (e3) => {
    const o2 = e3.detail.originalEvent, t3 = o2.button === 0 && o2.ctrlKey === true;
    (o2.button === 2 || t3) && e3.preventDefault();
  }), onFocusOutside: composeEventHandlers(e2.onFocusOutside, (e3) => e3.preventDefault()) }));
}), O$2 = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const t2 = E$3("DialogContent", e2.__scopeDialog), r2 = react.exports.useRef(false);
  return react.exports.createElement(h$4, _extends({}, e2, { ref: o2, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o3) => {
    var n2, a2;
    ((n2 = e2.onCloseAutoFocus) === null || n2 === void 0 || n2.call(e2, o3), o3.defaultPrevented) || (r2.current || (a2 = t2.triggerRef.current) === null || a2 === void 0 || a2.focus(), o3.preventDefault());
    r2.current = false;
  }, onInteractOutside: (o3) => {
    var n2, a2;
    (n2 = e2.onInteractOutside) === null || n2 === void 0 || n2.call(e2, o3), o3.defaultPrevented || (r2.current = true);
    const i2 = o3.target;
    ((a2 = t2.triggerRef.current) === null || a2 === void 0 ? void 0 : a2.contains(i2)) && o3.preventDefault();
  } }));
}), h$4 = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopeDialog: t2, trapFocus: n2, onOpenAutoFocus: a2, onCloseAutoFocus: i2 } = _a, s2 = __objRest(_a, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]), u2 = E$3("DialogContent", t2), p2 = react.exports.useRef(null), d2 = useComposedRefs(o2, p2);
  return useFocusGuards(), /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FocusScope, { asChild: true, loop: true, trapped: n2, onMountAutoFocus: a2, onUnmountAutoFocus: i2 }, /* @__PURE__ */ react.exports.createElement(DismissableLayer, _extends({ role: "dialog", id: u2.contentId, "aria-describedby": u2.descriptionId, "aria-labelledby": u2.titleId, "data-state": b$4(u2.open) }, s2, { ref: d2, onDismiss: () => u2.onOpenChange(false) }))), false);
});
const DialogTitle = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopeDialog: t2 } = _a, r2 = __objRest(_a, ["__scopeDialog"]), a2 = E$3("DialogTitle", t2);
  return react.exports.createElement(Primitive.h2, _extends({ id: a2.titleId }, r2, { ref: o2 }));
});
function b$4(e2) {
  return e2 ? "open" : "closed";
}
const Root$6 = Dialog;
const Overlay = DialogOverlay;
const Content$2 = DialogContent;
const Title$2 = DialogTitle;
function prevent(callback) {
  if (!callback) {
    return;
  }
  return (e2) => {
    e2.preventDefault();
    callback(e2);
  };
}
function preventPropagation(callback) {
  if (!callback) {
    return;
  }
  return (e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    callback(e2);
  };
}
function Modal({
  children,
  title,
  visible,
  onVisibilityChange
}) {
  return /* @__PURE__ */ jsxs(Root$6, {
    open: visible,
    onOpenChange: onVisibilityChange,
    children: [/* @__PURE__ */ jsx(ModalOverlay, {}), /* @__PURE__ */ jsxs(ModalContent, {
      children: [/* @__PURE__ */ jsx(ModalTitle, {
        children: title
      }), /* @__PURE__ */ jsx("div", {
        children
      }), /* @__PURE__ */ jsx(ModalClose, {
        onClick: prevent(() => onVisibilityChange(false)),
        children: /* @__PURE__ */ jsx(IconCross, {
          size: 16
        })
      })]
    })]
  });
}
const FadeIn = keyframes({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});
const ContentIn = keyframes({
  from: {
    opacity: 0,
    transform: "translateY(-48%) scale(.96)"
  },
  to: {
    opacity: 1,
    transform: "translateY(-50%) scale(1)"
  }
});
const ModalOverlay = /* @__PURE__ */ createStyled(Overlay, {
  target: "e63k5ye3"
})({
  position: "fixed",
  inset: 0,
  zIndex: 50,
  overflow: "auto",
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  animation: `${FadeIn} 300ms cubic-bezier(0.16, 1, 0.3, 1)`
}, "");
const ModalContent = /* @__PURE__ */ createStyled(Content$2, {
  target: "e63k5ye2"
})({
  position: "fixed",
  top: "50%",
  left: "0",
  right: "0",
  zIndex: 51,
  marginLeft: "auto",
  marginRight: "auto",
  width: "calc(100% - 2rem)",
  maxWidth: "1290px",
  borderRadius: "8px",
  backgroundColor: "var(--ve-background)",
  padding: "1.5rem 2rem",
  transform: "translateY(-50%)",
  animation: `${ContentIn} 300ms cubic-bezier(0.16, 1, 0.3, 1)`
}, "");
const ModalTitle = /* @__PURE__ */ createStyled(Title$2, {
  target: "e63k5ye1"
})({
  name: "qrr264",
  styles: "font-size:1.5rem;font-weight:500;margin:0;padding:0"
});
const ModalClose = /* @__PURE__ */ createStyled(ButtonIcon, {
  target: "e63k5ye0"
})({
  name: "yqq9j2",
  styles: "position:absolute;top:1.2rem;right:1.5rem"
});
function createCollection(c2) {
  const n2 = c2 + "CollectionProvider", [l2, i2] = createContextScope(n2), [f2, a2] = l2(n2, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }), u2 = (e2) => {
    const { scope: r2, children: t2 } = e2, c3 = e$3.useRef(null), n3 = e$3.useRef(/* @__PURE__ */ new Map()).current;
    return e$3.createElement(f2, { scope: r2, itemMap: n3, collectionRef: c3 }, t2);
  }, m2 = c2 + "CollectionSlot", s2 = /* @__PURE__ */ e$3.forwardRef((t2, c3) => {
    const { scope: n3, children: l3 } = t2, i3 = a2(m2, n3), f3 = useComposedRefs(c3, i3.collectionRef);
    return e$3.createElement(Slot, { ref: f3 }, l3);
  }), p2 = c2 + "CollectionItemSlot", d2 = "data-radix-collection-item", R2 = /* @__PURE__ */ e$3.forwardRef((t2, c3) => {
    const _a = t2, { scope: n3, children: l3 } = _a, i3 = __objRest(_a, ["scope", "children"]), f3 = e$3.useRef(null), u3 = useComposedRefs(c3, f3), m3 = a2(p2, n3);
    return e$3.useEffect(() => (m3.itemMap.set(f3, __spreadValues({ ref: f3 }, i3)), () => {
      m3.itemMap.delete(f3);
    })), /* @__PURE__ */ e$3.createElement(Slot, { [d2]: "", ref: u3 }, l3);
  });
  return [{ Provider: u2, Slot: s2, ItemSlot: R2 }, function(e2) {
    const r2 = a2(c2 + "CollectionConsumer", e2);
    return e$3.useCallback(() => {
      const e3 = r2.collectionRef.current;
      if (!e3)
        return [];
      const t2 = Array.from(e3.querySelectorAll(`[${d2}]`));
      return Array.from(r2.itemMap.values()).sort((e4, r3) => t2.indexOf(e4.ref.current) - t2.indexOf(r3.ref.current));
    }, [r2.collectionRef, r2.itemMap]);
  }, i2];
}
const f$5 = { bubbles: false, cancelable: true }, [p$4, l$3, m$5] = createCollection("RovingFocusGroup"), [d$4, v$2] = createContextScope("RovingFocusGroup", [m$5]);
const [g$3, F$1] = d$4("RovingFocusGroup");
const RovingFocusGroup = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => /* @__PURE__ */ react.exports.createElement(p$4.Provider, { scope: e2.__scopeRovingFocusGroup }, /* @__PURE__ */ react.exports.createElement(p$4.Slot, { scope: e2.__scopeRovingFocusGroup }, /* @__PURE__ */ react.exports.createElement(w$3, _extends({}, e2, { ref: o2 })))));
const w$3 = /* @__PURE__ */ react.exports.forwardRef((t2, n2) => {
  const _a = t2, { __scopeRovingFocusGroup: c2, orientation: p2, dir: m2 = "ltr", loop: d2 = false, currentTabStopId: v2, defaultCurrentTabStopId: F2, onCurrentTabStopIdChange: w2, onEntryFocus: b2 } = _a, x2 = __objRest(_a, ["__scopeRovingFocusGroup", "orientation", "dir", "loop", "currentTabStopId", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus"]), E2 = react.exports.useRef(null), I2 = useComposedRefs(n2, E2), [G2 = null, h2] = useControllableState({ prop: v2, defaultProp: F2, onChange: w2 }), [T2, A2] = react.exports.useState(false), y2 = useCallbackRef(b2), D2 = l$3(c2), S2 = react.exports.useRef(false);
  return react.exports.useEffect(() => {
    const e2 = E2.current;
    if (e2)
      return e2.addEventListener("rovingFocusGroup.onEntryFocus", y2), () => e2.removeEventListener("rovingFocusGroup.onEntryFocus", y2);
  }, [y2]), /* @__PURE__ */ react.exports.createElement(g$3, { scope: c2, orientation: p2, dir: m2, loop: d2, currentTabStopId: G2, onItemFocus: react.exports.useCallback((e2) => h2(e2), [h2]), onItemShiftTab: react.exports.useCallback(() => A2(true), []) }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ tabIndex: T2 ? -1 : 0, "data-orientation": p2 }, x2, { ref: I2, style: __spreadValues({ outline: "none" }, t2.style), onMouseDown: composeEventHandlers(t2.onMouseDown, () => {
    S2.current = true;
  }), onFocus: composeEventHandlers(t2.onFocus, (e2) => {
    const o2 = !S2.current;
    if (e2.target === e2.currentTarget && o2 && !T2) {
      const o3 = new Event("rovingFocusGroup.onEntryFocus", f$5);
      if (e2.currentTarget.dispatchEvent(o3), !o3.defaultPrevented) {
        const e3 = D2().filter((e4) => e4.focusable);
        R$3([e3.find((e4) => e4.active), e3.find((e4) => e4.id === G2), ...e3].filter(Boolean).map((e4) => e4.ref.current));
      }
    }
    S2.current = false;
  }), onBlur: composeEventHandlers(t2.onBlur, () => A2(false)) })));
});
const RovingFocusGroupItem = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopeRovingFocusGroup: n2, focusable: i2 = true, active: c2 = false } = _a, f2 = __objRest(_a, ["__scopeRovingFocusGroup", "focusable", "active"]), m2 = useId(), d2 = F$1("RovingFocusGroupItem", n2), v2 = d2.currentTabStopId === m2, g2 = l$3(n2);
  return react.exports.createElement(p$4.ItemSlot, { scope: n2, id: m2, focusable: i2, active: c2 }, /* @__PURE__ */ react.exports.createElement(Primitive.span, _extends({ tabIndex: v2 ? 0 : -1, "data-orientation": d2.orientation }, f2, { ref: o2, onMouseDown: composeEventHandlers(e2.onMouseDown, (e3) => {
    i2 ? d2.onItemFocus(m2) : e3.preventDefault();
  }), onFocus: composeEventHandlers(e2.onFocus, () => d2.onItemFocus(m2)), onKeyDown: composeEventHandlers(e2.onKeyDown, (e3) => {
    if (e3.key === "Tab" && e3.shiftKey)
      return void d2.onItemShiftTab();
    if (e3.target !== e3.currentTarget)
      return;
    const o3 = function(e4, o4, r3) {
      const t3 = function(e5, o5) {
        return o5 !== "rtl" ? e5 : e5 === "ArrowLeft" ? "ArrowRight" : e5 === "ArrowRight" ? "ArrowLeft" : e5;
      }(e4.key, r3);
      return o4 === "vertical" && ["ArrowLeft", "ArrowRight"].includes(t3) || o4 === "horizontal" && ["ArrowUp", "ArrowDown"].includes(t3) ? void 0 : b$3[t3];
    }(e3, d2.orientation, d2.dir);
    if (o3 !== void 0) {
      e3.preventDefault();
      let n3 = g2().filter((e4) => e4.focusable).map((e4) => e4.ref.current);
      if (o3 === "last")
        n3.reverse();
      else if (o3 === "prev" || o3 === "next") {
        o3 === "prev" && n3.reverse();
        const i3 = n3.indexOf(e3.currentTarget);
        n3 = d2.loop ? (t2 = i3 + 1, (r2 = n3).map((e4, o4) => r2[(t2 + o4) % r2.length])) : n3.slice(i3 + 1);
      }
      setTimeout(() => R$3(n3));
    }
    var r2, t2;
  }) })));
});
const b$3 = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" };
function R$3(e2) {
  const o2 = document.activeElement;
  for (const r2 of e2) {
    if (r2 === o2)
      return;
    if (r2.focus(), document.activeElement !== o2)
      return;
  }
}
const Root$5 = RovingFocusGroup;
const Item$2 = RovingFocusGroupItem;
const [d$3, l$2] = createContextScope("Tabs", [v$2]);
const u$3 = v$2(), [b$2, p$3] = d$3("Tabs");
const Tabs$2 = /* @__PURE__ */ react.exports.forwardRef((t2, o2) => {
  const _a = t2, { __scopeTabs: n2, value: i2, onValueChange: d2, defaultValue: l2, orientation: u2 = "horizontal", dir: p2 = "ltr", activationMode: m2 = "automatic" } = _a, f2 = __objRest(_a, ["__scopeTabs", "value", "onValueChange", "defaultValue", "orientation", "dir", "activationMode"]), [v2, T2] = useControllableState({ prop: i2, onChange: d2, defaultProp: l2 });
  return react.exports.createElement(b$2, { scope: n2, baseId: useId(), value: v2, onValueChange: T2, orientation: u2, dir: p2, activationMode: m2 }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ "data-orientation": u2 }, f2, { ref: o2 })));
});
const TabsList$1 = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopeTabs: r2, loop: n2 = true } = _a, i2 = __objRest(_a, ["__scopeTabs", "loop"]), d2 = p$3("TabsList", r2), l2 = u$3(r2);
  return react.exports.createElement(Root$5, _extends({ asChild: true }, l2, { orientation: d2.orientation, dir: d2.dir, loop: n2 }), /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ role: "tablist", "aria-orientation": d2.orientation, dir: d2.dir }, i2, { ref: o2 })));
});
const TabsTrigger = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopeTabs: r2, value: n2, disabled: d2 = false } = _a, l2 = __objRest(_a, ["__scopeTabs", "value", "disabled"]), b2 = p$3("TabsTrigger", r2), v2 = u$3(r2), T2 = m$4(b2.baseId, n2), x2 = f$4(b2.baseId, n2), g2 = n2 === b2.value;
  return react.exports.createElement(Item$2, _extends({ asChild: true }, v2, { focusable: !d2, active: g2 }), /* @__PURE__ */ react.exports.createElement(Primitive.button, _extends({ type: "button", role: "tab", "aria-selected": g2, "aria-controls": x2, "data-state": g2 ? "active" : "inactive", "data-disabled": d2 ? "" : void 0, disabled: d2, id: T2 }, l2, { ref: o2, onMouseDown: composeEventHandlers(e2.onMouseDown, (e3) => {
    d2 || e3.button !== 0 || e3.ctrlKey !== false ? e3.preventDefault() : b2.onValueChange(n2);
  }), onKeyDown: composeEventHandlers(e2.onKeyDown, (e3) => {
    [" ", "Enter"].includes(e3.key) && b2.onValueChange(n2);
  }), onFocus: composeEventHandlers(e2.onFocus, () => {
    const e3 = b2.activationMode !== "manual";
    g2 || d2 || !e3 || b2.onValueChange(n2);
  }) })));
});
const TabsContent = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const _a = e2, { __scopeTabs: o2, value: r2, children: n2 } = _a, i2 = __objRest(_a, ["__scopeTabs", "value", "children"]), d2 = p$3("TabsContent", o2), l2 = m$4(d2.baseId, r2), u2 = f$4(d2.baseId, r2), b2 = r2 === d2.value;
  return react.exports.createElement(Primitive.div, _extends({ "data-state": b2 ? "active" : "inactive", "data-orientation": d2.orientation, role: "tabpanel", "aria-labelledby": l2, hidden: !b2, id: u2, tabIndex: 0 }, i2, { ref: t2 }), b2 && n2);
});
function m$4(e2, t2) {
  return `${e2}-trigger-${t2}`;
}
function f$4(e2, t2) {
  return `${e2}-content-${t2}`;
}
const TabsList = /* @__PURE__ */ createStyled(TabsList$1, {
  target: "e1fie14x1"
})({
  name: "2whhw8",
  styles: "display:flex;gap:.5rem;margin-bottom:1em"
});
const TabButton = /* @__PURE__ */ createStyled(TabsTrigger, {
  target: "e1fie14x0"
})({
  name: "m8boro",
  styles: "background-color:var(--ve-hover);border-radius:56px;padding:.6rem 1rem;border:none;font-weight:500;cursor:pointer;transition:color .3s, background-color .3s"
});
const TabButtonSelected = {
  color: "var(--ve-primary)",
  backgroundColor: "var(--ve-primary-light)"
};
function Tabs$1(_k) {
  var _l = _k, {
    children
  } = _l, props = __objRest(_l, [
    "children"
  ]);
  var _a;
  const childrenArray = e$3.Children.toArray(children);
  const [currentTab, setCurrentTab] = react.exports.useState((_a = childrenArray[0]) == null ? void 0 : _a.props.title);
  return /* @__PURE__ */ jsxs(Tabs$2, {
    value: currentTab,
    onValueChange: setCurrentTab,
    children: [/* @__PURE__ */ jsx(TabsList, __spreadProps(__spreadValues({}, props), {
      children: childrenArray.map((child3) => /* @__PURE__ */ jsx(TabButton, {
        css: [currentTab === child3.props.title && TabButtonSelected, "", ""],
        value: child3.props.title,
        children: child3.props.title
      }, child3.props.title))
    })), childrenArray.map((child3) => /* @__PURE__ */ jsx(TabsContent, {
      value: child3.props.title,
      children: child3
    }, child3.props.title))]
  });
}
function Tab(props) {
  return /* @__PURE__ */ jsx("div", __spreadValues({}, props));
}
Tabs$1.Tab = Tab;
const Flex = react.exports.forwardRef((_m, ref) => {
  var _n = _m, {
    between,
    column: column2
  } = _n, props = __objRest(_n, [
    "between",
    "column"
  ]);
  return /* @__PURE__ */ jsx(Wrapper$e, __spreadProps(__spreadValues({}, props), {
    ref,
    css: [between && Between, column2 && Column, "", ""]
  }));
});
Flex.displayName = "Flex";
const Wrapper$e = createStyled("div", {
  target: "esnp6690"
})("display:flex;align-items:center;justify-content:flex-start;", ({
  gap = 1
}) => ({
  gap: gap + "em",
  gridGap: gap + "em"
}), "");
const Between = {
  justifyContent: "space-between"
};
const Column = {
  display: "grid",
  alignContent: "flex-start",
  gridTemplateColumns: "1fr",
  alignItems: "flex-start"
};
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step2 = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index3 = toRunNextFrame.indexOf(callback);
      if (index3 !== -1)
        toRunNextFrame.splice(index3, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step2.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step2.process(frameData);
      }
    }
  };
  return step2;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step2 = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step2.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frame);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
function useUnmountEffect(callback) {
  return react.exports.useEffect(() => () => callback(), []);
}
function useForceUpdate$1() {
  const isUnmountingRef = react.exports.useRef(false);
  const [forcedRenderCount, setForcedRenderCount] = react.exports.useState(0);
  useUnmountEffect(() => isUnmountingRef.current = true);
  const forceRender = react.exports.useCallback(() => {
    !isUnmountingRef.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = react.exports.useCallback(() => sync.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
function useConstant(init6) {
  const ref = react.exports.useRef(null);
  if (ref.current === null) {
    ref.current = init6();
  }
  return ref.current;
}
const Base = {
  animationDuration: ".7s",
  animationTimingFunction: "cubic-bezier(0.19, 1, 0.22, 1)",
  animateFill: "both"
};
const PresenceChild = ({
  children,
  isPresent,
  onExitComplete,
  in: inKeyframes,
  out: outKeyframes
}) => {
  const presenceChildren = useConstant(newChildrenMap);
  const animationName = isPresent ? inKeyframes : outKeyframes;
  react.exports.useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  return /* @__PURE__ */ jsx(ClassNames, {
    children: ({
      css: css2,
      cx: cx2
    }) => react.exports.cloneElement(children, {
      className: cx2(children.props.className, css2(__spreadProps(__spreadValues({}, Base), {
        animationName: animationName.toString()
      }))),
      onAnimationEnd: isPresent ? null : onExitComplete
    })
  });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const LayoutGroupContext = react.exports.createContext({});
function getChildKey(child3) {
  return child3.key || "";
}
function updateChildLookup(children, allChildren) {
  children.forEach((child3) => {
    const key = getChildKey(child3);
    allChildren.set(key, child3);
  });
}
function onlyElements(children) {
  const filtered = [];
  react.exports.Children.forEach(children, (child3) => {
    if (react.exports.isValidElement(child3))
      filtered.push(child3);
  });
  return filtered;
}
const AnimatePresence = ({
  children,
  in: inKeyframes,
  out: outKeyframes,
  exitBeforeEnter
}) => {
  let [forceRender] = useForceUpdate$1();
  const forceRenderLayoutGroup = react.exports.useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isInitialRender = react.exports.useRef(true);
  const isMounted = react.exports.useRef(true);
  react.exports.useEffect(() => () => {
    isMounted.current = false;
  }, []);
  const filteredChildren = onlyElements(children);
  const presentChildren = react.exports.useRef(filteredChildren);
  const allChildren = react.exports.useRef(/* @__PURE__ */ new Map()).current;
  const exiting = react.exports.useRef(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  if (isInitialRender.current) {
    isInitialRender.current = false;
    return /* @__PURE__ */ jsx(Fragment$1, {
      children: filteredChildren.map((child3) => /* @__PURE__ */ jsx(PresenceChild, {
        isPresent: true,
        in: inKeyframes,
        out: outKeyframes,
        children: child3
      }, getChildKey(child3)))
    });
  }
  let childrenToRender = [...filteredChildren];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i2 = 0; i2 < numPresent; i2++) {
    const key = presentKeys[i2] || "";
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    } else {
      exiting.delete(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child3 = allChildren.get(key);
    if (!child3)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    const onExit = () => {
      allChildren.delete(key);
      exiting.delete(key);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (!isMounted.current) {
          return;
        }
        forceRender();
      }
    };
    childrenToRender.splice(insertionIndex, 0, /* @__PURE__ */ jsx(PresenceChild, {
      isPresent: false,
      onExitComplete: onExit,
      in: inKeyframes,
      out: outKeyframes,
      children: child3
    }, getChildKey(child3)));
  });
  childrenToRender = childrenToRender.map((child3) => {
    const key = child3.key;
    return exiting.has(key) ? child3 : /* @__PURE__ */ jsx(PresenceChild, {
      isPresent: true,
      in: inKeyframes,
      out: outKeyframes,
      children: child3
    }, getChildKey(child3));
  });
  presentChildren.current = childrenToRender;
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: exiting.size ? childrenToRender : childrenToRender.map((child3) => react.exports.cloneElement(child3))
  });
};
function Flash({
  children,
  action,
  onClick,
  duration,
  onHide: onHide2
}) {
  return /* @__PURE__ */ jsx(AnimatePresence, {
    in: FlashIn,
    out: FlashOut,
    children: children && /* @__PURE__ */ jsxs(Wrapper$d, {
      between: true,
      children: [/* @__PURE__ */ jsx("div", {
        children
      }), action && /* @__PURE__ */ jsx(FlashButton, {
        size: "small",
        onClick: prevent(onClick),
        children: action
      }), duration && /* @__PURE__ */ jsx(Progress, {
        onAnimationEnd: preventPropagation(onHide2),
        style: {
          animationDuration: `${duration}s`
        }
      })]
    })
  });
}
const Wrapper$d = /* @__PURE__ */ createStyled(Flex, {
  target: "e1hfei1d2"
})({
  name: "pp3hn",
  styles: "position:fixed;bottom:1rem;right:2rem;color:var(--ve-background);background:var(--ve-dark);z-index:1001;padding:1em;border-radius:4px;width:460px;font-weight:500"
});
const FlashButton = /* @__PURE__ */ createStyled(Button$7, {
  target: "e1hfei1d1"
})({
  name: "w8vgob",
  styles: "border:solid 1px var(--ve-background);background-color:transparent"
});
const ProgressKeyframe = keyframes({
  from: {
    transform: "scaleX(0)"
  },
  to: {
    transform: "scaleX(1)"
  }
});
const Progress = createStyled("div", {
  target: "e1hfei1d0"
})({
  display: "block",
  position: "absolute",
  bottom: "0",
  left: "0",
  width: "100%",
  height: "4px",
  transformOrigin: "0 0",
  backgroundColor: "var(--ve-primary)",
  animation: `${ProgressKeyframe} 1s both linear`
}, "");
const FlashIn = keyframes({
  from: {
    transform: "translateX(3em);",
    opacity: 0
  },
  to: {
    transform: "translateX(0)",
    opacity: 1
  }
});
const FlashOut = keyframes({
  from: {
    transform: "translateX(0)",
    opacity: 1
  },
  to: {
    transform: "translateX(-3em);",
    opacity: 0
  }
});
const Styles = {
  Mosaic: {
    "--ve-transparentColor": "#ffffff",
    backgroundColor: "#d0d0d0",
    backgroundImage: "linear-gradient(45deg, var(--ve-transparentColor) 25%, transparent 25%), linear-gradient(-45deg, var(--ve-transparentColor) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--ve-transparentColor) 75%), linear-gradient(-45deg, transparent 75%, var(--ve-transparentColor) 75%)",
    backgroundSize: "10px 10px",
    backgroundPosition: "0 0, 0 5px, 5px -5px, -5px 0px"
  },
  FocusState: {
    borderColor: "var(--ve-primary)",
    outline: 0,
    boxShadow: "0 0 0 0.25rem rgb(23 113 230 / 25%)"
  }
};
const Card = createStyled("div", {
  target: "enm0imx0"
})("padding:.8em .6em .8em 1.4em;background-color:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 2px 0 rgba(0,0,0,0.05);transition:box-shadow .3s!important;", (props) => props.hoverable ? {
  "&:hover": {
    boxShadow: "var(--ve-shadow-dragging)",
    zIndex: 10
  }
} : {}, "");
const SpinnerKeyframes = keyframes({
  from: {
    transform: "rotate(0deg)"
  },
  to: {
    transform: "rotate(-360deg)"
  }
});
const SpinnerWrapper = createStyled("div", {
  target: "e1tzzy60"
})({
  position: "absolute",
  top: "calc(50% - var(--size) * 0.5)",
  left: "calc(50% - var(--size) * 0.5)",
  width: "var(--size)",
  height: "var(--size)",
  animation: `${SpinnerKeyframes} 1.4s infinite linear`,
  svg: {
    display: "block",
    width: "var(--size)",
    height: "var(--size)"
  }
}, ({
  size = 30
}) => ({
  "--size": `${size}px`
}), "");
function Spinner(props) {
  return /* @__PURE__ */ jsx(SpinnerWrapper, __spreadProps(__spreadValues({}, props), {
    children: /* @__PURE__ */ jsxs("svg", {
      viewBox: "0 0 60 60",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/* @__PURE__ */ jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M30 60C46.5685 60 60 46.5685 60 30C60 13.4315 46.5685 0 30 0C13.4315 0 0 13.4315 0 30C0 46.5685 13.4315 60 30 60ZM30 50C41.0457 50 50 41.0457 50 30C50 18.9543 41.0457 10 30 10C18.9543 10 10 18.9543 10 30C10 41.0457 18.9543 50 30 50Z",
        fill: "url(#paint0_linear_313_15)"
      }), /* @__PURE__ */ jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10 30H0C0 46.5685 13.4315 60 30 60V50C18.9543 50 10 41.0457 10 30Z",
        fill: "currentColor"
      }), /* @__PURE__ */ jsx("defs", {
        children: /* @__PURE__ */ jsxs("linearGradient", {
          id: "paint0_linear_313_15",
          x1: "30",
          y1: "30",
          x2: "17",
          y2: "30",
          gradientUnits: "userSpaceOnUse",
          children: [/* @__PURE__ */ jsx("stop", {
            stopColor: "currentColor",
            stopOpacity: "0"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "0.198062",
            stopColor: "currentColor",
            stopOpacity: "0.217786"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "0.434425",
            stopColor: "currentColor",
            stopOpacity: "0.477687"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "1",
            stopColor: "currentColor"
          })]
        })
      })]
    })
  }));
}
function IconPhone({
  size = 18
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M7 4v16h10V4H7zM6 2h12a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1zm6 15a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"
    })
  });
}
function IconDesktop({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M4 16h16V5H4v11zm9 2v2h4v2H7v-2h4v-2H2.992A.998.998 0 0 1 2 16.993V4.007C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007v12.986c0 .556-.455 1.007-.992 1.007H13z"
    })
  });
}
function IconCheck({
  size = 18
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M13.315 2.716A7.461 7.461 0 102.763 13.268 7.461 7.461 0 0013.315 2.716zM8.039 14.454a6.468 6.468 0 01-6.46-6.46 6.468 6.468 0 016.46-6.462A6.468 6.468 0 0114.5 7.992a6.468 6.468 0 01-6.46 6.461z"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M6.915 9.556L4.62 7.262l-.708.707 3.002 3.002 5.234-5.235-.707-.707-4.527 4.527z"
    })]
  });
}
function IconAlignLeft({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: size,
    height: size,
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M10 6H5v13h5V6zM3 4v17h9V4H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M22 7v2h-7V7h7zM22 11v2h-7v-2h7zM19 15v2h-4v-2h4z"
    })]
  });
}
function IconAlignRight({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 6h-5v13h5V6zm-7-2v17h9V4h-9z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M10 7v2H3V7h7zM10 11v2H3v-2h7zM7 15v2H3v-2h4z"
    })]
  });
}
function IconAlignTop({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("defs", {}), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 5H5v5h14V5zM3 3v9h18V3H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M20 14v2H3v-2h17zM14 18v2H3v-2h11z"
    })]
  });
}
function IconAlignBottom({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 14H5v5h14v-5zM3 12v9h18v-9H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M20 4v2H3V4h17zM14 8v2H3V8h11zM7 12v2H3v-2h4z"
    })]
  });
}
function IconTextLeft({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M3 8V6h8v2zM3 13v-2h18v2zM3 18v-2h14v2z"
    })
  });
}
function IconTextCenter({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M8 8V6h8v2zM3 13v-2h18v2zM5 18v-2h14v2z"
    })
  });
}
function IconTextRight({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M11 8V6h10v2zM3 13v-2h18v2zM6 18v-2h15v2z"
    })
  });
}
function IconCirclePlus({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: [/* @__PURE__ */ jsx("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }), /* @__PURE__ */ jsx("path", {
      d: "M11 11V7h2v4h4v2h-4v4h-2v-4H7v-2h4zm1 11C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z",
      fill: "currentColor"
    })]
  });
}
function IconDown({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M12 13.172l4.95-4.95 1.414 1.414L12 16 5.636 9.636 7.05 8.222z",
      fill: "currentColor"
    })
  });
}
function IconTrash({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-4.586 6l1.768 1.768-1.414 1.414L12 15.414l-1.768 1.768-1.414-1.414L10.586 14l-1.768-1.768 1.414-1.414L12 12.586l1.768-1.768 1.414 1.414L13.414 14zM9 4v2h6V4H9z",
      fill: "currentColor"
    })
  });
}
function IconCross({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsx("path", {
      d: "M6.99999 5.58599L11.95 0.635986L13.364 2.04999L8.41399 6.99999L13.364 11.95L11.95 13.364L6.99999 8.41399L2.04999 13.364L0.635986 11.95L5.58599 6.99999L0.635986 2.04999L2.04999 0.635986L6.99999 5.58599Z",
      fill: "currentColor"
    })
  });
}
function IconSearch({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsx("path", {
      d: "m11.02 10.078 2.856 2.855-.943.943-2.855-2.855A6.002 6.002 0 0 1 .333 6.334c0-3.313 2.688-6 6-6a6.002 6.002 0 0 1 4.688 9.744Zm-1.337-.495a4.665 4.665 0 0 0-3.35-7.917 4.665 4.665 0 0 0-4.666 4.667 4.665 4.665 0 0 0 7.916 3.35l.1-.1Z",
      fill: "currentColor"
    })
  });
}
function IconCode({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M24 12l-5.657 5.657-1.414-1.414L21.172 12l-4.243-4.243 1.414-1.414L24 12zM2.828 12l4.243 4.243-1.414 1.414L0 12l5.657-5.657L7.07 7.757 2.828 12zm6.96 9H7.66l6.552-18h2.128L9.788 21z"
    })
  });
}
function IconFolder({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M3 21a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h7.414l2 2H20a1 1 0 0 1 1 1v3h-2V7h-7.414l-2-2H4v11.998L5.5 11h17l-2.31 9.243a1 1 0 0 1-.97.757H3zm16.938-8H7.062l-1.5 6h12.876l1.5-6z"
    })
  });
}
function IconBack({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsx("path", {
      d: "M4.5 2.5L4.5 20.5L2.5 20.5L2.5 2.5L4.5 2.5ZM10.328 12.5L16.4 18.571L14.986 19.985L6.5 11.5L14.985 3.015L16.4 4.429L10.33 10.5L21.5 10.5L21.5 12.5L10.328 12.5Z",
      fill: "currentColor"
    })
  });
}
function IconSave({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      d: "M7 19v-6h10v6h2V7.828L16.172 5H5v14h2zM4 3h13l4 4v13a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm5 12v4h6v-4H9z",
      fill: "currentColor"
    })
  });
}
function IconCalendar({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M17 3h4a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h4V1h2v2h6V1h2v2zm-2 2H9v2H7V5H4v4h16V5h-3v2h-2V5zm5 6H4v8h16v-8z"
    })
  });
}
function IconPage({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M5 8v12h14V8H5zm0-2h14V4H5v2zm15 16H4a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1zM7 10h4v4H7v-4zm0 6h10v2H7v-2zm6-5h4v2h-4v-2z"
    })
  });
}
function IconBlocs({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M4 4v5h16V4H4ZM3 2a1 1 0 0 0-1 1v7c0 .6.4 1 1 1h18c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1H3ZM4 15v5h16v-5H4Zm-1-2a1 1 0 0 0-1 1v7c0 .6.4 1 1 1h18c.6 0 1-.4 1-1v-7c0-.6-.4-1-1-1H3Z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M5 5h6v1H5V5ZM5 16h6v1H5v-1Z"
    })]
  });
}
function SortableWrapper({
  items,
  children,
  onMove
}) {
  const ids2 = items.map((item) => item._id);
  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  function handleDragEnd(event) {
    const {
      active,
      over
    } = event;
    if (over && active.id !== over.id) {
      onMove(ids2.indexOf(active.id), ids2.indexOf(over.id));
    }
  }
  return /* @__PURE__ */ jsx(DndContext, {
    sensors,
    collisionDetection: closestCenter,
    onDragEnd: handleDragEnd,
    modifiers: [restrictToVerticalAxis, restrictToParentElement],
    children: /* @__PURE__ */ jsx(SortableContext, {
      items: ids2,
      strategy: verticalListSortingStrategy,
      children
    })
  });
}
function Sortable(_o) {
  var _p = _o, {
    item,
    children,
    className
  } = _p, props = __objRest(_p, [
    "item",
    "children",
    "className"
  ]);
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({
    id: item._id
  });
  const style2 = {
    transform: CSS.Translate.toString(transform),
    transition: transition || void 0
  };
  return /* @__PURE__ */ jsxs("div", __spreadProps(__spreadValues(__spreadValues({
    className,
    "data-dragging": isDragging ? true : void 0,
    ref: setNodeRef,
    style: style2
  }, attributes), props), {
    children: [/* @__PURE__ */ jsx(DragHandle, __spreadValues({}, listeners)), children]
  }));
}
function moveItem(items, from5, to) {
  return arrayMove(items, from5, to);
}
function insertItem(items, index3, value) {
  const clone = [...items];
  clone.splice(index3, 0, value);
  return clone;
}
function createStore$1(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace3) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace3 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState3 = () => state;
  const subscribeWithSelector = (listener, selector = getState3, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy4 = () => listeners.clear();
  const api = { setState, getState: getState3, subscribe, destroy: destroy4 };
  state = createState(setState, getState3, api);
  return api;
}
const isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
const useIsomorphicLayoutEffect$1 = isSSR ? react.exports.useEffect : react.exports.useLayoutEffect;
function create(createState) {
  const api = typeof createState === "function" ? createStore$1(createState) : createState;
  const useStore2 = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = react.exports.useReducer((c2) => c2 + 1, 0);
    const state = api.getState();
    const stateRef = react.exports.useRef(state);
    const selectorRef = react.exports.useRef(selector);
    const equalityFnRef = react.exports.useRef(equalityFn);
    const erroredRef = react.exports.useRef(false);
    const currentSliceRef = react.exports.useRef();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect$1(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = react.exports.useRef(state);
    useIsomorphicLayoutEffect$1(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    react.exports.useDebugValue(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore2, api);
  useStore2[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore2, api];
    return {
      next() {
        const done2 = items.length <= 0;
        return { value: items.shift(), done: done2 };
      }
    };
  };
  return useStore2;
}
function keys$1(ks) {
  return Array.isArray(ks) ? ks : ks.split(".");
}
function deepGet(o2, kp, d2 = null) {
  return keys$1(kp).reduce((o22, k2) => o22 && (Array.isArray(o22) ? o22[parseInt(k2)] : o22[k2]) || d2, o2);
}
function deepSet(object, keyPath, value) {
  if (!keyPath) {
    return value;
  }
  return keys$1(keyPath).reduceRight((acc, key, i2, keys2) => {
    const original = deepGet(object, keys2.slice(0, i2));
    if (Array.isArray(original)) {
      return original.map((v2, k2) => {
        if (k2.toString() === key) {
          return acc;
        }
        return v2;
      });
    } else {
      return Object.assign({}, original, {
        [key]: acc
      });
    }
  }, value);
}
function stringifyFields(source) {
  return JSON.stringify(source, (key, value) => {
    if (key === "_id") {
      return void 0;
    }
    return value;
  }, 2);
}
function indexify(object) {
  if (Array.isArray(object)) {
    const prefix2 = Math.round(Date.now() / 1e3);
    object.forEach((v2, k2) => {
      if (typeof v2 === "object") {
        v2._id = prefix2 + k2.toString();
        indexify(v2);
      }
    });
  } else if (typeof object === "object" && object !== null) {
    Object.keys(object).forEach((key) => indexify(object[key]));
  }
  return object;
}
function cast(value, expectedValue) {
  if (typeof expectedValue === "boolean") {
    return !!value;
  }
  if (typeof expectedValue === "string") {
    if (typeof value === "boolean") {
      return "";
    }
    return "" + (value != null ? value : "");
  }
  throw new Error(`Cannot cast ${typeof value} into a ${typeof expectedValue}`);
}
function devtools(fn3, options) {
  return (set2, get3, api) => {
    var _a;
    let didWarnAboutNameDeprecation = false;
    if (typeof options === "string" && !didWarnAboutNameDeprecation) {
      console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead");
      didWarnAboutNameDeprecation = true;
    }
    const devtoolsOptions = options === void 0 ? { name: void 0, anonymousActionType: void 0 } : typeof options === "string" ? { name: options } : options;
    if (typeof ((_a = devtoolsOptions == null ? void 0 : devtoolsOptions.serialize) == null ? void 0 : _a.options) !== "undefined") {
      console.warn("[zustand devtools middleware]: `serialize.options` is deprecated, just use `serialize`");
    }
    let extensionConnector;
    try {
      extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
    } catch {
    }
    if (!extensionConnector) {
      if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production" && typeof window !== "undefined") {
        console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
      }
      return fn3(set2, get3, api);
    }
    let extension = Object.create(extensionConnector.connect(devtoolsOptions));
    let didWarnAboutDevtools = false;
    Object.defineProperty(api, "devtools", {
      get: () => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        return extension;
      },
      set: (value) => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        extension = value;
      }
    });
    let didWarnAboutPrefix = false;
    Object.defineProperty(extension, "prefix", {
      get: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
        return "";
      },
      set: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
      }
    });
    let isRecording = true;
    api.setState = (state, replace3, nameOrAction) => {
      set2(state, replace3);
      if (!isRecording)
        return;
      extension.send(nameOrAction === void 0 ? { type: devtoolsOptions.anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction, get3());
    };
    const setStateFromDevtools = (...a2) => {
      const originalIsRecording = isRecording;
      isRecording = false;
      set2(...a2);
      isRecording = originalIsRecording;
    };
    const initialState = fn3(api.setState, get3, api);
    extension.init(initialState);
    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      let didWarnAboutReservedActionType = false;
      const originalDispatch = api.dispatch;
      api.dispatch = (...a2) => {
        if (a2[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
          didWarnAboutReservedActionType = true;
        }
        originalDispatch(...a2);
      };
    }
    extension.subscribe((message) => {
      var _a2;
      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error("[zustand devtools middleware] Unsupported action format");
            return;
          }
          return parseJsonThen(message.payload, (action) => {
            if (action.type === "__setState") {
              setStateFromDevtools(action.state);
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          });
        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState);
              return extension.init(api.getState());
            case "COMMIT":
              return extension.init(api.getState());
            case "ROLLBACK":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
                extension.init(api.getState());
              });
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
              });
            case "IMPORT_STATE": {
              const { nextLiftedState } = message.payload;
              const lastComputedState = (_a2 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a2.state;
              if (!lastComputedState)
                return;
              setStateFromDevtools(lastComputedState);
              extension.send(null, nextLiftedState);
              return;
            }
            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }
          return;
      }
    });
    return initialState;
  };
}
const parseJsonThen = (stringified, f2) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e2) {
    console.error("[zustand devtools middleware] Could not parse the received json", e2);
  }
  if (parsed !== void 0)
    f2(parsed);
};
const combine = (initialState, create6) => (set2, get3, api) => Object.assign({}, initialState, create6(set2, get3, api));
function uniqId() {
  return `_${Math.random().toString(36).substr(2, 9)}`;
}
function textContent(str) {
  return new DOMParser().parseFromString(str, "text/html").body.textContent;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function createContext() {
  const ZustandContext = react.exports.createContext(void 0);
  const Provider2 = ({
    initialStore,
    createStore: createStore2,
    children
  }) => {
    const storeRef = react.exports.useRef();
    if (!storeRef.current) {
      if (initialStore) {
        console.warn("Provider initialStore is deprecated and will be removed in the next version.");
        if (!createStore2) {
          createStore2 = () => initialStore;
        }
      }
      storeRef.current = createStore2();
    }
    return react.exports.createElement(ZustandContext.Provider, { value: storeRef.current }, children);
  };
  const useStore2 = (selector, equalityFn = Object.is) => {
    const useProviderStore = react.exports.useContext(ZustandContext);
    if (!useProviderStore) {
      throw new Error("Seems like you have not used zustand provider as an ancestor.");
    }
    return useProviderStore(selector, equalityFn);
  };
  const useStoreApi = () => {
    const useProviderStore = react.exports.useContext(ZustandContext);
    if (!useProviderStore) {
      throw new Error("Seems like you have not used zustand provider as an ancestor.");
    }
    return react.exports.useMemo(() => ({
      getState: useProviderStore.getState,
      setState: useProviderStore.setState,
      subscribe: useProviderStore.subscribe,
      destroy: useProviderStore.destroy
    }), [useProviderStore]);
  };
  return {
    Provider: Provider2,
    useStore: useStore2,
    useStoreApi
  };
}
function clamp$1(value, min3, max3) {
  return Math.min(Math.max(value, min3), max3);
}
function fillDefaults(data, fields) {
  let newData = __spreadValues({}, data);
  for (const field of fields) {
    if (field.group) {
      newData = fillDefaults(newData, field.fields);
      continue;
    }
    const name = field.name;
    if (data[name] === void 0 && "default" in field.options) {
      newData[name] = field.options.default;
    }
  }
  return newData;
}
function t$2(key) {
  return VisualEditor.i18n[key];
}
var InsertPosition = /* @__PURE__ */ ((InsertPosition2) => {
  InsertPosition2["Start"] = "start";
  InsertPosition2["End"] = "end";
  return InsertPosition2;
})(InsertPosition || {});
var PreviewModes = /* @__PURE__ */ ((PreviewModes2) => {
  PreviewModes2[PreviewModes2["PHONE"] = 0] = "PHONE";
  PreviewModes2[PreviewModes2["DESKTOP"] = 1] = "DESKTOP";
  return PreviewModes2;
})(PreviewModes || {});
const sidebarWidth = typeof localStorage !== "undefined" ? localStorage.getItem("veSidebarWidth") : 0;
const createStore = (data = [], definitions, hiddenCategories = [], rootElement, templates2, insertPosition) => create(devtools(combine({
  data,
  definitions,
  hiddenCategories,
  rootElement,
  templates: templates2,
  insertPosition,
  previousData: [],
  rollbackMessage: null,
  addBlockIndex: null,
  focusIndex: null,
  previewMode: 1,
  sidebarWidth: clamp$1(sidebarWidth ? parseInt(sidebarWidth, 10) : 33, 0, window.innerWidth - 375)
}, (set2) => ({
  setSidebarWidth: function(width) {
    localStorage.setItem("veSidebarWidth", width.toString());
    set2(() => ({
      sidebarWidth: width
    }));
  },
  updateData: function(newData, path) {
    return set2((state) => ({
      data: deepSet(state.data, path, newData)
    }));
  },
  removeBloc: function(removedData) {
    return set2(({
      data: data2
    }) => ({
      previousData: data2,
      data: data2.filter((d2) => d2 !== removedData),
      rollbackMessage: t$2("deleteItemConfirm")
    }));
  },
  rollback: function() {
    return set2(({
      previousData
    }) => ({
      previousData: [],
      rollbackMessage: null,
      data: previousData
    }));
  },
  voidRollback: function() {
    return set2(() => ({
      rollbackMessage: null,
      previousData: []
    }));
  },
  insertData: function(name, index3, extraData) {
    const newData = __spreadProps(__spreadValues({}, extraData), {
      _name: name,
      _id: name + uniqId()
    });
    set2((state) => {
      return {
        data: insertItem(state.data, index3, newData),
        focusIndex: newData._id
      };
    });
    return newData;
  },
  setData: function(newData) {
    set2(() => {
      return {
        data: indexify(newData),
        focusIndex: null
      };
    });
  },
  setFocusIndex: function(id2) {
    set2(() => ({
      focusIndex: id2
    }));
  },
  setAddBlockIndex: function(index3) {
    if (index3 === void 0) {
      set2((state) => ({
        addBlockIndex: state.insertPosition === InsertPosition.Start ? 0 : state.data.length
      }));
      return;
    }
    if (typeof index3 === "string") {
      set2((state) => ({
        addBlockIndex: state.data.findIndex((v2) => v2._id === index3)
      }));
      return;
    }
    set2(() => ({
      addBlockIndex: index3
    }));
  },
  togglePreviewMode: function() {
    set2(({
      previewMode
    }) => ({
      previewMode: previewMode === 1 ? 0 : 1
    }));
  }
}))));
const {
  Provider,
  useStore
} = createContext();
function StoreProvider({
  children,
  data,
  definitions,
  hiddenCategories,
  rootElement,
  templates: templates2,
  insertPosition
}) {
  return /* @__PURE__ */ jsx(Provider, {
    createStore: () => createStore(data, definitions, hiddenCategories, rootElement, templates2, insertPosition),
    children
  });
}
function useData() {
  return useStore((state) => state.data);
}
function useRootElement() {
  return useStore((state) => state.rootElement);
}
function useUpdateData() {
  return useStore((state) => state.updateData);
}
function useRemoveBloc() {
  return useStore((state) => state.removeBloc);
}
function useInsertData() {
  return useStore((state) => state.insertData);
}
function useSetData() {
  return useStore((state) => state.setData);
}
function useFocusIndex() {
  return useStore((state) => state.focusIndex);
}
function useDefinitions() {
  return useStore((state) => state.definitions);
}
function useSetFocusIndex() {
  return useStore((state) => state.setFocusIndex);
}
function useFieldFocused(id2) {
  return useStore((state) => state.focusIndex === id2);
}
function usePreviewMode() {
  return useStore((state) => state.previewMode);
}
function useTogglePreviewMode() {
  return useStore((state) => state.togglePreviewMode);
}
function useSidebarWidth() {
  return useStore((state) => state.sidebarWidth);
}
function useSetSidebarWidth() {
  return useStore((state) => state.setSidebarWidth);
}
function useFieldDefinitions() {
  return useStore((state) => state.definitions);
}
function useHiddenCategories() {
  return useStore((state) => state.hiddenCategories);
}
function useBlocSelectionVisible() {
  return useStore((state) => state.addBlockIndex) !== null;
}
function useSetBlockIndex() {
  return useStore((state) => state.setAddBlockIndex);
}
function useTemplates() {
  return useStore((state) => state.templates);
}
function useAddBlock() {
  const insertData = useInsertData();
  const blockIndex = useStore((state) => state.addBlockIndex) || 0;
  const definitions = useDefinitions();
  const setBlockIndex = useSetBlockIndex();
  return react.exports.useCallback((blocName) => {
    insertData(blocName, blockIndex, fillDefaults({}, definitions[blocName].fields));
    setBlockIndex(null);
  }, [insertData, blockIndex, definitions, setBlockIndex]);
}
function useRollbackMessage() {
  const message = useStore((state) => state.rollbackMessage);
  const rollback = useStore((state) => state.rollback);
  const voidRollback = useStore((state) => state.voidRollback);
  return {
    message,
    rollback,
    voidRollback
  };
}
function useToggle(initial = false) {
  const [state, setState] = react.exports.useState(initial);
  return [state, () => setState((s2) => !s2), setState];
}
function useUpdateEffect(cb2, deps) {
  const isFirstRender = react.exports.useRef(true);
  react.exports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    return cb2();
  }, deps);
}
function strToDom(str) {
  return document.createRange().createContextualFragment(`<div>${str.trim()}</div>`).firstChild;
}
function offsetTop(element, acc = 0) {
  if (element.offsetParent) {
    return offsetTop(element.offsetParent, acc + element.offsetTop);
  }
  return acc + element.offsetTop;
}
const Wrapper$c = /* @__PURE__ */ createStyled(Flex, {
  target: "e1n2ihkq2"
})({
  name: "0",
  styles: ""
});
const Title$1 = createStyled("div", {
  target: "e1n2ihkq1"
})({
  name: "1p24k77",
  styles: "width:100%;color:var(--ve-color-light);text-align:left;font-size:.95em;scroll-margin:1.8em;cursor:pointer;strong{display:block;color:var(--ve-color);font-weight:500;font-size:1.1em;}"
});
const HoverableActions = /* @__PURE__ */ createStyled(Flex, {
  target: "e1n2ihkq0"
})({
  opacity: 0,
  transition: "opacity .3s",
  [`*:hover > * > &`]: {
    opacity: 1
  }
}, "");
const SidebarHeading = react.exports.forwardRef(({
  children,
  onClick,
  title,
  description
}, ref) => {
  const as = onClick ? UnstyledButton : "div";
  return /* @__PURE__ */ jsxs(Wrapper$c, {
    ref,
    gap: 0,
    between: true,
    children: [/* @__PURE__ */ jsxs(Title$1, {
      as,
      onClick,
      children: [/* @__PURE__ */ jsx("strong", {
        children: title
      }), description]
    }), children]
  });
});
SidebarHeading.displayName = "SidebarHeading";
const SidebarHeadingHoverable = (props) => {
  return /* @__PURE__ */ jsx(HoverableActions, __spreadValues({
    gap: 0
  }, props));
};
SidebarHeading.Hover = SidebarHeadingHoverable;
const SidebarBlocWrapper = /* @__PURE__ */ createStyled(Sortable, {
  target: "SidebarBlocWrapper"
})({
  name: "r5r2rm",
  styles: "position:relative;padding:.8em .6em .8em 1.4em;background-color:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 2px 0 rgba(0,0,0,0.05);transition:box-shadow .3s;cursor:inherit;&[data-dragging]{box-shadow:var(--ve-shadow-dragging);transition:box-shadow .3s!important;z-index:10;}"
});
var _ref$9 = {
  name: "1ok6q9c",
  styles: "background-color:var(--ve-hover);box-shadow:none"
};
function SidebarBlocMissing({
  data
}) {
  const removeBloc = useRemoveBloc();
  return /* @__PURE__ */ jsx(SidebarBlocWrapper, {
    item: data,
    css: _ref$9,
    children: /* @__PURE__ */ jsx(SidebarHeading, {
      title: `${t$2("unknownComponent")} : ${data._name}`,
      children: /* @__PURE__ */ jsx(ButtonIcon, {
        danger: true,
        onClick: prevent(() => removeBloc(data)),
        title: t$2("deleteComponent"),
        children: /* @__PURE__ */ jsx(IconTrash, {
          size: 20
        })
      })
    })
  });
}
function FieldsRenderer({
  data,
  fields,
  path,
  onUpdate
}) {
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: fields.filter((field) => field.shouldRender(data)).map((field, k2) => field.group ? /* @__PURE__ */ jsx(field.render, {
      options: field.options,
      children: /* @__PURE__ */ jsx(FieldsRenderer, {
        fields: field.fields,
        data,
        path,
        onUpdate
      })
    }, k2) : /* @__PURE__ */ jsx(Field, {
      field,
      value: field.name ? data[field.name] : void 0,
      path: `${path}.${field.name}`,
      extraProps: field.extraProps ? field.extraProps(data) : void 0,
      onUpdate
    }, field.name))
  });
}
function Field({
  field,
  value,
  path,
  extraProps,
  onUpdate
}) {
  const Component2 = field.render;
  const handleChange = react.exports.useCallback((v2) => {
    onUpdate(v2, path);
  }, [path, onUpdate]);
  return /* @__PURE__ */ jsx(Component2, __spreadValues({
    value,
    onChange: handleChange,
    options: field.options
  }, extraProps));
}
function SidebarFields({
  fields,
  data,
  path
}) {
  const updateData = useUpdateData();
  return /* @__PURE__ */ jsx(FieldsRenderer, {
    fields,
    data,
    onUpdate: updateData,
    path
  });
}
async function copyToClipboard(text3) {
  try {
    const permissionName = "clipboard-write";
    const result2 = await navigator.permissions.query({
      name: permissionName
    });
    if (result2.state == "granted" || result2.state == "prompt") {
      await navigator.clipboard.writeText(text3);
      return true;
    }
    throw result2;
  } catch (e2) {
    await navigator.clipboard.writeText(text3);
    return true;
  }
}
function CopyAction(_q) {
  var _r = _q, {
    data,
    size
  } = _r, props = __objRest(_r, [
    "data",
    "size"
  ]);
  const [success, setSuccess] = react.exports.useState(false);
  const timer = react.exports.useRef();
  const handleCopy = async () => {
    try {
      await copyToClipboard(stringifyFields(data));
      setSuccess(true);
      timer.current = window.setTimeout(() => {
        setSuccess(false);
      }, 4e3);
    } catch (e2) {
      alert(e2);
    }
  };
  const tooltipLabel = Array.isArray(data) ? t$2("copyPage") : t$2("copyComponent");
  react.exports.useEffect(() => {
    clearTimeout(timer.current);
  }, []);
  return /* @__PURE__ */ jsx(Tooltip$1, {
    content: success ? /* @__PURE__ */ jsxs(Fragment$1, {
      children: [t$2("copySuccess"), /* @__PURE__ */ jsx("br", {}), t$2("copyInstructions")]
    }) : tooltipLabel,
    trigger: "focus",
    children: /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(ButtonIcon, __spreadProps(__spreadValues({
        onClick: prevent(handleCopy),
        success
      }, props), {
        children: success ? /* @__PURE__ */ jsx(IconCheck, {
          size
        }) : /* @__PURE__ */ jsx(IconCode, {
          size
        })
      }))
    })
  });
}
var _ref$8 = {
  name: "1xvwyp0",
  styles: "margin-top:.5em"
};
const SidebarBloc = react.exports.memo(function SidebarItem({
  data,
  definition,
  path
}) {
  const ref = react.exports.useRef(null);
  const isFocused = useFieldFocused(data._id);
  const [isCollapsed, toggleCollapsed, setCollapsed] = useToggle(!isFocused);
  const removeBloc = useRemoveBloc();
  const setFocusIndex = useSetFocusIndex();
  const label = (definition == null ? void 0 : definition.label) && data[definition.label] ? data[definition.label] : null;
  useUpdateEffect(() => {
    if (isFocused) {
      setCollapsed(false);
      window.setTimeout(() => ref.current.scrollIntoView({
        behavior: "smooth",
        block: "start"
      }), 100);
    } else {
      setCollapsed(true);
    }
  }, [isFocused]);
  const labelHTMLSafe = react.exports.useMemo(() => (label == null ? void 0 : label.includes("<")) ? strToDom(label).innerText : label, [label]);
  const handleRemove = () => {
    removeBloc(data);
  };
  const focusBloc = () => {
    if (isCollapsed) {
      setFocusIndex(path);
    }
    toggleCollapsed();
  };
  if (!definition) {
    return /* @__PURE__ */ jsx(SidebarBlocMissing, {
      data
    });
  }
  return /* @__PURE__ */ jsxs(SidebarBlocWrapper, {
    item: data,
    children: [/* @__PURE__ */ jsxs(SidebarHeading, {
      ref,
      title: definition.title,
      description: isCollapsed ? labelHTMLSafe : null,
      onClick: prevent(focusBloc),
      children: [/* @__PURE__ */ jsxs(SidebarHeading.Hover, {
        children: [/* @__PURE__ */ jsx(CopyAction, {
          data,
          size: 20
        }), /* @__PURE__ */ jsx(ButtonIcon, {
          danger: true,
          onClick: handleRemove,
          title: t$2("deleteComponent"),
          children: /* @__PURE__ */ jsx(IconTrash, {
            size: 20
          })
        })]
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        rotate: isCollapsed ? -90 : 0,
        onClick: prevent(toggleCollapsed),
        children: /* @__PURE__ */ jsx(IconDown, {
          size: 20
        })
      })]
    }), !isCollapsed && /* @__PURE__ */ jsx(Flex, {
      column: true,
      gap: 1,
      css: _ref$8,
      children: /* @__PURE__ */ jsx(SidebarFields, {
        fields: definition.fields,
        data,
        path
      })
    })]
  });
});
function SidebarBlocs({
  data
}) {
  const updateData = useUpdateData();
  const definitions = useFieldDefinitions();
  const handleMove = (from5, to) => {
    updateData(moveItem(data, from5, to));
  };
  return /* @__PURE__ */ jsx(Wrapper$b, {
    children: /* @__PURE__ */ jsx(SortableWrapper, {
      items: data,
      onMove: handleMove,
      children: data.map((v2, k2) => /* @__PURE__ */ jsx(SidebarBloc, {
        data: v2,
        definition: definitions[v2._name],
        path: `${k2}`
      }, v2._id))
    })
  });
}
const Wrapper$b = createStyled("div", {
  target: "e1lkcxfq0"
})({
  name: "fr4z9h",
  styles: "display:grid;grid-template-columns:1fr;flex-direction:column;grid-gap:1em;padding:1em;overflow:auto;scrollbar-gutter:stable"
});
function SidebarHeader({
  onClose,
  children
}) {
  const togglePreviewMode = useTogglePreviewMode();
  const previewMode = usePreviewMode();
  const isPhone = previewMode === PreviewModes.PHONE;
  const setAddBlock = useSetBlockIndex();
  const data = useData();
  return /* @__PURE__ */ jsxs(Wrapper$a, {
    between: true,
    children: [/* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(ButtonIcon, {
        title: t$2("close"),
        onClick: prevent(onClose),
        children: /* @__PURE__ */ jsx(IconCross, {
          size: 12
        })
      })
    }), /* @__PURE__ */ jsxs(Flex, {
      children: [children, /* @__PURE__ */ jsx(CopyAction, {
        data,
        size: 20
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        onClick: prevent(togglePreviewMode),
        title: t$2("responsiveView"),
        children: isPhone ? /* @__PURE__ */ jsx(IconDesktop, {
          size: 20
        }) : /* @__PURE__ */ jsx(IconPhone, {
          size: 24
        })
      }), /* @__PURE__ */ jsx(Button$7, {
        icon: IconCirclePlus,
        onClick: prevent(() => setAddBlock()),
        children: t$2("addComponent")
      })]
    })]
  });
}
const Wrapper$a = /* @__PURE__ */ createStyled(Flex, {
  target: "eh5ak8v0"
})({
  name: "dryaye",
  styles: "padding:0 1em;flex:none;background-color:#FFF;border-bottom:1px solid rgba(0,0,0,0.06);box-shadow:rgba(0, 0, 0, 0.05) 0 1px 2px 0;height:64px"
});
function SidebarFooter() {
  return /* @__PURE__ */ jsxs(Wrapper$9, {
    between: true,
    children: [/* @__PURE__ */ jsxs(Mention, {
      children: [t$2("poweredBy"), " ", /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsx("a", {
        href: "https://boxraiser.com",
        target: "_blank",
        children: /* @__PURE__ */ jsx(Logo, {
          src: "https://static.boxraiser.com/logo.svg",
          alt: "Logo Boxraiser"
        })
      })]
    }), /* @__PURE__ */ jsx(Button$7, {
      type: "submit",
      icon: IconSave,
      children: t$2("save")
    })]
  });
}
const Wrapper$9 = /* @__PURE__ */ createStyled(Flex, {
  target: "e1rh06wn2"
})({
  name: "1t65jij",
  styles: "margin-top:auto;background-color:#FFF;justify-content:flex-end;border-top:1px solid rgba(0,0,0,0.06);padding:.5em 1em;box-shadow:0 -1px 2px 0 rgba(0,0,0,0.05)"
});
const Mention = /* @__PURE__ */ createStyled("div", {
  target: "e1rh06wn1"
})({
  name: "1nvz0zk",
  styles: "font-size:.7em;margin-right:auto"
});
const Logo = /* @__PURE__ */ createStyled("img", {
  target: "e1rh06wn0"
})({
  name: "14i868d",
  styles: "width:auto;height:20px"
});
function SidebarEmpty(data) {
  return /* @__PURE__ */ jsxs(Wrapper$8, {
    children: [/* @__PURE__ */ jsx(Description, {
      children: t$2("noContent")
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(Button$7, {
        outline: true,
        onClick: prevent(data.onAction),
        size: "small",
        children: t$2("useTemplate")
      })
    })]
  });
}
const Wrapper$8 = createStyled("div", {
  target: "enegsk11"
})({
  name: "d3jdti",
  styles: "display:flex;align-items:center;flex-direction:column;justify-content:center;height:100%;text-align:center"
});
const Description = createStyled("p", {
  target: "enegsk10"
})({
  name: "1gpzra0",
  styles: "margin-bottom:1em"
});
function SidebarTemplates({
  onTemplate
}) {
  const templates2 = useTemplates();
  const setData = useSetData();
  const [loadingTemplate, setLoadingTemplate] = react.exports.useState();
  const callback = react.exports.useCallback(async (t2) => {
    setLoadingTemplate(t2);
    let data;
    if (typeof t2.data === "function") {
      setLoadingTemplate(t2);
      data = await t2.data().catch(() => []);
      setLoadingTemplate(t2);
    } else {
      data = t2.data;
    }
    setData(data);
    onTemplate();
  }, [setData, onTemplate]);
  return /* @__PURE__ */ jsx(Wrapper$7, {
    children: templates2.map((t2) => /* @__PURE__ */ jsx(TemplateCard, {
      template: t2,
      onClick: callback,
      loading: loadingTemplate === t2
    }))
  });
}
function TemplateCard({
  template,
  onClick,
  loading
}) {
  return /* @__PURE__ */ jsxs(StyledCard, {
    hoverable: true,
    onClick: prevent(() => loading ? null : onClick(template)),
    loading,
    children: [loading && /* @__PURE__ */ jsx(Spinner, {}), /* @__PURE__ */ jsx(TemplateImage, {
      src: template.image,
      alt: ""
    }), /* @__PURE__ */ jsxs(Body, {
      children: [/* @__PURE__ */ jsx(Title, {
        children: template.name
      }), /* @__PURE__ */ jsx("div", {
        children: template.description
      })]
    })]
  });
}
const Wrapper$7 = createStyled("div", {
  target: "e1e5th424"
})({
  name: "rouwkd",
  styles: "display:flex;flex-direction:column;justify-content:flex-start;height:100%;padding:1em;gap:1em;overflow:auto"
});
const StyledCard = /* @__PURE__ */ createStyled(Card, {
  target: "e1e5th423"
})("padding:0;display:grid;position:relative;grid-template-columns:150px 1fr;grid-gap:1.5em;align-items:center;width:100%;cursor:pointer;", (props) => props.loading ? {
  opacity: 0.4,
  cursor: "inherit"
} : {}, "");
const TemplateImage = createStyled("img", {
  target: "e1e5th422"
})({
  name: "1iynevt",
  styles: "width:100%;height:150px;object-fit:cover"
});
const Body = createStyled("div", {
  target: "e1e5th421"
})({
  name: "j8h71g",
  styles: "display:grid;grid-template-columns:1fr"
});
const Title = createStyled("div", {
  target: "e1e5th420"
})({
  name: "5kdo1",
  styles: "color:var(--ve-color);font-weight:500;font-size:1.1em"
});
function Sidebar(_s) {
  var _t2 = _s, {
    data,
    onClose
  } = _t2, props = __objRest(_t2, [
    "data",
    "onClose"
  ]);
  const [state, setState] = react.exports.useState(0);
  const templates2 = useTemplates();
  const toggleMode = react.exports.useCallback(() => {
    setState((v2) => v2 === 0 ? 1 : 0);
  }, []);
  const hasTemplates = templates2.length > 0;
  const showEmpty = data.length === 0 && hasTemplates;
  const isTemplateMode = state === 1;
  return /* @__PURE__ */ jsxs(SidebarWrapper, __spreadProps(__spreadValues({}, props), {
    children: [/* @__PURE__ */ jsx(SidebarHeader, {
      onClose,
      children: hasTemplates && /* @__PURE__ */ jsx(ButtonIcon, {
        onClick: prevent(toggleMode),
        title: t$2(isTemplateMode ? "addComponent" : "useTemplate"),
        children: isTemplateMode ? /* @__PURE__ */ jsx(IconBlocs, {}) : /* @__PURE__ */ jsx(IconPage, {})
      })
    }), state === 0 && (showEmpty ? /* @__PURE__ */ jsx(SidebarEmpty, {
      onAction: () => setState(1)
    }) : /* @__PURE__ */ jsx(SidebarBlocs, {
      data
    })), state === 1 && /* @__PURE__ */ jsx(SidebarTemplates, {
      onTemplate: () => setState(0)
    }), /* @__PURE__ */ jsx(SidebarFooter, {})]
  }));
}
const Out$2 = keyframes({
  from: {
    transform: "translateX(0)"
  },
  to: {
    transform: "translateX(-100%)"
  }
});
const In$3 = keyframes({
  from: {
    transform: "translateX(-100%)"
  },
  to: {
    transform: "translateX(0)"
  }
});
const SidebarWrapper = createStyled("div", {
  target: "el71wm30"
})({
  position: "relative",
  display: "flex",
  flexDirection: "column",
  height: "100vh",
  backgroundColor: "#FBFBFD",
  zIndex: 2,
  boxShadow: "0 20px 25px -5px rgba(0,0,0,0.2),0 10px 10px -5px rgba(0,0,0,0.04)",
  transition: "transform .5s cubic-bezier(0.19, 1, 0.22, 1)",
  animation: `${In$3} .7s cubic-bezier(0.19, 1, 0.22, 1) both`,
  "[hidden=hidden] &": {
    animation: `${Out$2} .7s cubic-bezier(0.19, 1, 0.22, 1) both`
  }
}, "");
function useAsyncEffect(cb2, deps) {
  react.exports.useEffect(() => {
    cb2();
  }, deps);
}
function on(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.addEventListener) {
    obj.addEventListener.apply(obj, args);
  }
}
function off(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.removeEventListener) {
    obj.removeEventListener.apply(obj, args);
  }
}
var isBrowser = typeof window !== "undefined";
var useEffectOnce = function(effect3) {
  react.exports.useEffect(effect3, []);
};
var useEffectOnce$1 = useEffectOnce;
var useUnmount = function(fn3) {
  var fnRef = react.exports.useRef(fn3);
  fnRef.current = fn3;
  useEffectOnce$1(function() {
    return function() {
      return fnRef.current();
    };
  });
};
var useUnmount$1 = useUnmount;
var useRafState = function(initialState) {
  var frame2 = react.exports.useRef(0);
  var _a = react.exports.useState(initialState), state = _a[0], setState = _a[1];
  var setRafState = react.exports.useCallback(function(value) {
    cancelAnimationFrame(frame2.current);
    frame2.current = requestAnimationFrame(function() {
      setState(value);
    });
  }, []);
  useUnmount$1(function() {
    cancelAnimationFrame(frame2.current);
  });
  return [state, setRafState];
};
var useRafState$1 = useRafState;
var useWindowSize = function(initialWidth, initialHeight) {
  if (initialWidth === void 0) {
    initialWidth = Infinity;
  }
  if (initialHeight === void 0) {
    initialHeight = Infinity;
  }
  var _a = useRafState$1({
    width: isBrowser ? window.innerWidth : initialWidth,
    height: isBrowser ? window.innerHeight : initialHeight
  }), state = _a[0], setState = _a[1];
  react.exports.useEffect(function() {
    if (isBrowser) {
      var handler_1 = function() {
        setState({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };
      on(window, "resize", handler_1);
      return function() {
        off(window, "resize", handler_1);
      };
    }
  }, []);
  return state;
};
var useWindowSize$1 = useWindowSize;
const PHONE_HEIGHT = 844;
let memoizedCreateCacheWithContainer = weakMemoize((container) => {
  return createCache({
    container: container.querySelector("head"),
    key: "iframe"
  });
});
function FrameProvider({
  container,
  children
}) {
  return /* @__PURE__ */ jsx(CacheProvider, {
    value: memoizedCreateCacheWithContainer(container),
    children
  });
}
var _ref$7 = {
  name: "yxrv7x",
  styles: "visual-editor{display:block;}"
};
const BaseStyles = ({
  children,
  complete = true
}) => {
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Global, {
      styles: _ref$7
    }), /* @__PURE__ */ jsx(Reset, {
      complete,
      children
    })]
  });
};
const Reset = createStyled("div", {
  target: "e1mvu4qm0"
})({
  name: "1vq1tps",
  styles: "--ve-background:#fff;--ve-primary:#1771e6;--ve-dark:#202227;--ve-primary-hover:#388afa;--ve-primary-light:#1771e626;--ve-color:#111827;--ve-hover:#f3f4f9;--ve-color-light:#6b7280;--ve-field-border:rgb(209, 213, 219);--ve-field-shadow:rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;--ve-blocs-background:rgba(0, 0, 0, 0.05);--ve-danger:#ae2121;--ve-danger-light:rgba(255, 0, 0, 0.05);--ve-shadow-dragging:rgba(0, 0, 0, 0.1) 0 10px 15px -3px,rgba(0, 0, 0, 0.05) 0 4px 6px -2px;--ve-gap:0.5em;font-size:16px;line-height:1.4;*,*::before,*::after{box-sizing:border-box;}"
}, (props) => props.complete ? `
  img,
  picture,
  video,
  canvas,
  svg {
    display: block;
    max-width: 100%;
  }

  input,
  button,
  textarea,
  select {
    font: inherit;
  }` : {}, "");
/*! @license Rematrix v0.2.2

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format$1(source) {
  if (source.constructor !== Array) {
    throw new TypeError("Expected array.");
  }
  if (source.length === 16) {
    return source;
  }
  if (source.length === 6) {
    var matrix = identity();
    matrix[0] = source[0];
    matrix[1] = source[1];
    matrix[4] = source[2];
    matrix[5] = source[3];
    matrix[12] = source[4];
    matrix[13] = source[5];
    return matrix;
  }
  throw new RangeError("Expected array with either 6 or 16 values.");
}
function identity() {
  var matrix = [];
  for (var i2 = 0; i2 < 16; i2++) {
    i2 % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(m2, x2) {
  var fm = format$1(m2);
  var fx = format$1(x2);
  var product = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var row = [fm[i2], fm[i2 + 4], fm[i2 + 8], fm[i2 + 12]];
    for (var j2 = 0; j2 < 4; j2++) {
      var k2 = j2 * 4;
      var col = [fx[k2], fx[k2 + 1], fx[k2 + 2], fx[k2 + 3]];
      var result2 = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i2 + k2] = result2;
    }
  }
  return product;
}
function parse$1(source) {
  if (typeof source === "string") {
    var match2 = source.match(/matrix(3d)?\(([^)]+)\)/);
    if (match2) {
      var raw = match2[2].split(", ").map(parseFloat);
      return format$1(raw);
    }
  }
  return identity();
}
function scaleX(scalar) {
  var matrix = identity();
  matrix[0] = scalar;
  return matrix;
}
function scaleY(scalar) {
  var matrix = identity();
  matrix[5] = scalar;
  return matrix;
}
function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
var a$1 = function(t2) {
  return typeof t2 == "number";
}, o$1 = function(t2) {
  return typeof t2 == "function";
}, l$1 = function(t2) {
  return Object.prototype.toString.call(t2) === "[object Object]";
}, p$2 = function(t2) {
  return Array.prototype.slice.apply(t2);
}, c$3 = function(t2) {
  var e2 = t2.reduce(function(t3, e3) {
    return t3[e3] = (t3[e3] || 0) + 1, t3;
  }, {});
  return Object.keys(e2).filter(function(t3) {
    return e2[t3] > 1;
  });
};
function u$2(t2) {
  return [].slice.call(arguments, 1).forEach(function(e2) {
    if (e2)
      for (var i2 in e2)
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
  }), t2;
}
var d$2, f$3 = function(t2, e2, i2) {
  return t2 + (e2 - t2) * i2;
}, h$3 = { __proto__: null, isNumber: a$1, isFunction: o$1, isObject: l$1, toArray: p$2, getDuplicateValsAsStrings: c$3, assign: u$2, tweenProp: f$3 }, g$2 = { __proto__: null, DATA_FLIP_ID: "data-flip-id", DATA_INVERSE_FLIP_ID: "data-inverse-flip-id", DATA_FLIP_COMPONENT_ID: "data-flip-component-id", DATA_FLIP_CONFIG: "data-flip-config", DATA_PORTAL_KEY: "data-portal-key", DATA_EXIT_CONTAINER: "data-exit-container" }, m$3 = { noWobble: { stiffness: 200, damping: 26 }, gentle: { stiffness: 120, damping: 14 }, veryGentle: { stiffness: 130, damping: 17 }, wobbly: { stiffness: 180, damping: 12 }, stiff: { stiffness: 260, damping: 26 } }, v$1 = function(t2) {
  return l$1(t2) ? t2 : Object.keys(m$3).indexOf(t2) > -1 ? m$3[t2] : {};
};
typeof window != "undefined" && (d$2 = window.requestAnimationFrame);
var y$1 = d$2 = d$2 || function(t2) {
  window.setTimeout(t2, 1e3 / 60);
}, _$1 = Date.now(), S$1 = typeof performance == "object" && typeof performance.now == "function" ? function() {
  return performance.now();
} : function() {
  return Date.now() - _$1;
};
function E$2(t2, e2) {
  var i2 = t2.indexOf(e2);
  i2 !== -1 && t2.splice(i2, 1);
}
var A$1 = function() {
  function t2() {
  }
  return t2.prototype.run = function() {
    var t3 = this;
    y$1(function() {
      t3.springSystem.loop(S$1());
    });
  }, t2;
}(), C$1 = function() {
  this.position = 0, this.velocity = 0;
}, b$1 = 0, I = function() {
  function t2(t3) {
    this._id = "s" + b$1++, this._springSystem = t3, this.listeners = [], this._startValue = 0, this._currentState = new C$1(), this._displacementFromRestThreshold = 1e-3, this._endValue = 0, this._overshootClampingEnabled = false, this._previousState = new C$1(), this._restSpeedThreshold = 1e-3, this._tempState = new C$1(), this._timeAccumulator = 0, this._wasAtRest = true, this._cachedSpringConfig = {};
  }
  var e2 = t2.prototype;
  return e2.getId = function() {
    return this._id;
  }, e2.destroy = function() {
    this.listeners = [], this._springSystem.deregisterSpring(this);
  }, e2.setSpringConfig = function(t3) {
    return this._springConfig = t3, this;
  }, e2.getCurrentValue = function() {
    return this._currentState.position;
  }, e2.getDisplacementDistanceForState = function(t3) {
    return Math.abs(this._endValue - t3.position);
  }, e2.setEndValue = function(t3) {
    if (t3 === this._endValue)
      return this;
    if (this.prevEndValue = t3, this._endValue === t3 && this.isAtRest())
      return this;
    this._startValue = this.getCurrentValue(), this._endValue = t3, this._springSystem.activateSpring(this.getId());
    for (var e3 = 0, i2 = this.listeners.length; e3 < i2; e3++) {
      var n2 = this.listeners[e3].onSpringEndStateChange;
      n2 && n2(this);
    }
    return this;
  }, e2.setVelocity = function(t3) {
    return t3 === this._currentState.velocity || (this._currentState.velocity = t3, this._springSystem.activateSpring(this.getId())), this;
  }, e2.setCurrentValue = function(t3) {
    this._startValue = t3, this._currentState.position = t3;
    for (var e3 = 0, i2 = this.listeners.length; e3 < i2; e3++) {
      var n2 = this.listeners[e3];
      n2.onSpringUpdate && n2.onSpringUpdate(this);
    }
    return this;
  }, e2.setAtRest = function() {
    return this._endValue = this._currentState.position, this._tempState.position = this._currentState.position, this._currentState.velocity = 0, this;
  }, e2.setOvershootClampingEnabled = function(t3) {
    return this._overshootClampingEnabled = t3, this;
  }, e2.isOvershooting = function() {
    var t3 = this._startValue, e3 = this._endValue;
    return this._springConfig.tension > 0 && (t3 < e3 && this.getCurrentValue() > e3 || t3 > e3 && this.getCurrentValue() < e3);
  }, e2.advance = function(t3, e3) {
    var i2 = this.isAtRest();
    if (!i2 || !this._wasAtRest) {
      var n2 = e3;
      e3 > 0.064 && (n2 = 0.064), this._timeAccumulator += n2;
      for (var r2, s2, a2, o2, l2, p2, c2 = this._springConfig.tension, u2 = this._springConfig.friction, d2 = this._currentState.position, f2 = this._currentState.velocity, h2 = this._tempState.position, g2 = this._tempState.velocity; this._timeAccumulator >= 1e-3; )
        this._timeAccumulator -= 1e-3, this._timeAccumulator < 1e-3 && (this._previousState.position = d2, this._previousState.velocity = f2), s2 = c2 * (this._endValue - h2) - u2 * f2, o2 = c2 * (this._endValue - (h2 = d2 + 1e-3 * (r2 = f2) * 0.5)) - u2 * (g2 = f2 + 1e-3 * s2 * 0.5), p2 = c2 * (this._endValue - (h2 = d2 + 1e-3 * (a2 = g2) * 0.5)) - u2 * (g2 = f2 + 1e-3 * o2 * 0.5), h2 = d2 + 1e-3 * (l2 = g2), d2 += 1 / 6 * (r2 + 2 * (a2 + l2) + (g2 = f2 + 1e-3 * p2)) * 1e-3, f2 += 1 / 6 * (s2 + 2 * (o2 + p2) + (c2 * (this._endValue - h2) - u2 * g2)) * 1e-3;
      this._tempState.position = h2, this._tempState.velocity = g2, this._currentState.position = d2, this._currentState.velocity = f2, this._timeAccumulator > 0 && this._interpolate(this._timeAccumulator / 1e-3), (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) && (this._springConfig.tension > 0 ? (this._startValue = this._endValue, this._currentState.position = this._endValue) : (this._endValue = this._currentState.position, this._startValue = this._endValue), this.setVelocity(0), i2 = true);
      var m2 = false;
      this._wasAtRest && (this._wasAtRest = false, m2 = true);
      var v2 = false;
      i2 && (this._wasAtRest = true, v2 = true), this.notifyPositionUpdated(m2, v2);
    }
  }, e2.notifyPositionUpdated = function(t3, e3) {
    var i2 = this;
    this.listeners.filter(Boolean).forEach(function(n2) {
      t3 && n2.onSpringActivate && !i2._onActivateCalled && (n2.onSpringActivate(i2), i2._onActivateCalled = true), n2.onSpringUpdate && n2.onSpringUpdate(i2), e3 && n2.onSpringAtRest && n2.onSpringAtRest(i2);
    });
  }, e2.systemShouldAdvance = function() {
    return !this.isAtRest() || !this.wasAtRest();
  }, e2.wasAtRest = function() {
    return this._wasAtRest;
  }, e2.isAtRest = function() {
    return Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || this._springConfig.tension === 0);
  }, e2._interpolate = function(t3) {
    this._currentState.position = this._currentState.position * t3 + this._previousState.position * (1 - t3), this._currentState.velocity = this._currentState.velocity * t3 + this._previousState.velocity * (1 - t3);
  }, e2.addListener = function(t3) {
    return this.listeners.push(t3), this;
  }, e2.addOneTimeListener = function(t3) {
    var e3 = this;
    return Object.keys(t3).forEach(function(i2) {
      var n2;
      t3[i2] = (n2 = t3[i2], function() {
        n2.apply(void 0, [].slice.call(arguments)), e3.removeListener(t3);
      });
    }), this.listeners.push(t3), this;
  }, e2.removeListener = function(t3) {
    return E$2(this.listeners, t3), this;
  }, t2;
}(), O$1 = function() {
  function t2(t3) {
    this.looper = t3 || new A$1(), this.looper.springSystem = this, this.listeners = [], this._activeSprings = [], this._idleSpringIndices = [], this._isIdle = true, this._lastTimeMillis = -1, this._springRegistry = {};
  }
  var e2 = t2.prototype;
  return e2.createSpring = function(t3, e3) {
    return this.createSpringWithConfig({ tension: t3, friction: e3 });
  }, e2.createSpringWithConfig = function(t3) {
    var e3 = new I(this);
    return this.registerSpring(e3), e3.setSpringConfig(t3), e3;
  }, e2.getIsIdle = function() {
    return this._isIdle;
  }, e2.registerSpring = function(t3) {
    this._springRegistry[t3.getId()] = t3;
  }, e2.deregisterSpring = function(t3) {
    E$2(this._activeSprings, t3), delete this._springRegistry[t3.getId()];
  }, e2.advance = function(t3, e3) {
    for (var i2 = this; this._idleSpringIndices.length > 0; )
      this._idleSpringIndices.pop();
    for (this._activeSprings.filter(Boolean).forEach(function(n3) {
      n3.systemShouldAdvance() ? n3.advance(t3 / 1e3, e3 / 1e3) : i2._idleSpringIndices.push(i2._activeSprings.indexOf(n3));
    }); this._idleSpringIndices.length > 0; ) {
      var n2 = this._idleSpringIndices.pop();
      n2 >= 0 && this._activeSprings.splice(n2, 1);
    }
  }, e2.loop = function(t3) {
    var e3;
    this._lastTimeMillis === -1 && (this._lastTimeMillis = t3 - 1);
    var i2 = t3 - this._lastTimeMillis;
    this._lastTimeMillis = t3;
    var n2 = 0, r2 = this.listeners.length;
    for (n2 = 0; n2 < r2; n2++)
      (e3 = this.listeners[n2]).onBeforeIntegrate && e3.onBeforeIntegrate(this);
    for (this.advance(t3, i2), this._activeSprings.length === 0 && (this._isIdle = true, this._lastTimeMillis = -1), n2 = 0; n2 < r2; n2++)
      (e3 = this.listeners[n2]).onAfterIntegrate && e3.onAfterIntegrate(this);
    this._isIdle || this.looper.run();
  }, e2.activateSpring = function(t3) {
    var e3 = this._springRegistry[t3];
    this._activeSprings.indexOf(e3) === -1 && this._activeSprings.push(e3), this.getIsIdle() && (this._isIdle = false, this.looper.run());
  }, t2;
}(), w$2 = new O$1(), x$2 = function(t2) {
  var e2 = t2.springConfig, i2 = e2.overshootClamping, n2 = t2.getOnUpdateFunc, r2 = t2.onAnimationEnd, s2 = t2.onSpringActivate, a2 = w$2.createSpring(e2.stiffness, e2.damping);
  a2.setOvershootClampingEnabled(!!i2);
  var o2 = { onSpringActivate: s2, onSpringAtRest: function() {
    a2.destroy(), r2();
  }, onSpringUpdate: n2({ spring: a2, onAnimationEnd: r2 }) };
  return a2.addListener(o2), a2;
}, U = function(t2) {
  var e2 = x$2(t2);
  return e2.setEndValue(1), e2;
}, V = function(t2, e2) {
  if (e2 === void 0 && (e2 = {}), t2 && t2.length) {
    e2.reverse && t2.reverse();
    var i2, n2 = typeof (i2 = e2.speed) != "number" ? 1.1 : 1 + Math.min(Math.max(5 * i2, 0), 5), r2 = 1 / Math.max(Math.min(t2.length, 100), 10), s2 = t2.map(function(t3, e3) {
      var i3 = t3.getOnUpdateFunc;
      return t3.getOnUpdateFunc = function(t4) {
        var a2 = i3(t4);
        return function(t5) {
          var i4 = t5.getCurrentValue();
          (i4 = i4 < 0.01 ? 0 : i4 > 0.99 ? 1 : i4) >= r2 && s2[e3 + 1] && s2[e3 + 1](Math.max(Math.min(i4 * n2, 1), 0)), a2(t5);
        };
      }, t3;
    }).map(function(t3) {
      var e3 = x$2(t3);
      if (e3)
        return e3.setEndValue.bind(e3);
    }).filter(Boolean);
    s2[0] && s2[0](1);
  }
}, F = function(t2) {
  return [0, 1, 4, 5, 12, 13].map(function(e2) {
    return t2[e2];
  });
}, P$1 = function(t2) {
  return t2.top < window.innerHeight && t2.bottom > 0 && t2.left < window.innerWidth && t2.right > 0;
};
function R$2(t2) {
  return JSON.parse(t2.dataset.flipConfig || "{}");
}
var T$1 = function(t2, e2) {
  var i2;
  return u$2(t2, ((i2 = {})[e2[0]] = e2[1], i2));
}, D$1 = function(t2, e2) {
  return p$2(e2 ? document.querySelectorAll('[data-portal-key="' + e2 + '"]') : t2.querySelectorAll("[data-flip-id]"));
}, M$1 = function(t2) {
  return t2.map(function(t3) {
    return [t3, t3.getBoundingClientRect()];
  });
}, k = function(l2) {
  var d2, h2 = l2.cachedOrderedFlipIds, g2 = h2 === void 0 ? [] : h2, y2 = l2.inProgressAnimations, _2 = y2 === void 0 ? {} : y2, S2 = l2.flippedElementPositionsBeforeUpdate, E2 = S2 === void 0 ? {} : S2, A2 = l2.flipCallbacks, C2 = A2 === void 0 ? {} : A2, b2 = l2.containerEl, I2 = l2.applyTransformOrigin, O2 = l2.spring, w2 = l2.debug, x2 = l2.portalKey, k2 = l2.staggerConfig, j2 = k2 === void 0 ? {} : k2, B2 = l2.decisionData, N2 = B2 === void 0 ? {} : B2, L2 = l2.handleEnterUpdateDelete, q2 = l2.onComplete, W2 = l2.onStart, K2 = M$1(D$1((d2 = { element: b2, portalKey: x2 }).element, d2.portalKey)).map(function(t2) {
    var e2 = t2[0], i2 = t2[1], n2 = window.getComputedStyle(e2);
    return [e2.dataset.flipId, { element: e2, rect: i2, opacity: parseFloat(n2.opacity), transform: n2.transform }];
  }).reduce(T$1, {}), X2 = function(t2) {
    var e2 = t2.containerEl, i2 = t2.portalKey;
    return i2 ? function(t3) {
      return function(e3) {
        return p$2(document.querySelectorAll('[data-portal-key="' + t3 + '"]' + e3));
      };
    }(i2) : e2 ? function(t3) {
      var e3 = Math.random().toFixed(5);
      return t3.dataset.flipperId = e3, function(i3) {
        return p$2(t3.querySelectorAll('[data-flipper-id="' + e3 + '"] ' + i3));
      };
    }(e2) : function() {
      return [];
    };
  }({ containerEl: b2, portalKey: x2 }), Y2 = function(t2) {
    return function(e2) {
      return t2('[data-flip-id="' + e2 + '"]')[0];
    };
  }(X2), H2 = function(t2) {
    return E2[t2] && K2[t2];
  }, J2 = Object.keys(E2).concat(Object.keys(K2)).filter(function(t2) {
    return !H2(t2);
  }), z2 = { flipCallbacks: C2, getElement: Y2, flippedElementPositionsBeforeUpdate: E2, flippedElementPositionsAfterUpdate: K2, inProgressAnimations: _2, decisionData: N2 }, G2 = function(t2) {
    var e2, i2 = t2.unflippedIds, n2 = t2.flipCallbacks, r2 = t2.getElement, s2 = t2.flippedElementPositionsBeforeUpdate, a2 = t2.flippedElementPositionsAfterUpdate, o2 = t2.inProgressAnimations, l3 = t2.decisionData, p2 = i2.filter(function(t3) {
      return a2[t3];
    }).filter(function(t3) {
      return n2[t3] && n2[t3].onAppear;
    }), c2 = i2.filter(function(t3) {
      return s2[t3] && n2[t3] && n2[t3].onExit;
    }), u2 = new Promise(function(t3) {
      e2 = t3;
    }), d3 = [], f2 = 0, h3 = c2.map(function(t3, i3) {
      var r3 = s2[t3].domDataForExitAnimations, a3 = r3.element, p3 = r3.parent, c3 = r3.childPosition, u3 = c3.top, h4 = c3.left, g3 = c3.width, m2 = c3.height;
      getComputedStyle(p3).position === "static" && (p3.style.position = "relative"), a3.style.transform = "matrix(1, 0, 0, 1, 0, 0)", a3.style.position = "absolute", a3.style.top = u3 + "px", a3.style.left = h4 + "px", a3.style.height = m2 + "px", a3.style.width = g3 + "px";
      var v2 = d3.filter(function(t4) {
        return t4[0] === p3;
      })[0];
      v2 || (v2 = [p3, document.createDocumentFragment()], d3.push(v2)), v2[1].appendChild(a3), f2 += 1;
      var y3 = function() {
        try {
          p3.removeChild(a3);
        } catch (t4) {
        } finally {
          (f2 -= 1) == 0 && e2();
        }
      };
      return o2[t3] = { stop: y3 }, function() {
        return n2[t3].onExit(a3, i3, y3, l3);
      };
    });
    return d3.forEach(function(t3) {
      t3[0].appendChild(t3[1]);
    }), h3.length || e2(), { hideEnteringElements: function() {
      p2.forEach(function(t3) {
        var e3 = r2(t3);
        e3 && (e3.style.opacity = "0");
      });
    }, animateEnteringElements: function() {
      p2.forEach(function(t3, e3) {
        var i3 = r2(t3);
        i3 && n2[t3].onAppear(i3, e3, l3);
      });
    }, animateExitingElements: function() {
      return h3.forEach(function(t3) {
        return t3();
      }), u2;
    } };
  }(u$2({}, z2, { unflippedIds: J2 })), Q2 = G2.hideEnteringElements, Z2 = G2.animateEnteringElements, $ = G2.animateExitingElements, tt3 = u$2({}, z2, { containerEl: b2, flippedIds: g2.filter(H2), applyTransformOrigin: I2, spring: O2, debug: w2, staggerConfig: j2, scopedSelector: X2, onComplete: q2 });
  W2 && W2(b2, N2);
  var et2 = function(l3) {
    var d3, h3 = l3.flippedIds, g3 = l3.flipCallbacks, y3 = l3.inProgressAnimations, _3 = l3.flippedElementPositionsBeforeUpdate, S3 = l3.flippedElementPositionsAfterUpdate, E3 = l3.applyTransformOrigin, A3 = l3.spring, C3 = l3.getElement, b3 = l3.debug, I3 = l3.staggerConfig, O3 = I3 === void 0 ? {} : I3, w3 = l3.decisionData, x3 = w3 === void 0 ? {} : w3, T2 = l3.onComplete, D2 = l3.containerEl, M2 = new Promise(function(t2) {
      d3 = t2;
    });
    if (T2 && M2.then(function() {
      return T2(D2, x3);
    }), !h3.length)
      return function() {
        return d3([]), M2;
      };
    var k3 = [], j3 = C3(h3[0]), B3 = j3 ? j3.ownerDocument.querySelector("body") : document.querySelector("body"), N3 = (c$3(h3), h3.map(function(l4) {
      var c2 = _3[l4].rect, h4 = S3[l4].rect, C4 = _3[l4].opacity, b4 = S3[l4].opacity, I4 = h4.width < 1 || h4.height < 1, O4 = S3[l4].element;
      if (!P$1(c2) && !P$1(h4))
        return false;
      if (!O4)
        return false;
      var w4, U2, V2, T3 = R$2(O4), D3 = (V2 = (U2 = (w4 = { flipperSpring: A3, flippedSpring: T3.spring }) === void 0 ? {} : w4).flippedSpring, u$2({}, m$3.noWobble, v$1(U2.flipperSpring), v$1(V2))), M3 = T3.stagger === true ? "default" : T3.stagger, j4 = { element: O4, id: l4, stagger: M3, springConfig: D3 };
      if (g3[l4] && g3[l4].shouldFlip && !g3[l4].shouldFlip(x3.previous, x3.current))
        return false;
      var L4 = Math.abs(c2.left - h4.left) + Math.abs(c2.top - h4.top), q4 = Math.abs(c2.width - h4.width) + Math.abs(c2.height - h4.height), W4 = Math.abs(b4 - C4);
      if (c2.height === 0 && h4.height === 0 || c2.width === 0 && h4.width === 0 || L4 < 0.5 && q4 < 0.5 && W4 < 0.01)
        return false;
      var K4 = parse$1(S3[l4].transform), X4 = { matrix: K4 }, Y4 = { matrix: [] }, H3 = [K4];
      T3.translate && (H3.push(translateX(c2.left - h4.left)), H3.push(translateY(c2.top - h4.top))), T3.scale && (H3.push(scaleX(Math.max(c2.width, 1) / Math.max(h4.width, 1))), H3.push(scaleY(Math.max(c2.height, 1) / Math.max(h4.height, 1)))), T3.opacity && (Y4.opacity = C4, X4.opacity = b4);
      var J3 = [];
      if (!g3[l4] || !g3[l4].shouldInvert || g3[l4].shouldInvert(x3.previous, x3.current)) {
        var z3 = function(t2, e2) {
          return p$2(t2.querySelectorAll('[data-inverse-flip-id="' + e2 + '"]'));
        }(O4, l4);
        J3 = z3.map(function(t2) {
          return [t2, R$2(t2)];
        });
      }
      Y4.matrix = F(H3.reduce(multiply)), X4.matrix = F(X4.matrix);
      var G3, Q3 = function(t2) {
        var e2 = t2.element, i2 = t2.invertedChildren, n2 = t2.body;
        return function(t3) {
          var r2 = t3.matrix, s2 = t3.opacity, o2 = t3.forceMinVals;
          if (a$1(s2) && (e2.style.opacity = s2 + ""), o2 && (e2.style.minHeight = "1px", e2.style.minWidth = "1px"), r2) {
            var l5 = function(t4) {
              return "matrix(" + t4.join(", ") + ")";
            }(r2);
            e2.style.transform = l5, i2 && function(t4) {
              var e3 = t4.matrix, i3 = t4.body;
              t4.invertedChildren.forEach(function(t5) {
                var n3 = t5[0], r3 = t5[1];
                if (i3.contains(n3)) {
                  var s3 = e3[0], a2 = e3[3], o3 = e3[5], l6 = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }, p2 = "";
                  r3.translate && (l6.translateX = -e3[4] / s3, l6.translateY = -o3 / a2, p2 += "translate(" + l6.translateX + "px, " + l6.translateY + "px)"), r3.scale && (l6.scaleX = 1 / s3, l6.scaleY = 1 / a2, p2 += " scale(" + l6.scaleX + ", " + l6.scaleY + ")"), n3.style.transform = p2;
                }
              });
            }({ invertedChildren: i2, matrix: r2, body: n2 });
          }
        };
      }({ element: O4, invertedChildren: J3, body: B3 });
      if (g3[l4] && g3[l4].onComplete) {
        var Z3 = g3[l4].onComplete;
        G3 = function() {
          return Z3(O4, x3);
        };
      }
      var $2 = a$1(Y4.opacity) && a$1(X4.opacity) && Y4.opacity !== X4.opacity, tt4 = false;
      return u$2({}, j4, { stagger: M3, springConfig: D3, getOnUpdateFunc: function(t2) {
        var e2 = t2.spring, i2 = t2.onAnimationEnd;
        return y3[l4] = { destroy: e2.destroy.bind(e2), onAnimationEnd: i2 }, function(t3) {
          g3[l4] && g3[l4].onSpringUpdate && g3[l4].onSpringUpdate(t3.getCurrentValue()), tt4 || (tt4 = true, g3[l4] && g3[l4].onStart && g3[l4].onStart(O4, x3));
          var e3 = t3.getCurrentValue();
          if (B3.contains(O4)) {
            var i3 = { matrix: [] };
            i3.matrix = Y4.matrix.map(function(t4, i4) {
              return f$3(t4, X4.matrix[i4], e3);
            }), $2 && (i3.opacity = f$3(Y4.opacity, X4.opacity, e3)), Q3(i3);
          } else
            t3.destroy();
        };
      }, initializeFlip: function() {
        Q3({ matrix: Y4.matrix, opacity: $2 ? Y4.opacity : void 0, forceMinVals: I4 }), g3[l4] && g3[l4].onStartImmediate && g3[l4].onStartImmediate(O4, x3), T3.transformOrigin ? O4.style.transformOrigin = T3.transformOrigin : E3 && (O4.style.transformOrigin = "0 0"), J3.forEach(function(t2) {
          var e2 = t2[0], i2 = t2[1];
          i2.transformOrigin ? e2.style.transformOrigin = i2.transformOrigin : E3 && (e2.style.transformOrigin = "0 0");
        });
      }, onAnimationEnd: function(t2) {
        delete y3[l4], o$1(G3) && G3(), O4.style.transform = "", J3.forEach(function(t3) {
          t3[0].style.transform = "";
        }), I4 && O4 && (O4.style.minHeight = "", O4.style.minWidth = ""), t2 || (k3.push(l4), k3.length >= N3.length && d3(k3));
      }, delayUntil: T3.delayUntil });
    }).filter(Boolean));
    if (N3.forEach(function(t2) {
      return (0, t2.initializeFlip)();
    }), b3)
      return function() {
      };
    var L3 = N3.filter(function(t2) {
      return t2.delayUntil && (e2 = t2.delayUntil, N3.filter(function(t3) {
        return t3.id === e2;
      }).length);
      var e2;
    }), q3 = {}, W3 = {}, K3 = {};
    L3.forEach(function(t2) {
      t2.stagger ? (K3[t2.stagger] = true, W3[t2.delayUntil] ? W3[t2.delayUntil].push(t2.stagger) : W3[t2.delayUntil] = [t2.stagger]) : q3[t2.delayUntil] ? q3[t2.delayUntil].push(t2) : q3[t2.delayUntil] = [t2];
    });
    var X3 = N3.filter(function(t2) {
      return t2.stagger;
    }).reduce(function(t2, e2) {
      return t2[e2.stagger] ? t2[e2.stagger].push(e2) : t2[e2.stagger] = [e2], t2;
    }, {}), Y3 = N3.filter(function(t2) {
      return L3.indexOf(t2) === -1;
    });
    return Y3.forEach(function(t2) {
      t2.onSpringActivate = function() {
        q3[t2.id] && q3[t2.id].forEach(U), W3[t2.id] && Object.keys(W3[t2.id].reduce(function(t3, e2) {
          var i2;
          return u$2(t3, ((i2 = {})[e2] = true, i2));
        }, {})).forEach(function(t3) {
          V(X3[t3], O3[t3]);
        });
      };
    }), function() {
      return N3.length || d3([]), Y3.filter(function(t2) {
        return !t2.stagger;
      }).forEach(U), Object.keys(X3).forEach(function(t2) {
        K3[t2] || V(X3[t2], O3[t2]);
      }), M2;
    };
  }(tt3);
  L2 ? L2({ hideEnteringElements: Q2, animateEnteringElements: Z2, animateExitingElements: $, animateFlippedElements: et2 }) : (Q2(), $().then(Z2), et2());
}, j = function(t2) {
  var e2 = t2.element, i2 = t2.flipCallbacks, n2 = i2 === void 0 ? {} : i2, r2 = t2.inProgressAnimations, s2 = r2 === void 0 ? {} : r2, a2 = D$1(e2, t2.portalKey), o2 = p$2(e2.querySelectorAll("[data-inverse-flip-id]")), l2 = {}, c2 = [], d2 = {};
  a2.filter(function(t3) {
    return n2 && n2[t3.dataset.flipId] && n2[t3.dataset.flipId].onExit;
  }).forEach(function(t3) {
    var e3 = t3.parentNode;
    if (t3.closest) {
      var i3 = t3.closest("[data-exit-container]");
      i3 && (e3 = i3);
    }
    var n3 = c2.findIndex(function(t4) {
      return t4[0] === e3;
    });
    n3 === -1 && (c2.push([e3, e3.getBoundingClientRect()]), n3 = c2.length - 1), l2[t3.dataset.flipId] = c2[n3][1], d2[t3.dataset.flipId] = e3;
  });
  var f2 = M$1(a2), h2 = f2.map(function(t3) {
    var e3 = t3[0], i3 = t3[1], r3 = {};
    if (n2 && n2[e3.dataset.flipId] && n2[e3.dataset.flipId].onExit) {
      var s3 = l2[e3.dataset.flipId];
      u$2(r3, { element: e3, parent: d2[e3.dataset.flipId], childPosition: { top: i3.top - s3.top, left: i3.left - s3.left, width: i3.width, height: i3.height } });
    }
    return [e3.dataset.flipId, { rect: i3, opacity: parseFloat(window.getComputedStyle(e3).opacity || "1"), domDataForExitAnimations: r3 }];
  }).reduce(T$1, {});
  return function(t3, e3) {
    Object.keys(t3).forEach(function(e4) {
      t3[e4].destroy && t3[e4].destroy(), t3[e4].onAnimationEnd && t3[e4].onAnimationEnd(true), delete t3[e4];
    }), e3.forEach(function(t4) {
      t4.style.transform = "", t4.style.opacity = "";
    });
  }(s2, a2.concat(o2)), { flippedElementPositions: h2, cachedOrderedFlipIds: f2.map(function(t3) {
    return t3[0].dataset.flipId;
  }) };
};
new O$1();
function c$2(e2, t2) {
  if (e2 == null)
    return {};
  var r2, n2, i2 = {}, o2 = Object.keys(e2);
  for (n2 = 0; n2 < o2.length; n2++)
    t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
  return i2;
}
var d$1 = react.exports.createContext({}), f$2 = react.exports.createContext("portal"), u$1 = function(t2) {
  var r2, n2;
  function i2() {
    var e2;
    return (e2 = t2.apply(this, arguments) || this).inProgressAnimations = {}, e2.flipCallbacks = {}, e2.el = void 0, e2;
  }
  n2 = t2, (r2 = i2).prototype = Object.create(n2.prototype), r2.prototype.constructor = r2, r2.__proto__ = n2;
  var l2 = i2.prototype;
  return l2.getSnapshotBeforeUpdate = function(e2) {
    return e2.flipKey !== this.props.flipKey && this.el ? j({ element: this.el, flipCallbacks: this.flipCallbacks, inProgressAnimations: this.inProgressAnimations, portalKey: this.props.portalKey }) : null;
  }, l2.componentDidUpdate = function(e2, t3, r3) {
    this.props.flipKey !== e2.flipKey && this.el && k({ flippedElementPositionsBeforeUpdate: r3.flippedElementPositions, cachedOrderedFlipIds: r3.cachedOrderedFlipIds, containerEl: this.el, inProgressAnimations: this.inProgressAnimations, flipCallbacks: this.flipCallbacks, applyTransformOrigin: this.props.applyTransformOrigin, spring: this.props.spring, debug: this.props.debug, portalKey: this.props.portalKey, staggerConfig: this.props.staggerConfig, handleEnterUpdateDelete: this.props.handleEnterUpdateDelete, decisionData: { previous: e2.decisionData, current: this.props.decisionData }, onComplete: this.props.onComplete, onStart: this.props.onStart });
  }, l2.render = function() {
    var t3 = this, r3 = this.props, n3 = r3.portalKey, i3 = e$3.createElement(d$1.Provider, { value: this.flipCallbacks }, e$3.createElement(r3.element, { className: r3.className, ref: function(e2) {
      return t3.el = e2;
    } }, this.props.children));
    return n3 && (i3 = e$3.createElement(f$2.Provider, { value: n3 }, i3)), i3;
  }, i2;
}(react.exports.Component);
u$1.defaultProps = { applyTransformOrigin: true, element: "div" };
var h$2 = function(e2) {
  var t2, r2 = e2.children, o2 = e2.flipId, p2 = e2.inverseFlipId, s2 = e2.portalKey, d2 = c$2(e2, ["children", "flipId", "inverseFlipId", "portalKey"]), f2 = r2, u2 = function(e3) {
    return typeof e3 == "function";
  }(f2);
  if (!u2)
    try {
      f2 = react.exports.Children.only(r2);
    } catch (e3) {
      throw new Error("Each Flipped component must wrap a single child");
    }
  d2.scale || d2.translate || d2.opacity || h$3.assign(d2, { translate: true, scale: true, opacity: true });
  var h2 = ((t2 = {})[g$2.DATA_FLIP_CONFIG] = JSON.stringify(d2), t2);
  return o2 !== void 0 ? h2[g$2.DATA_FLIP_ID] = String(o2) : p2 && (h2[g$2.DATA_INVERSE_FLIP_ID] = String(p2)), s2 !== void 0 && (h2[g$2.DATA_PORTAL_KEY] = s2), u2 ? f2(h2) : react.exports.cloneElement(f2, h2);
}, m$2 = function(t2) {
  var r2 = t2.children, n2 = t2.flipId, i2 = t2.shouldFlip, o2 = t2.shouldInvert, p2 = t2.onAppear, a2 = t2.onStart, s2 = t2.onStartImmediate, u2 = t2.onComplete, m2 = t2.onExit, g2 = t2.onSpringUpdate, y2 = c$2(t2, ["children", "flipId", "shouldFlip", "shouldInvert", "onAppear", "onStart", "onStartImmediate", "onComplete", "onExit", "onSpringUpdate"]);
  return r2 ? y2.inverseFlipId ? e$3.createElement(h$2, Object.assign({}, y2), r2) : e$3.createElement(f$2.Consumer, null, function(t3) {
    return e$3.createElement(d$1.Consumer, null, function(c2) {
      return h$3.isObject(c2) && n2 && (c2[n2] = { shouldFlip: i2, shouldInvert: o2, onAppear: p2, onStart: a2, onStartImmediate: s2, onComplete: u2, onExit: m2, onSpringUpdate: g2 }), e$3.createElement(h$2, Object.assign({ flipId: n2 }, y2, { portalKey: t3 }), r2);
    });
  }) : null;
};
m$2.displayName = "Flipped";
function PreviewAddFloating({
  onClick,
  style: style2
}) {
  return /* @__PURE__ */ jsx(Button$6, {
    onClick,
    style: style2,
    children: /* @__PURE__ */ jsx("span", {
      children: "Ajouter un bloc"
    })
  });
}
const Button$6 = /* @__PURE__ */ createStyled(UnstyledButton, {
  target: "e1xk7vdw0"
})({
  name: "p94mvf",
  styles: "position:relative;margin-top:-40px;margin-bottom:-40px;opacity:0;width:100%;height:80px;display:flex;align-items:center;justify-content:center;z-index:101;background-color:transparent;border:none;transition:opacity .3s;&:hover{opacity:1;}&::before{content:'';height:2px;width:100%;position:absolute;top:calc(50% - 1px);left:0;z-index:101;background-color:var(--ve-primary);}&::after{content:'+';font-size:1.5em;z-index:101;width:40px;height:40px;background:var(--ve-primary);display:flex;align-items:center;justify-content:center;color:#FFF;border-radius:40px;transition:transform .3s;}& span{pointer-events:none;font-size:15px;height:34px;background:var(--ve-primary);padding:0 .5em;display:flex;align-items:center;position:absolute;left:50%;bottom:-30px;transform:translate(-50%, 5px);color:#FFF;transition:transform .3s;&::before{content:'';position:absolute;display:block;left:calc(50% - 6px);top:-6px;width:12px;height:12px;background:var(--bs-primary);transform:rotate(45deg);}}&:hover span{transform:translate(-50%, 0px);}"
});
function debounce(func, wait) {
  let timeout = null;
  return function executedFunction(...args) {
    const later = () => {
      timeout = null;
      func(...args);
    };
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = window.setTimeout(later, wait);
  };
}
function useEffectDebounced(callback, deps, time) {
  const callbackRef = react.exports.useRef(callback);
  const debouncedCallback = react.exports.useMemo(() => {
    return debounce((...args) => callbackRef.current(...args), time);
  }, []);
  callbackRef.current = callback;
  react.exports.useEffect(() => {
    debouncedCallback();
  }, deps);
}
function usePreview(data, previewUrl, initialHTML) {
  const [loading, setLoading] = react.exports.useState(false);
  const [html, setHTML] = react.exports.useState(initialHTML);
  const isFirstRender = react.exports.useRef(!!initialHTML);
  useEffectDebounced(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    const timer = window.setTimeout(() => setLoading(true), 200);
    fetch(previewUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify(__spreadProps(__spreadValues({}, data), {
        preview: true
      }))
    }).then((r2) => r2.text()).then(setHTML).finally(() => {
      clearTimeout(timer);
      setLoading(false);
    });
    return () => clearTimeout(timer);
  }, [data], 500);
  return {
    loading,
    html
  };
}
function PreviewItem({
  data,
  initialHTML,
  previewUrl,
  title
}) {
  const ref = react.exports.useRef(null);
  const {
    loading,
    html
  } = usePreview(data, previewUrl, initialHTML);
  const setFocusIndex = useSetFocusIndex();
  const isFocused = useFieldFocused(data._id);
  react.exports.useEffect(() => {
    if (isFocused) {
      const top2 = offsetTop(ref.current) - 40;
      const root = ref.current.closest("html");
      root.scrollTop = top2;
    }
  }, [isFocused]);
  return /* @__PURE__ */ jsx(m$2, {
    flipId: data._id,
    children: /* @__PURE__ */ jsxs(PreviewItemWrapper, {
      id: `previewItem${data._id}`,
      isFocused,
      ref,
      onClick: () => setFocusIndex(data._id),
      children: [loading && /* @__PURE__ */ jsx(StyledSpinner, {
        size: 12
      }), /* @__PURE__ */ jsx(PreviewItemTitle, {
        isFocused,
        children: title
      }), /* @__PURE__ */ jsx("div", {
        dangerouslySetInnerHTML: {
          __html: html
        }
      })]
    })
  });
}
const PreviewItemWrapper = createStyled("div", {
  target: "e1c7pr7s2"
})("position:relative;cursor:pointer;&:hover{border-color:var(--ve-primary);}&::before{content:'';position:absolute;inset:0;border-style:solid;border-color:transparent;z-index:10;}&:hover::before{border-color:var(--ve-primary);}", ({
  isFocused
}) => ({
  "&::before": {
    borderWidth: isFocused ? 2 : 1,
    borderColor: isFocused ? "var(--ve-primary)" : "transparent"
  }
}), "");
const PreviewItemTitle = createStyled("div", {
  target: "e1c7pr7s1"
})("position:absolute;top:0;left:0;background-color:var(--ve-primary);color:#FFF;padding:.2rem .4rem;border-top-left-radius:5px;border-top-right-radius:5px;opacity:0;transform:translateY(calc(1px - 100%));*:hover > &{opacity:1;}", ({
  isFocused
}) => ({
  opacity: isFocused ? 1 : 0
}), "");
const StyledSpinner = /* @__PURE__ */ createStyled(Spinner, {
  target: "e1c7pr7s0"
})({
  name: "7xu5g",
  styles: "top:1rem;right:1rem;left:auto;bottom:auto;color:var(--ve-primary)"
});
function PreviewAddButton({
  onClick
}) {
  return /* @__PURE__ */ jsx(Wrapper$6, {
    children: /* @__PURE__ */ jsx(Button$7, {
      icon: IconCirclePlus,
      onClick,
      children: "Ajouter un bloc"
    })
  });
}
const Wrapper$6 = createStyled("div", {
  target: "e7x7kav0"
})({
  name: "1rh8xtt",
  styles: "background-color:transparent;border:2px dashed var(--ve-field-border);display:flex;align-items:center;justify-content:center;font-weight:bold;color:var(--ve-color);width:calc(100% - 2rem);margin:1rem;padding:1rem"
});
function PreviewItems({
  data,
  initialHTML = {},
  previewUrl
}) {
  const setAddBlockIndex = useSetBlockIndex();
  const definitions = useFieldDefinitions();
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(u$1, {
      flipKey: data.map((d2) => d2._id).join("_"),
      children: data.map((v2, k2) => {
        var _a;
        return /* @__PURE__ */ jsxs("div", {
          children: [/* @__PURE__ */ jsx(PreviewAddFloating, {
            onClick: prevent(() => setAddBlockIndex(k2))
          }), /* @__PURE__ */ jsx(PreviewItem, {
            title: ((_a = definitions[v2._name]) == null ? void 0 : _a.title) || "",
            data: v2,
            initialHTML: initialHTML[v2._id] || "",
            previewUrl
          })]
        }, v2._id);
      })
    }), /* @__PURE__ */ jsx(PreviewAddButton, {
      onClick: () => setAddBlockIndex(data.length)
    })]
  });
}
var _ref$6 = {
  name: "1elmght",
  styles: "color:white;opacity:0.6"
};
function Preview({
  data,
  previewUrl
}) {
  const iframe = react.exports.useRef(null);
  const [iframeRoot, setIframeRoot] = react.exports.useState(null);
  const initialHTML = react.exports.useRef({});
  const [loaded, setLoaded] = react.exports.useState(false);
  const showSpinner = !loaded;
  useAsyncEffect(async () => {
    const r2 = await fetch(previewUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify(data)
    });
    if (!r2.ok) {
      return;
    }
    const iframeDocument = iframe.current.contentDocument;
    iframeDocument.open();
    iframeDocument.write(await r2.text());
    iframeDocument.close();
    const root = iframeDocument.querySelector("#ve-components");
    initialHTML.current = Array.from(root.children).reduce((acc, v2, k2) => __spreadProps(__spreadValues({}, acc), {
      [data[k2]._id]: v2.outerHTML
    }), {});
    root.innerHTML = "";
    setIframeRoot(root);
  }, []);
  const previewMode = usePreviewMode();
  const {
    height: windowHeight
  } = useWindowSize$1();
  let transform = void 0;
  if (previewMode === PreviewModes.PHONE && windowHeight < 844) {
    transform = {
      transform: `scale(${windowHeight / PHONE_HEIGHT})`
    };
  }
  return /* @__PURE__ */ jsxs(PreviewWrapper$1, {
    children: [showSpinner && /* @__PURE__ */ jsx(Spinner, {
      css: _ref$6
    }), /* @__PURE__ */ jsx(StyledIframe, {
      loaded,
      mobile: previewMode === PreviewModes.PHONE,
      ref: iframe,
      style: transform,
      onLoad: () => setLoaded(true)
    }), iframeRoot && reactDom.exports.createPortal(/* @__PURE__ */ jsx(FrameProvider, {
      container: iframe.current.contentDocument,
      children: /* @__PURE__ */ jsx(BaseStyles, {
        complete: false,
        children: /* @__PURE__ */ jsx(PreviewItems, {
          data,
          initialHTML: initialHTML.current,
          previewUrl
        })
      })
    }), iframeRoot)]
  });
}
const Out$1 = keyframes({
  from: {
    transform: "translateX(0)",
    opacity: 1
  },
  to: {
    transform: "translateX(50px)",
    opacity: 0
  }
});
const In$2 = keyframes({
  from: {
    transform: "translateX(50px)",
    opacity: 0
  },
  to: {
    transform: "translateX(0)",
    opacity: 1
  }
});
const PreviewWrapper$1 = createStyled("div", {
  target: "eccll7f1"
})({
  width: "100%",
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  animation: `${In$2} .7s cubic-bezier(0.19, 1, 0.22, 1) both`,
  '[hidden="hidden"] &': {
    animationName: `${Out$1}`
  }
}, "");
const StyledIframe = createStyled("iframe", {
  target: "eccll7f0"
})("transform-origin:50% 50%;border:none;color:var(--ve-primary);transition:width .3s, height .3s, opacity .5s;", (props) => ({
  opacity: props.loaded ? 1 : 0,
  width: props.mobile ? "390px" : "100%",
  height: props.mobile ? "844px" : "100%"
}), "");
function ResizeBar() {
  const [drag, setDrag] = react.exports.useState(false);
  const setSidebarWidth = useSetSidebarWidth();
  const handleMouseDown = (e2) => {
    e2.stopPropagation();
    e2.preventDefault();
    setDrag(true);
    const listener = (e22) => {
      setSidebarWidth(Math.round(100 * e22.clientX / window.innerWidth));
    };
    document.documentElement.addEventListener("mousemove", listener);
    document.documentElement.addEventListener("mouseup", () => {
      setDrag(false);
      document.documentElement.removeEventListener("mousemove", listener);
    }, {
      once: true
    });
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Wrapper$5, {
      isDragging: drag,
      onMouseDown: handleMouseDown
    }), drag && /* @__PURE__ */ jsx(ResizeBarOverlay, {})]
  });
}
const Wrapper$5 = createStyled("div", {
  target: "e8mscdn1"
})("position:fixed;top:0;bottom:0;height:100%;left:var(--ve-clampedSidebar);width:15px;z-index:1002;cursor:ew-resize;transition:box-shadow .3s;:hover{box-shadow:-1px -1px 0 1px var(--ve-primary);}", ({
  isDragging
}) => isDragging ? {
  boxShadow: "-1px -1px 0 1px var(--ve-primary)"
} : null, "");
const ResizeBarOverlay = createStyled("div", {
  target: "e8mscdn0"
})({
  name: "1rfie70",
  styles: "position:fixed;top:0;left:0;width:100%;height:100%;z-index:1001"
});
function BlocSelectorItem({
  definition,
  name,
  iconsUrl,
  onClick
}) {
  const icon = iconsUrl.replace("[name]", name);
  const title = definition.title;
  return /* @__PURE__ */ jsxs(Button$5, {
    onClick: prevent(onClick),
    children: [/* @__PURE__ */ jsx(ButtonImage, {
      children: /* @__PURE__ */ jsx("img", {
        src: icon,
        alt: ""
      })
    }), /* @__PURE__ */ jsx("div", {
      children: title
    })]
  });
}
const Button$5 = createStyled("button", {
  target: "etyz0221"
})({
  name: "xggmpv",
  styles: "background-color:transparent;border:none;display:flex;flex-direction:column;gap:1rem;font:inherit;font-weight:500;cursor:pointer;transition:.3s;&:hover, &:focus{outline:none;color:var(--ve-primary);& img{transform:translateY(-5px);}}"
});
const ButtonImage = createStyled("div", {
  target: "etyz0220"
})({
  width: "100%",
  backgroundColor: "var(--ve-hover)",
  height: 107,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  transition: ".3s",
  img: {
    width: 120,
    height: 80,
    objectFit: "contain",
    borderRadius: 4,
    transition: "transform .3s"
  },
  "&::after": {
    content: "''",
    position: "absolute",
    inset: 0,
    opacity: 0,
    background: "var(--ve-primary)",
    mixBlendMode: "saturation",
    borderRadius: 4,
    transition: "opacity .3s"
  },
  [`button:hover &::after, button:focus &::after`]: {
    opacity: 1
  },
  [`button:focus &`]: {
    transition: "none",
    border: "2px solid var(--ve-primary)"
  }
}, "");
const Wrapper$4 = createStyled("div", {
  target: "ekm0i7p1"
})({
  name: "1d2bqma",
  styles: "position:relative;float:right;svg{position:absolute;left:1rem;top:50%;color:var(--ve-color-light);transform:translateY(-50%);}"
});
const Input$1 = createStyled("input", {
  target: "ekm0i7p0"
})({
  height: 40,
  background: "var(--ve-hover)",
  borderRadius: 40,
  padding: "0 1rem 0 2.6rem",
  border: "1px solid transparent",
  font: "inherit",
  "&:focus": Styles.FocusState
}, "");
function BlocSelectorSearch({
  value,
  onChange
}) {
  return /* @__PURE__ */ jsxs(Wrapper$4, {
    children: [/* @__PURE__ */ jsx(Input$1, {
      type: "search",
      placeholder: t$2("searchComponent"),
      value,
      onChange: (e2) => onChange(e2.target.value)
    }), /* @__PURE__ */ jsx(IconSearch, {
      size: 14
    })]
  });
}
const BlocSelectorGrid = /* @__PURE__ */ createStyled(Tabs$1.Tab, {
  target: "ewyh3qs0"
})({
  name: "1dbqzqt",
  styles: "display:grid;grid-template-columns:repeat(auto-fit, 218px);gap:2rem;overflow:auto;max-height:calc(100vh - 300px);margin-top:2rem;align-content:flex-start;height:700px;&::-webkit-scrollbar{width:7px;height:7px;}&::-webkit-scrollbar-track{background:var(--ve-hover);padding:1px;}&::-webkit-scrollbar-thumb{background:var(--ve-field-border);border-radius:4px;}&[hidden]{display:none;}"
});
const ALL_TAB = "Tous les blocs";
var _ref$5 = {
  name: "di48ht",
  styles: "margin:1.5rem 0"
};
function BlocSelector({
  iconsUrl
}) {
  const isVisible = useBlocSelectionVisible();
  const setBlockIndex = useSetBlockIndex();
  const [search, setSearch] = react.exports.useState("");
  const definitions = useFieldDefinitions();
  const hiddenCategories = useHiddenCategories();
  const addBlock = useAddBlock();
  const categories = react.exports.useMemo(() => {
    return [ALL_TAB, ...Object.values(definitions).filter((d2) => d2.category).filter((d2) => {
      var _a;
      return !hiddenCategories.includes((_a = d2.category) != null ? _a : "");
    }).reduce((acc, d2) => acc.includes(d2.category) ? acc : [...acc, d2.category], [])];
  }, [definitions]);
  react.exports.useEffect(() => {
    setSearch("");
  }, [isVisible]);
  if (!isVisible) {
    return null;
  }
  const handleVisibilityChange = (v2) => {
    setBlockIndex(null);
  };
  return /* @__PURE__ */ jsxs(Modal, {
    visible: isVisible,
    onVisibilityChange: handleVisibilityChange,
    title: t$2("addComponent"),
    children: [/* @__PURE__ */ jsx(BlocSelectorSearch, {
      value: search,
      onChange: setSearch
    }), /* @__PURE__ */ jsx(Tabs$1, {
      css: _ref$5,
      children: categories.map((category) => /* @__PURE__ */ jsx(BlocSelectorGrid, {
        title: category,
        children: Object.keys(definitions).filter((key) => {
          var _a;
          return !hiddenCategories.includes((_a = definitions[key].category) != null ? _a : "");
        }).filter(searchDefinition(search != null ? search : "", category, definitions)).map((key) => /* @__PURE__ */ jsx(BlocSelectorItem, {
          definition: definitions[key],
          name: key,
          iconsUrl,
          onClick: () => addBlock(key)
        }, key))
      }, category))
    })]
  });
}
function searchDefinition(search, category, definitions) {
  return (key) => {
    const categoryFilter = category === ALL_TAB ? true : definitions[key].category === category;
    const searchFilter = search === "" ? true : definitions[key].title.toLowerCase().includes(search.toLowerCase());
    return categoryFilter && searchFilter;
  };
}
function RollbackMessage() {
  const {
    message: rollbackMessage,
    rollback,
    voidRollback
  } = useRollbackMessage();
  return /* @__PURE__ */ jsx(Flash, {
    action: t$2("rollback"),
    onClick: rollback,
    duration: 3,
    onHide: voidRollback,
    children: rollbackMessage
  });
}
function SidebarToggleButton({
  collapsed,
  onClick
}) {
  return /* @__PURE__ */ jsx(Button$4, {
    onClick: prevent(onClick),
    collapsed,
    children: /* @__PURE__ */ jsx(IconBack, {
      size: 20
    })
  });
}
const Button$4 = /* @__PURE__ */ createStyled(ButtonIcon, {
  target: "erpda1x0"
})("position:absolute;top:10px;z-index:1001;box-shadow:var(--ve-field-shadow);border:1px solid var(--ve-hover);transition:opacity .3s;&:hover{opacity:1;}", (props) => ({
  left: props.collapsed ? "1em" : "calc(var(--ve-clampedSidebar) + 1em)",
  opacity: props.collapsed ? 1 : 0,
  transform: props.collapsed ? "rotate(180deg)" : "none"
}), "");
function PreviewPostMessage({
  data,
  previewUrl
}) {
  const iframe = react.exports.useRef(null);
  const [loaded, setLoaded] = react.exports.useState(false);
  const previewMode = usePreviewMode();
  const {
    height: windowHeight
  } = useWindowSize$1();
  let transform = void 0;
  const setFocusIndex = useSetFocusIndex();
  const setAddBlockIndex = useSetBlockIndex();
  const focusIndex = useFocusIndex();
  const previewUrlRef = react.exports.useRef(previewUrl);
  previewUrlRef.current = previewUrl;
  if (previewMode === PreviewModes.PHONE && windowHeight < 844) {
    transform = {
      transform: `scale(${windowHeight / PHONE_HEIGHT})`
    };
  }
  react.exports.useEffect(() => {
    const listener = (e2) => {
      if (e2.data.type === "ve-focus") {
        setFocusIndex(e2.data.payload.id);
      } else if (e2.data.type === "ve-add") {
        console.log({
          id: e2.data.payload.id
        });
        setAddBlockIndex(e2.data.payload.id);
      }
    };
    window.addEventListener("message", listener);
    return () => {
      window.removeEventListener("message", listener);
    };
  }, []);
  react.exports.useEffect(() => {
    if (loaded && iframe.current && iframe.current.contentWindow) {
      iframe.current.contentWindow.postMessage({
        type: "ve-data",
        payload: data
      }, previewUrlRef.current);
    }
  }, [loaded, data]);
  react.exports.useEffect(() => {
    if (iframe.current && iframe.current.contentWindow) {
      iframe.current.contentWindow.postMessage({
        type: "ve-focus",
        payload: {
          id: focusIndex
        }
      }, previewUrlRef.current);
    }
  }, [focusIndex]);
  const previewURLWithReferrer = new URL(previewUrl);
  previewURLWithReferrer.searchParams.set("referrer", window.location.toString());
  return /* @__PURE__ */ jsx(PreviewWrapper$1, {
    children: /* @__PURE__ */ jsx(StyledIframe, {
      ref: iframe,
      src: previewURLWithReferrer.toString(),
      loaded,
      mobile: previewMode === PreviewModes.PHONE,
      style: transform,
      onLoad: () => setLoaded(true)
    })
  });
}
function Layout({
  data,
  previewUrl,
  onClose,
  iconsUrl
}) {
  const [sidebarCollapsed, toggleSidebar] = useToggle(false);
  const showResizeControl = !sidebarCollapsed;
  const PreviewComponent = VisualEditor.postMessagePreview ? PreviewPostMessage : Preview;
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: /* @__PURE__ */ jsxs(Wrapper$3, {
      withSidebar: !sidebarCollapsed,
      children: [/* @__PURE__ */ jsx(Sidebar, {
        data,
        onClose,
        css: /* @__PURE__ */ css({
          display: sidebarCollapsed ? "none" : void 0
        }, "", "")
      }), previewUrl && /* @__PURE__ */ jsx(PreviewComponent, {
        data,
        previewUrl
      }), /* @__PURE__ */ jsx(SidebarToggleButton, {
        collapsed: sidebarCollapsed,
        onClick: toggleSidebar
      }), showResizeControl && /* @__PURE__ */ jsx(ResizeBar, {}), /* @__PURE__ */ jsx(BlocSelector, {
        iconsUrl
      }), /* @__PURE__ */ jsx(RollbackMessage, {})]
    })
  });
}
function Wrapper$3(props) {
  const sidebarWidth2 = useSidebarWidth();
  return /* @__PURE__ */ jsx(StyledWrapper, __spreadProps(__spreadValues({}, props), {
    style: {
      "--ve-sidebar": `${sidebarWidth2}vw`
    }
  }));
}
const In$1 = keyframes({
  from: {
    backgroundColor: "rgba(255, 255, 255, 0)"
  },
  to: {
    backgroundColor: "var(--ve-field-border)"
  }
});
const Out = keyframes({
  from: {
    backgroundColor: "var(--ve-field-border)"
  },
  to: {
    backgroundColor: "rgba(255, 255, 255, 0)"
  }
});
const StyledWrapper = createStyled("div", {
  target: "e1vjeyik0"
})({
  isolation: "isolate",
  zIndex: 9999,
  fontSize: "15px",
  "--ve-sidebar": "600px",
  "--ve-clampedSidebar": "clamp(450px, var(--ve-sidebar), calc(100vw - 375px))",
  color: "var(--ve-color-light)",
  transition: "background-color .3s",
  position: "fixed",
  inset: "0",
  width: "100%",
  height: "100%",
  display: "grid",
  backgroundColor: "var(--ve-field-border)",
  animation: `${In$1} .7s cubic-bezier(0.19, 1, 0.22, 1) both`,
  '[hidden="hidden"] &': {
    animation: `${Out} .7s cubic-bezier(0.19, 1, 0.22, 1) both`
  },
  "& *": {
    "&::-webkit-scrollbar": {
      width: "7px",
      height: "7px"
    },
    "&::-webkit-scrollbar-track": {
      background: "transparent",
      padding: "1px"
    },
    "&::-webkit-scrollbar-thumb": {
      background: "var(--ve-field-border)",
      borderRadius: "4px"
    }
  }
}, (props) => ({
  gridTemplateColumns: props.withSidebar ? "var(--ve-clampedSidebar) 1fr" : "1fr"
}), "");
function useClipboardPaste(enabled) {
  const insertData = useInsertData();
  react.exports.useEffect(() => {
    if (!enabled) {
      return;
    }
    const listener = (event) => {
      try {
        let paste = (event.clipboardData || window.clipboardData).getData("text").trim();
        if (paste.startsWith("{")) {
          event.preventDefault();
          const data = JSON.parse(paste);
          if (data._name) {
            insertData(data._name, 0, indexify(data));
          }
        } else if (paste.startsWith("[")) {
          event.preventDefault();
          const data = JSON.parse(paste);
          if (data.length > 0) {
            for (let i2 = data.length - 1; i2 >= 0; i2--) {
              insertData(data[i2]._name, 0, indexify(data[i2]));
            }
          }
        }
      } catch (e2) {
      }
    };
    document.addEventListener("paste", listener);
    return () => {
      document.removeEventListener("paste", listener);
    };
  }, [insertData, enabled]);
}
function useStateDelayed(originalState, duration = 700, onlyOnFalse = true) {
  const [delayedState, setDelayedState] = react.exports.useState(originalState);
  react.exports.useEffect(() => {
    if (originalState && onlyOnFalse) {
      setDelayedState(originalState);
    } else {
      const timer = window.setTimeout(() => setDelayedState(originalState), 700);
      return () => window.clearTimeout(timer);
    }
  }, [originalState]);
  return delayedState;
}
const Translations$1 = {
  unknownComponent: "Unknown component",
  deleteComponent: "Remove component",
  copyPage: "Copier le code de la page",
  copyComponent: "Copy the component",
  searchComponent: "Search a component",
  copySuccess: "The code has been copied",
  copyInstructions: "You can paste the component on another page (CTRL + V)",
  addComponent: "Add a component",
  responsiveView: "Responsive view",
  addItem: "Add an item",
  deleteItem: "Remove item",
  rollback: "Restore",
  deleteItemConfirm: "The component has been deleted",
  save: "Save",
  close: "Close",
  noContent: `You have no content yet`,
  useTemplate: "Use a template",
  poweredBy: "Powered by"
};
const stopPropagation = (e2) => e2.stopPropagation();
function useStopPropagation(ref, eventNames) {
  react.exports.useEffect(() => {
    if (!ref.current) {
      return;
    }
    eventNames.map((eventName) => {
      ref.current.addEventListener(eventName, stopPropagation);
    });
    return () => {
      if (!ref.current) {
        return;
      }
      eventNames.map((eventName) => {
        ref.current.removeEventListener(eventName, stopPropagation);
      });
    };
  });
}
class PreviewWrapper extends HTMLElement {
  constructor() {
    super(...arguments);
    __publicField(this, "isFocused", false);
    __publicField(this, "root");
    __publicField(this, "referrer", () => {
      var _a;
      return (_a = new URL(document.location.toString()).searchParams.get("referrer")) != null ? _a : "";
    });
    __publicField(this, "onWrapperClick", () => {
      window.parent.postMessage({
        type: "ve-focus",
        payload: {
          id: this.dataset.id,
          parent: true
        }
      }, this.referrer());
    });
    __publicField(this, "onAddClick", (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      window.parent.postMessage({
        type: "ve-add",
        payload: {
          id: this.dataset.id
        }
      }, this.referrer());
    });
    __publicField(this, "onFocusChange", (e2) => {
      if (e2.data.type === "ve-focus") {
        const isFocused = e2.data.payload.id === this.dataset.id;
        if (isFocused !== this.isFocused) {
          this.isFocused = e2.data.payload.id === this.dataset.id;
          this.render();
        }
      }
    });
  }
  render() {
    if (!this.root) {
      return;
    }
    this.root.render(/* @__PURE__ */ jsxs(Reset, {
      complete: false,
      children: [/* @__PURE__ */ jsx(PreviewAddFloating, {
        onClick: this.onAddClick,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0
        }
      }), /* @__PURE__ */ jsx(PreviewItemWrapper, {
        isFocused: this.isFocused,
        style: {
          position: "absolute",
          inset: 0
        },
        onClick: this.onWrapperClick,
        children: this.dataset.name && /* @__PURE__ */ jsx(PreviewItemTitle, {
          isFocused: this.isFocused,
          children: this.dataset.name
        })
      })]
    }));
  }
  connectedCallback() {
    this.style.setProperty("position", "relative");
    this.style.setProperty("display", "block");
    window.addEventListener("message", this.onFocusChange);
    const div2 = document.createElement("div");
    this.appendChild(div2);
    this.root = createRoot(div2);
    this.render();
  }
  disconnectedCallback() {
    window.removeEventListener("message", this.onFocusChange);
  }
}
class AddButton extends HTMLElement {
  connectedCallback() {
    var _a;
    const div2 = document.createElement("div");
    this.appendChild(div2);
    const referrer = (_a = new URL(document.location.toString()).searchParams.get("referrer")) != null ? _a : "";
    const onAddClick = (e2) => {
      var _a2;
      e2.stopPropagation();
      e2.preventDefault();
      window.parent.postMessage({
        type: "ve-add",
        payload: {
          id: parseInt((_a2 = this.dataset.index) != null ? _a2 : "0")
        }
      }, referrer);
    };
    createRoot(div2).render(/* @__PURE__ */ jsx(Reset, {
      complete: true,
      children: /* @__PURE__ */ jsx(PreviewAddButton, {
        onClick: onAddClick
      })
    }));
  }
}
function useUniqId(prefix2 = "") {
  return react.exports.useMemo(() => prefix2 + uniqId(), []);
}
function defineField(args) {
  return (name, options = {}) => {
    const fieldArgs = typeof args === "function" ? args() : args;
    return __spreadProps(__spreadValues(__spreadValues({}, genericFieldDefinition(fieldArgs, options)), fieldArgs), {
      options: __spreadValues(__spreadValues({}, fieldArgs.defaultOptions), options),
      name,
      group: false
    });
  };
}
function defineFieldGroup(args) {
  return (fields, options = {}) => {
    return __spreadProps(__spreadValues({}, genericFieldDefinition(args, options)), {
      group: true,
      fields,
      render: args.render
    });
  };
}
function defaultFieldProperties() {
  return {
    conditions: [],
    shouldRender(data) {
      return this.conditions.filter((condition) => !condition(data)).length === 0;
    },
    when(fieldName, expectedValue = true) {
      return __spreadProps(__spreadValues({}, this), {
        conditions: [...this.conditions, (data) => {
          if (typeof expectedValue === "function") {
            return expectedValue(data[fieldName]);
          }
          return cast(data[fieldName], expectedValue) === expectedValue;
        }]
      });
    }
  };
}
function genericFieldDefinition(args, options) {
  return __spreadValues({
    options: __spreadValues(__spreadValues({}, args.defaultOptions), options)
  }, defaultFieldProperties());
}
const Component$c = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("textinput");
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    type: options.multiline ? "textarea" : "text",
    id: id2,
    value,
    onInput: (e2) => onChange(e2.target.value),
    help: options.help
  });
};
const Text$2 = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$c
});
const Component$b = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("checkbox");
  return /* @__PURE__ */ jsx(Field$1, {
    help: options.help,
    children: /* @__PURE__ */ jsxs(Wrapper$2, {
      children: [/* @__PURE__ */ jsx(Input, {
        type: "checkbox",
        id: id2,
        checked: value,
        onChange: () => onChange(!value)
      }), /* @__PURE__ */ jsx(Label, {
        htmlFor: id2,
        children: options.label
      })]
    })
  });
};
const Checkbox = defineField({
  defaultOptions: {
    label: "",
    default: false
  },
  render: Component$b
});
const Wrapper$2 = createStyled("div", {
  target: "e151718g1"
})({
  name: "8k1832",
  styles: "position:relative;display:flex"
});
const Input = /* @__PURE__ */ createStyled("input", {
  target: "ve-checkbox-input"
})({
  name: "zr2kbf",
  styles: "position:absolute;inset:0;opacity:0;cursor:pointer;z-index:5"
});
const Label = createStyled("label", {
  target: "e151718g0"
})({
  display: "flex",
  alignItems: "center",
  cursor: "pointer",
  lineHeight: 1,
  "&::before": {
    cursor: "pointer",
    display: "block",
    content: "''",
    width: "38px",
    height: "20px",
    border: "solid 1px var(--ve-field-border)",
    borderRadius: "18px",
    marginRight: ".5em",
    transition: ".3s"
  },
  "&::after": {
    position: "absolute",
    content: "''",
    top: "2px",
    left: "2px",
    borderRadius: "16px",
    width: "16px",
    height: "16px",
    backgroundColor: "var(--ve-color-light)",
    transition: ".3s"
  },
  [`${Input}:checked + &::before`]: {
    borderColor: "var(--ve-primary)",
    backgroundColor: "var(--ve-primary)"
  },
  [`${Input}:focus + &::before`]: {
    outline: "0",
    boxShadow: "0 0 0 0.25rem rgb(23 113 230 / 25%)"
  },
  [`${Input}:checked + &::after`]: {
    backgroundColor: "#FFF",
    transform: "translateX(17px)"
  }
}, "");
const Wrapper$1 = createStyled("div", {
  target: "esnz6933"
})({
  name: "1908g4q",
  styles: "display:flex;flex-direction:column;background-color:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 2px 0 rgba(0,0,0,0.05)"
});
const Item$1 = /* @__PURE__ */ createStyled(Sortable, {
  target: "esnz6932"
})({
  name: "3wafdo",
  styles: "position:relative;display:grid;grid-template-columns:1fr;gap:.5em;padding:.4rem .7rem .4rem calc(10px + .7rem);border-bottom:solid 1px rgba(0,0,0,0.06);background-color:#fff"
});
const ItemBody = createStyled("div", {
  target: "esnz6931"
})({
  name: "t117un",
  styles: "display:grid;grid-template-columns:1fr;gap:1em"
});
const Footer = createStyled("div", {
  target: "esnz6930"
})({
  name: "12p1ehp",
  styles: "display:flex;justify-content:flex-end;padding:.2rem;background-color:rgba(0,0,0,0.03)"
});
const Component$a = ({
  value: valueProps,
  onChange,
  options
}) => {
  const value = valueProps != null ? valueProps : [];
  const canAdd = !options.max || value.length < options.max;
  const canRemove = !options.min || value.length > options.min;
  const [lastAdditionIndex, setLastAdditionIndex] = react.exports.useState(-1);
  const add3 = () => {
    onChange([...value, fillDefaults({
      _id: uniqId()
    }, options.fields)]);
    setLastAdditionIndex(value.length);
  };
  const remove2 = (line2) => {
    onChange(value.filter((v2) => v2 !== line2));
  };
  const updateProperty = (v2, path) => {
    onChange(deepSet(value, path, v2));
  };
  function handleMove(from5, to) {
    onChange(moveItem(value, from5, to));
  }
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(SortableWrapper, {
      items: value,
      onMove: handleMove,
      children: /* @__PURE__ */ jsxs(Wrapper$1, {
        children: [value.map((line2, k2) => /* @__PURE__ */ jsx(FieldLine, {
          line: line2,
          index: k2,
          onUpdate: updateProperty,
          onRemove: canRemove ? remove2 : null,
          options,
          defaultCollapsed: lastAdditionIndex !== k2
        }, line2._id)), canAdd && /* @__PURE__ */ jsx(Footer, {
          children: /* @__PURE__ */ jsx(Button$7, {
            secondary: true,
            onClick: prevent(add3),
            icon: IconCirclePlus,
            children: options.addLabel
          })
        })]
      })
    })
  });
};
const FieldLine = ({
  line: line2,
  index: index3,
  onRemove,
  onUpdate,
  options,
  defaultCollapsed
}) => {
  const [collapsed, toggleCollapsed] = useToggle(defaultCollapsed);
  const title = options.collapsed ? line2[options.collapsed] : `#${index3 + 1}`;
  const escapedTitle = react.exports.useMemo(() => textContent(title), [title]);
  return /* @__PURE__ */ jsxs(Item$1, {
    item: line2,
    children: [/* @__PURE__ */ jsxs(SidebarHeading, {
      onClick: prevent(toggleCollapsed),
      title: escapedTitle,
      children: [/* @__PURE__ */ jsx(SidebarHeading.Hover, {
        children: onRemove && /* @__PURE__ */ jsx(ButtonIcon, {
          danger: true,
          onClick: () => onRemove(line2),
          title: t$2("deleteItem"),
          children: /* @__PURE__ */ jsx(IconTrash, {
            size: 20
          })
        })
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        rotate: collapsed ? -90 : 0,
        onClick: prevent(toggleCollapsed),
        children: /* @__PURE__ */ jsx(IconDown, {
          size: 24
        })
      })]
    }), !collapsed && /* @__PURE__ */ jsx(ItemBody, {
      children: /* @__PURE__ */ jsx(FieldsRenderer, {
        fields: options.fields,
        data: line2,
        onUpdate,
        path: index3.toString()
      })
    })]
  });
};
const Repeater = defineField(() => ({
  defaultOptions: {
    addLabel: t$2("addItem"),
    fields: [],
    default: []
  },
  render: Component$a
}));
var _ref$4 = {
  name: "18hed01",
  styles: "padding-right:40px"
};
const Component$9 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("imageinput");
  const handleBrowse = () => {
    options.onBrowse(value).then((v2) => {
      onChange(v2);
    }).catch((e2) => {
    });
  };
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    label: options.label,
    help: options.help,
    value,
    tooltip: value ? /* @__PURE__ */ jsx(TooltipImage, {
      src: value,
      alt: ""
    }) : void 0,
    onChange: (e2) => onChange(e2.target.value),
    css: _ref$4,
    icon: options.onBrowse ? /* @__PURE__ */ jsx(Button$3, {
      onClick: prevent(handleBrowse),
      children: /* @__PURE__ */ jsx(IconFolder, {
        size: 16
      })
    }) : void 0
  });
};
const ImageUrl = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$9
});
const Button$3 = /* @__PURE__ */ createStyled(ButtonIcon, {
  target: "efwrm0h1"
})({
  name: "fcl53z",
  styles: "width:32px;height:32px;color:var(--ve-color-light)"
});
const TooltipImage = createStyled("img", {
  target: "efwrm0h0"
})({
  name: "tw8fke",
  styles: "width:150px;height:150px;position:relative;z-index:2;object-fit:cover"
});
function OrderedMap(content2) {
  this.content = content2;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key)
        return i2;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content2 = self.content.slice();
    if (found2 == -1) {
      content2.push(newKey || key, value);
    } else {
      content2[found2 + 1] = value;
      if (newKey)
        content2[found2] = newKey;
    }
    return new OrderedMap(content2);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content2 = this.content.slice();
    content2.splice(found2, 2);
    return new OrderedMap(content2);
  },
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content2 = this.remove(key).content.slice();
    content2.push(key, value);
    return new OrderedMap(content2);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content2 = without.content.slice();
    var found2 = without.find(place);
    content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
    return new OrderedMap(content2);
  },
  forEach: function(f2) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f2(this.content[i2], this.content[i2 + 1]);
  },
  prepend: function(map14) {
    map14 = OrderedMap.from(map14);
    if (!map14.size)
      return this;
    return new OrderedMap(map14.content.concat(this.subtract(map14).content));
  },
  append: function(map14) {
    map14 = OrderedMap.from(map14);
    if (!map14.size)
      return this;
    return new OrderedMap(this.subtract(map14).content.concat(map14.content));
  },
  subtract: function(map14) {
    var result2 = this;
    map14 = OrderedMap.from(map14);
    for (var i2 = 0; i2 < map14.content.length; i2 += 2)
      result2 = result2.remove(map14.content[i2]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content2 = [];
  if (value)
    for (var prop in value)
      content2.push(prop, value[prop]);
  return new OrderedMap(content2);
};
var orderedmap = OrderedMap;
function findDiffStart(a2, b2, pos) {
  for (var i2 = 0; ; i2++) {
    if (i2 == a2.childCount || i2 == b2.childCount) {
      return a2.childCount == b2.childCount ? null : pos;
    }
    var childA = a2.child(i2), childB = b2.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j2 = 0; childA.text[j2] == childB.text[j2]; j2++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b2, posA, posB) {
  for (var iA = a2.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a2.child(--iA), childB = b2.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = function Fragment2(content2, size) {
  this.content = content2;
  this.size = size || 0;
  if (size == null) {
    for (var i2 = 0; i2 < content2.length; i2++) {
      this.size += content2[i2].nodeSize;
    }
  }
};
var prototypeAccessors$5 = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment.prototype.nodesBetween = function nodesBetween(from5, to, f2, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i2 = 0, pos = 0; pos < to; i2++) {
    var child3 = this.content[i2], end3 = pos + child3.nodeSize;
    if (end3 > from5 && f2(child3, nodeStart + pos, parent, i2) !== false && child3.content.size) {
      var start4 = pos + 1;
      child3.nodesBetween(Math.max(0, from5 - start4), Math.min(child3.content.size, to - start4), f2, nodeStart + start4);
    }
    pos = end3;
  }
};
Fragment.prototype.descendants = function descendants(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment.prototype.textBetween = function textBetween(from5, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from5, to, function(node5, pos) {
    if (node5.isText) {
      text3 += node5.text.slice(Math.max(from5, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node5.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node5) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node5.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment.prototype.append = function append2(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content2 = this.content.slice(), i2 = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content2[content2.length - 1] = last.withText(last.text + first2.text);
    i2 = 1;
  }
  for (; i2 < other.content.length; i2++) {
    content2.push(other.content[i2]);
  }
  return new Fragment(content2, this.size + other.size);
};
Fragment.prototype.cut = function cut(from5, to) {
  if (to == null) {
    to = this.size;
  }
  if (from5 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from5) {
    for (var i2 = 0, pos = 0; pos < to; i2++) {
      var child3 = this.content[i2], end3 = pos + child3.nodeSize;
      if (end3 > from5) {
        if (pos < from5 || end3 > to) {
          if (child3.isText) {
            child3 = child3.cut(Math.max(0, from5 - pos), Math.min(child3.text.length, to - pos));
          } else {
            child3 = child3.cut(Math.max(0, from5 - pos - 1), Math.min(child3.content.size, to - pos - 1));
          }
        }
        result2.push(child3);
        size += child3.nodeSize;
      }
      pos = end3;
    }
  }
  return new Fragment(result2, size);
};
Fragment.prototype.cutByIndex = function cutByIndex(from5, to) {
  if (from5 == to) {
    return Fragment.empty;
  }
  if (from5 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment(this.content.slice(from5, to));
};
Fragment.prototype.replaceChild = function replaceChild(index3, node5) {
  var current = this.content[index3];
  if (current == node5) {
    return this;
  }
  var copy5 = this.content.slice();
  var size = this.size + node5.nodeSize - current.nodeSize;
  copy5[index3] = node5;
  return new Fragment(copy5, size);
};
Fragment.prototype.addToStart = function addToStart(node5) {
  return new Fragment([node5].concat(this.content), this.size + node5.nodeSize);
};
Fragment.prototype.addToEnd = function addToEnd(node5) {
  return new Fragment(this.content.concat(node5), this.size + node5.nodeSize);
};
Fragment.prototype.eq = function eq(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.content.length; i2++) {
    if (!this.content[i2].eq(other.content[i2])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$5.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$5.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$5.childCount.get = function() {
  return this.content.length;
};
Fragment.prototype.child = function child(index3) {
  var found2 = this.content[index3];
  if (!found2) {
    throw new RangeError("Index " + index3 + " out of range for " + this);
  }
  return found2;
};
Fragment.prototype.maybeChild = function maybeChild(index3) {
  return this.content[index3];
};
Fragment.prototype.forEach = function forEach(f2) {
  for (var i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
    var child3 = this.content[i2];
    f2(child3, p2, i2);
    p2 += child3.nodeSize;
  }
};
Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart(this, other, pos);
};
Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd(this, other, pos, otherPos);
};
Fragment.prototype.findIndex = function findIndex(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex(0, pos);
  }
  if (pos == this.size) {
    return retIndex(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i2 = 0, curPos = 0; ; i2++) {
    var cur = this.child(i2), end3 = curPos + cur.nodeSize;
    if (end3 >= pos) {
      if (end3 == pos || round2 > 0) {
        return retIndex(i2 + 1, end3);
      }
      return retIndex(i2, curPos);
    }
    curPos = end3;
  }
};
Fragment.prototype.toString = function toString() {
  return "<" + this.toStringInner() + ">";
};
Fragment.prototype.toStringInner = function toStringInner() {
  return this.content.join(", ");
};
Fragment.prototype.toJSON = function toJSON() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment.fromJSON = function fromJSON(schema, value) {
  if (!value) {
    return Fragment.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment(value.map(schema.nodeFromJSON));
};
Fragment.fromArray = function fromArray(array) {
  if (!array.length) {
    return Fragment.empty;
  }
  var joined, size = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var node5 = array[i2];
    size += node5.nodeSize;
    if (i2 && node5.isText && array[i2 - 1].sameMarkup(node5)) {
      if (!joined) {
        joined = array.slice(0, i2);
      }
      joined[joined.length - 1] = node5.withText(joined[joined.length - 1].text + node5.text);
    } else if (joined) {
      joined.push(node5);
    }
  }
  return new Fragment(joined || array, size);
};
Fragment.from = function from2(nodes) {
  if (!nodes) {
    return Fragment.empty;
  }
  if (nodes instanceof Fragment) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment.prototype, prototypeAccessors$5);
var found = { index: 0, offset: 0 };
function retIndex(index3, offset3) {
  found.index = index3;
  found.offset = offset3;
  return found;
}
Fragment.empty = new Fragment([], 0);
function compareDeep(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (!(a2 && typeof a2 == "object") || !(b2 && typeof b2 == "object")) {
    return false;
  }
  var array = Array.isArray(a2);
  if (Array.isArray(b2) != array) {
    return false;
  }
  if (array) {
    if (a2.length != b2.length) {
      return false;
    }
    for (var i2 = 0; i2 < a2.length; i2++) {
      if (!compareDeep(a2[i2], b2[i2])) {
        return false;
      }
    }
  } else {
    for (var p2 in a2) {
      if (!(p2 in b2) || !compareDeep(a2[p2], b2[p2])) {
        return false;
      }
    }
    for (var p$12 in b2) {
      if (!(p$12 in a2)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$1 = function Mark(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark$1.prototype.addToSet = function addToSet(set2) {
  var copy5, placed = false;
  for (var i2 = 0; i2 < set2.length; i2++) {
    var other = set2[i2];
    if (this.eq(other)) {
      return set2;
    }
    if (this.type.excludes(other.type)) {
      if (!copy5) {
        copy5 = set2.slice(0, i2);
      }
    } else if (other.type.excludes(this.type)) {
      return set2;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy5) {
          copy5 = set2.slice(0, i2);
        }
        copy5.push(this);
        placed = true;
      }
      if (copy5) {
        copy5.push(other);
      }
    }
  }
  if (!copy5) {
    copy5 = set2.slice();
  }
  if (!placed) {
    copy5.push(this);
  }
  return copy5;
};
Mark$1.prototype.removeFromSet = function removeFromSet(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (this.eq(set2[i2])) {
      return set2.slice(0, i2).concat(set2.slice(i2 + 1));
    }
  }
  return set2;
};
Mark$1.prototype.isInSet = function isInSet(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (this.eq(set2[i2])) {
      return true;
    }
  }
  return false;
};
Mark$1.prototype.eq = function eq2(other) {
  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
};
Mark$1.prototype.toJSON = function toJSON2() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark$1.fromJSON = function fromJSON2(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark$1.sameSet = function sameSet(a2, b2) {
  if (a2 == b2) {
    return true;
  }
  if (a2.length != b2.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].eq(b2[i2])) {
      return false;
    }
  }
  return true;
};
Mark$1.setFrom = function setFrom(marks2) {
  if (!marks2 || marks2.length == 0) {
    return Mark$1.none;
  }
  if (marks2 instanceof Mark$1) {
    return [marks2];
  }
  var copy5 = marks2.slice();
  copy5.sort(function(a2, b2) {
    return a2.type.rank - b2.type.rank;
  });
  return copy5;
};
Mark$1.none = [];
function ReplaceError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = ReplaceError.prototype;
  return err2;
}
ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";
var Slice = function Slice2(content2, openStart, openEnd) {
  this.content = content2;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$3 = { size: { configurable: true } };
prototypeAccessors$1$3.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice.prototype.insertAt = function insertAt(pos, fragment) {
  var content2 = insertInto(this.content, pos + this.openStart, fragment, null);
  return content2 && new Slice(content2, this.openStart, this.openEnd);
};
Slice.prototype.removeBetween = function removeBetween(from5, to) {
  return new Slice(removeRange(this.content, from5 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice.prototype.eq = function eq3(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice.prototype.toString = function toString2() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice.prototype.toJSON = function toJSON3() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice.fromJSON = function fromJSON3(schema, json) {
  if (!json) {
    return Slice.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
};
Slice.maxOpen = function maxOpen(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice(fragment, openStart, openEnd);
};
Object.defineProperties(Slice.prototype, prototypeAccessors$1$3);
function removeRange(content2, from5, to) {
  var ref = content2.findIndex(from5);
  var index3 = ref.index;
  var offset3 = ref.offset;
  var child3 = content2.maybeChild(index3);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset3 == from5 || child3.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from5).append(content2.cut(to));
  }
  if (index3 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index3, child3.copy(removeRange(child3.content, from5 - offset3 - 1, to - offset3 - 1)));
}
function insertInto(content2, dist, insert, parent) {
  var ref = content2.findIndex(dist);
  var index3 = ref.index;
  var offset3 = ref.offset;
  var child3 = content2.maybeChild(index3);
  if (offset3 == dist || child3.isText) {
    if (parent && !parent.canReplace(index3, index3, insert)) {
      return null;
    }
    return content2.cut(0, dist).append(insert).append(content2.cut(dist));
  }
  var inner = insertInto(child3.content, dist - offset3 - 1, insert);
  return inner && content2.replaceChild(index3, child3.copy(inner));
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function replace($from, $to, slice5) {
  if (slice5.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice5.openStart != $to.depth - slice5.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice5, 0);
}
function replaceOuter($from, $to, slice5, depth) {
  var index3 = $from.index(depth), node5 = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice5.openStart) {
    var inner = replaceOuter($from, $to, slice5, depth + 1);
    return node5.copy(node5.content.replaceChild(index3, inner));
  } else if (!slice5.content.size) {
    return close(node5, replaceTwoWay($from, $to, depth));
  } else if (!slice5.openStart && !slice5.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close(parent, content2.cut(0, $from.parentOffset).append(slice5.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace(slice5, $from);
    var start4 = ref.start;
    var end3 = ref.end;
    return close(node5, replaceThreeWay($from, start4, end3, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$1($before, $after, depth) {
  var node5 = $before.node(depth);
  checkJoin(node5, $after.node(depth));
  return node5;
}
function addNode(child3, target) {
  var last = target.length - 1;
  if (last >= 0 && child3.isText && child3.sameMarkup(target[last])) {
    target[last] = child3.withText(target[last].text + child3.text);
  } else {
    target.push(child3);
  }
}
function addRange($start, $end, depth, target) {
  var node5 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node5.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i2 = startIndex2; i2 < endIndex2; i2++) {
    addNode(node5.child(i2), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode($end.nodeBefore, target);
  }
}
function close(node5, content2) {
  if (!node5.type.validContent(content2)) {
    throw new ReplaceError("Invalid content for node " + node5.type.name);
  }
  return node5.copy(content2);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content2 = [];
  addRange(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content2);
    }
    addRange($start, $end, depth, content2);
    if (openEnd) {
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content2);
    }
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function replaceTwoWay($from, $to, depth) {
  var content2 = [];
  addRange(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content2);
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function prepareSliceForReplace(slice5, $along) {
  var extra = $along.depth - slice5.openStart, parent = $along.node(extra);
  var node5 = parent.copy(slice5.content);
  for (var i2 = extra - 1; i2 >= 0; i2--) {
    node5 = $along.node(i2).copy(Fragment.from(node5));
  }
  return {
    start: node5.resolveNoCache(slice5.openStart + extra),
    end: node5.resolveNoCache(node5.content.size - slice5.openEnd - extra)
  };
}
var ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$1 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$1.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$1.doc.get = function() {
  return this.node(0);
};
ResolvedPos.prototype.node = function node2(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos.prototype.index = function index2(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos.prototype.start = function start2(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos.prototype.end = function end2(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos.prototype.before = function before(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos.prototype.after = function after(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$1.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$1.nodeAfter.get = function() {
  var parent = this.parent, index3 = this.index(this.depth);
  if (index3 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child3 = parent.child(index3);
  return dOff ? parent.child(index3).cut(dOff) : child3;
};
prototypeAccessors$2$1.nodeBefore.get = function() {
  var index3 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index3).cut(0, dOff);
  }
  return index3 == 0 ? null : this.parent.child(index3 - 1);
};
ResolvedPos.prototype.posAtIndex = function posAtIndex(index3, depth) {
  depth = this.resolveDepth(depth);
  var node5 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i2 = 0; i2 < index3; i2++) {
    pos += node5.child(i2).nodeSize;
  }
  return pos;
};
ResolvedPos.prototype.marks = function marks() {
  var parent = this.parent, index3 = this.index();
  if (parent.content.size == 0) {
    return Mark$1.none;
  }
  if (this.textOffset) {
    return parent.child(index3).marks;
  }
  var main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks2 = main2.marks;
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (marks2[i2].type.spec.inclusive === false && (!other || !marks2[i2].isInSet(other.marks))) {
      marks2 = marks2[i2--].removeFromSet(marks2);
    }
  }
  return marks2;
};
ResolvedPos.prototype.marksAcross = function marksAcross($end) {
  var after2 = this.parent.maybeChild(this.index());
  if (!after2 || !after2.isInline) {
    return null;
  }
  var marks2 = after2.marks, next2 = $end.parent.maybeChild($end.index());
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (marks2[i2].type.spec.inclusive === false && (!next2 || !marks2[i2].isInSet(next2.marks))) {
      marks2 = marks2[i2--].removeFromSet(marks2);
    }
  }
  return marks2;
};
ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--) {
    if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2)))) {
      return new NodeRange(this, other, d2);
    }
  }
};
ResolvedPos.prototype.sameParent = function sameParent(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos.prototype.max = function max(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos.prototype.min = function min(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos.prototype.toString = function toString3() {
  var str = "";
  for (var i2 = 1; i2 <= this.depth; i2++) {
    str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos.resolve = function resolve(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start4 = 0, parentOffset = pos;
  for (var node5 = doc2; ; ) {
    var ref = node5.content.findIndex(parentOffset);
    var index3 = ref.index;
    var offset3 = ref.offset;
    var rem = parentOffset - offset3;
    path.push(node5, index3, start4 + offset3);
    if (!rem) {
      break;
    }
    node5 = node5.child(index3);
    if (node5.isText) {
      break;
    }
    parentOffset = rem - 1;
    start4 += offset3 + 1;
  }
  return new ResolvedPos(pos, path, parentOffset);
};
ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
  for (var i2 = 0; i2 < resolveCache.length; i2++) {
    var cached = resolveCache[i2];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result2;
};
Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2$1);
var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
var NodeRange = function NodeRange2($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1$1);
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node$1 = function Node(type, attrs, content2, marks2) {
  this.type = type;
  this.attrs = attrs;
  this.content = content2 || Fragment.empty;
  this.marks = marks2 || Mark$1.none;
};
var prototypeAccessors$3$1 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$1.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$1.childCount.get = function() {
  return this.content.childCount;
};
Node$1.prototype.child = function child2(index3) {
  return this.content.child(index3);
};
Node$1.prototype.maybeChild = function maybeChild2(index3) {
  return this.content.maybeChild(index3);
};
Node$1.prototype.forEach = function forEach2(f2) {
  this.content.forEach(f2);
};
Node$1.prototype.nodesBetween = function nodesBetween2(from5, to, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from5, to, f2, startPos, this);
};
Node$1.prototype.descendants = function descendants2(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$3$1.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$1.prototype.textBetween = function textBetween2(from5, to, blockSeparator, leafText) {
  return this.content.textBetween(from5, to, blockSeparator, leafText);
};
prototypeAccessors$3$1.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$1.lastChild.get = function() {
  return this.content.lastChild;
};
Node$1.prototype.eq = function eq4(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$1.prototype.sameMarkup = function sameMarkup(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$1.prototype.hasMarkup = function hasMarkup(type, attrs, marks2) {
  return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks2 || Mark$1.none);
};
Node$1.prototype.copy = function copy(content2) {
  if (content2 === void 0)
    content2 = null;
  if (content2 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content2, this.marks);
};
Node$1.prototype.mark = function mark(marks2) {
  return marks2 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks2);
};
Node$1.prototype.cut = function cut2(from5, to) {
  if (from5 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from5, to));
};
Node$1.prototype.slice = function slice2(from5, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from5 == to) {
    return Slice.empty;
  }
  var $from = this.resolve(from5), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start4 = $from.start(depth), node5 = $from.node(depth);
  var content2 = node5.content.cut($from.pos - start4, $to.pos - start4);
  return new Slice(content2, $from.depth - depth, $to.depth - depth);
};
Node$1.prototype.replace = function replace$12(from5, to, slice5) {
  return replace(this.resolve(from5), this.resolve(to), slice5);
};
Node$1.prototype.nodeAt = function nodeAt(pos) {
  for (var node5 = this; ; ) {
    var ref = node5.content.findIndex(pos);
    var index3 = ref.index;
    var offset3 = ref.offset;
    node5 = node5.maybeChild(index3);
    if (!node5) {
      return null;
    }
    if (offset3 == pos || node5.isText) {
      return node5;
    }
    pos -= offset3 + 1;
  }
};
Node$1.prototype.childAfter = function childAfter(pos) {
  var ref = this.content.findIndex(pos);
  var index3 = ref.index;
  var offset3 = ref.offset;
  return { node: this.content.maybeChild(index3), index: index3, offset: offset3 };
};
Node$1.prototype.childBefore = function childBefore(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index3 = ref.index;
  var offset3 = ref.offset;
  if (offset3 < pos) {
    return { node: this.content.child(index3), index: index3, offset: offset3 };
  }
  var node5 = this.content.child(index3 - 1);
  return { node: node5, index: index3 - 1, offset: offset3 - node5.nodeSize };
};
Node$1.prototype.resolve = function resolve2(pos) {
  return ResolvedPos.resolveCached(this, pos);
};
Node$1.prototype.resolveNoCache = function resolveNoCache(pos) {
  return ResolvedPos.resolve(this, pos);
};
Node$1.prototype.rangeHasMark = function rangeHasMark(from5, to, type) {
  var found2 = false;
  if (to > from5) {
    this.nodesBetween(from5, to, function(node5) {
      if (type.isInSet(node5.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$1.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$1.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$1.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$1.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$1.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$1.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$1.isAtom.get = function() {
  return this.type.isAtom;
};
Node$1.prototype.toString = function toString4() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks(this.marks, name);
};
Node$1.prototype.contentMatchAt = function contentMatchAt(index3) {
  var match2 = this.type.contentMatch.matchFragment(this.content, 0, index3);
  if (!match2) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match2;
};
Node$1.prototype.canReplace = function canReplace(from5, to, replacement, start4, end3) {
  if (replacement === void 0)
    replacement = Fragment.empty;
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = replacement.childCount;
  var one = this.contentMatchAt(from5).matchFragment(replacement, start4, end3);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    if (!this.type.allowsMarks(replacement.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
Node$1.prototype.canReplaceWith = function canReplaceWith(from5, to, type, marks2) {
  if (marks2 && !this.type.allowsMarks(marks2)) {
    return false;
  }
  var start4 = this.contentMatchAt(from5).matchType(type);
  var end3 = start4 && start4.matchFragment(this.content, to);
  return end3 ? end3.validEnd : false;
};
Node$1.prototype.canAppend = function canAppend(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$1.prototype.check = function check() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy5 = Mark$1.none;
  for (var i2 = 0; i2 < this.marks.length; i2++) {
    copy5 = this.marks[i2].addToSet(copy5);
  }
  if (!Mark$1.sameSet(copy5, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m2) {
      return m2.type.name;
    }));
  }
  this.content.forEach(function(node5) {
    return node5.check();
  });
};
Node$1.prototype.toJSON = function toJSON4() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node$1.fromJSON = function fromJSON4(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks2 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks2 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks2);
  }
  var content2 = Fragment.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content2, marks2);
};
Object.defineProperties(Node$1.prototype, prototypeAccessors$3$1);
var TextNode = /* @__PURE__ */ function(Node3) {
  function TextNode2(type, attrs, content2, marks2) {
    Node3.call(this, type, attrs, null, marks2);
    if (!content2) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content2;
  }
  if (Node3)
    TextNode2.__proto__ = Node3;
  TextNode2.prototype = Object.create(Node3 && Node3.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
  TextNode2.prototype.toString = function toString8() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween3(from5, to) {
    return this.text.slice(from5, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark3(marks2) {
    return marks2 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks2);
  };
  TextNode2.prototype.withText = function withText(text3) {
    if (text3 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text3, this.marks);
  };
  TextNode2.prototype.cut = function cut3(from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from5 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from5, to));
  };
  TextNode2.prototype.eq = function eq12(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON7() {
    var base2 = Node3.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$1);
function wrapMarks(marks2, str) {
  for (var i2 = marks2.length - 1; i2 >= 0; i2--) {
    str = marks2[i2].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch = function ContentMatch2(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$1 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch.parse = function parse(string, nodeTypes) {
  var stream = new TokenStream(string, nodeTypes);
  if (stream.next == null) {
    return ContentMatch.empty;
  }
  var expr = parseExpr(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match2 = dfa(nfa(expr));
  checkForDeadEnds(match2, stream);
  return match2;
};
ContentMatch.prototype.matchType = function matchType(type) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    if (this.next[i2] == type) {
      return this.next[i2 + 1];
    }
  }
  return null;
};
ContentMatch.prototype.matchFragment = function matchFragment(frag, start4, end3) {
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = frag.childCount;
  var cur = this;
  for (var i2 = start4; cur && i2 < end3; i2++) {
    cur = cur.matchType(frag.child(i2).type);
  }
  return cur;
};
prototypeAccessors$4$1.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4$1.defaultType.get = function() {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    var type = this.next[i2];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch.prototype.compatible = function compatible(other) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    for (var j2 = 0; j2 < other.next.length; j2 += 2) {
      if (this.next[i2] == other.next[j2]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch.prototype.fillBefore = function fillBefore(after2, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match2, types) {
    var finished = match2.matchFragment(after2, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i2 = 0; i2 < match2.next.length; i2 += 2) {
      var type = match2.next[i2], next2 = match2.next[i2 + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
        seen.push(next2);
        var found2 = search(next2, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch.prototype.findWrapping = function findWrapping(target) {
  for (var i2 = 0; i2 < this.wrapCache.length; i2 += 2) {
    if (this.wrapCache[i2] == target) {
      return this.wrapCache[i2 + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match2 = current.match;
    if (match2.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i2 = 0; i2 < match2.next.length; i2 += 2) {
      var type = match2.next[i2];
      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match2.next[i2 + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$4$1.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch.prototype.edge = function edge(n2) {
  var i2 = n2 << 1;
  if (i2 >= this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i2], next: this.next[i2 + 1] };
};
ContentMatch.prototype.toString = function toString5() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i2 = 1; i2 < m2.next.length; i2 += 2) {
      if (seen.indexOf(m2.next[i2]) == -1) {
        scan(m2.next[i2]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i2) {
    var out = i2 + (m2.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m2.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m2.next[i$1].name + "->" + seen.indexOf(m2.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4$1);
ContentMatch.empty = new ContentMatch(true);
var TokenStream = function TokenStream2(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$1 = { next: { configurable: true } };
prototypeAccessors$1$2$1.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream.prototype.eat = function eat(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream.prototype.err = function err(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2$1);
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min3 = parseNum(stream), max3 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max3 = parseNum(stream);
    } else {
      max3 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min3, max: max3, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile4(expr, 0), node5());
  return nfa2;
  function node5() {
    return nfa2.push([]) - 1;
  }
  function edge2(from5, to, term) {
    var edge3 = { term, to };
    nfa2[from5].push(edge3);
    return edge3;
  }
  function connect(edges, to) {
    edges.forEach(function(edge3) {
      return edge3.to = to;
    });
  }
  function compile4(expr2, from5) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile4(expr3, from5));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i2 = 0; ; i2++) {
        var next2 = compile4(expr2.exprs[i2], from5);
        if (i2 == expr2.exprs.length - 1) {
          return next2;
        }
        connect(next2, from5 = node5());
      }
    } else if (expr2.type == "star") {
      var loop = node5();
      edge2(from5, loop);
      connect(compile4(expr2.expr, loop), loop);
      return [edge2(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node5();
      connect(compile4(expr2.expr, from5), loop$1);
      connect(compile4(expr2.expr, loop$1), loop$1);
      return [edge2(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge2(from5)].concat(compile4(expr2.expr, from5));
    } else if (expr2.type == "range") {
      var cur = from5;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node5();
        connect(compile4(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile4(expr2.expr, cur), cur);
      } else {
        for (var i$22 = expr2.min; i$22 < expr2.max; i$22++) {
          var next$2 = node5();
          edge2(cur, next$2);
          connect(compile4(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge2(cur)];
    } else if (expr2.type == "name") {
      return [edge2(from5, null, expr2.value)];
    }
  }
}
function cmp(a2, b2) {
  return b2 - a2;
}
function nullFrom(nfa2, node5) {
  var result2 = [];
  scan(node5);
  return result2.sort(cmp);
  function scan(node6) {
    var edges = nfa2[node6];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node6);
    for (var i2 = 0; i2 < edges.length; i2++) {
      var ref = edges[i2];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node5) {
      nfa2[node5].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set2 = known > -1 && out[known + 1];
        nullFrom(nfa2, to).forEach(function(node6) {
          if (!set2) {
            out.push(term, set2 = []);
          }
          if (set2.indexOf(node6) == -1) {
            set2.push(node6);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (var i2 = 0; i2 < out.length; i2 += 2) {
      var states$1 = out[i2 + 1].sort(cmp);
      state.next.push(out[i2], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match2, stream) {
  for (var i2 = 0, work = [match2]; i2 < work.length; i2++) {
    var state = work[i2], dead = !state.validEnd, nodes = [];
    for (var j2 = 0; j2 < state.next.length; j2 += 2) {
      var node5 = state.next[j2], next2 = state.next[j2 + 1];
      nodes.push(node5.name);
      if (dead && !(node5.isText || node5.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next2) == -1) {
        work.push(next2);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute(attrs[name]);
    }
  }
  return result2;
}
var NodeType$1 = function NodeType(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);
  this.defaultAttrs = defaultAttrs(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$1 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$1.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$1.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$1.isLeaf.get = function() {
  return this.contentMatch == ContentMatch.empty;
};
prototypeAccessors$5$1.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$1.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$1.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
  for (var n2 in this.attrs) {
    if (this.attrs[n2].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$1.prototype.compatibleContent = function compatibleContent(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$1.prototype.computeAttrs = function computeAttrs$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs(this.attrs, attrs);
  }
};
NodeType$1.prototype.create = function create2(attrs, content2, marks2) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content2), Mark$1.setFrom(marks2));
};
NodeType$1.prototype.createChecked = function createChecked(attrs, content2, marks2) {
  content2 = Fragment.from(content2);
  if (!this.validContent(content2)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$1(this, this.computeAttrs(attrs), content2, Mark$1.setFrom(marks2));
};
NodeType$1.prototype.createAndFill = function createAndFill(attrs, content2, marks2) {
  attrs = this.computeAttrs(attrs);
  content2 = Fragment.from(content2);
  if (content2.size) {
    var before2 = this.contentMatch.fillBefore(content2);
    if (!before2) {
      return null;
    }
    content2 = before2.append(content2);
  }
  var after2 = this.contentMatch.matchFragment(content2).fillBefore(Fragment.empty, true);
  if (!after2) {
    return null;
  }
  return new Node$1(this, attrs, content2.append(after2), Mark$1.setFrom(marks2));
};
NodeType$1.prototype.validContent = function validContent(content2) {
  var result2 = this.contentMatch.matchFragment(content2);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i2 = 0; i2 < content2.childCount; i2++) {
    if (!this.allowsMarks(content2.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$1.prototype.allowsMarkType = function allowsMarkType(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$1.prototype.allowsMarks = function allowsMarks(marks2) {
  if (this.markSet == null) {
    return true;
  }
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (!this.allowsMarkType(marks2[i2].type)) {
      return false;
    }
  }
  return true;
};
NodeType$1.prototype.allowedMarks = function allowedMarks(marks2) {
  if (this.markSet == null) {
    return marks2;
  }
  var copy5;
  for (var i2 = 0; i2 < marks2.length; i2++) {
    if (!this.allowsMarkType(marks2[i2].type)) {
      if (!copy5) {
        copy5 = marks2.slice(0, i2);
      }
    } else if (copy5) {
      copy5.push(marks2[i2]);
    }
  }
  return !copy5 ? marks2 : copy5.length ? copy5 : Mark$1.empty;
};
NodeType$1.compile = function compile2(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$1(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _2 in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$1.prototype, prototypeAccessors$5$1);
var Attribute = function Attribute2(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$1 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$1.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3$1);
var MarkType = function MarkType2(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs(this.attrs);
  this.instance = defaults2 && new Mark$1(this, defaults2);
};
MarkType.prototype.create = function create3(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$1(this, computeAttrs(this.attrs, attrs));
};
MarkType.compile = function compile3(marks2, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks2.forEach(function(name, spec) {
    return result2[name] = new MarkType(name, rank++, schema, spec);
  });
  return result2;
};
MarkType.prototype.removeFromSet = function removeFromSet2(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (set2[i2].type == this) {
      set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
      i2--;
    }
  }
  return set2;
};
MarkType.prototype.isInSet = function isInSet2(set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (set2[i2].type == this) {
      return set2[i2];
    }
  }
};
MarkType.prototype.excludes = function excludes(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema = function Schema2(spec) {
  this.spec = {};
  for (var prop in spec) {
    this.spec[prop] = spec[prop];
  }
  this.spec.nodes = orderedmap.from(spec.nodes);
  this.spec.marks = orderedmap.from(spec.marks);
  this.nodes = NodeType$1.compile(this.spec.nodes, this);
  this.marks = MarkType.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema.prototype.node = function node3(type, attrs, content2, marks2) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$1)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content2, marks2);
};
Schema.prototype.text = function text(text$1, marks2) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$1, Mark$1.setFrom(marks2));
};
Schema.prototype.mark = function mark2(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
  return Node$1.fromJSON(this, json);
};
Schema.prototype.markFromJSON = function markFromJSON(json) {
  return Mark$1.fromJSON(this, json);
};
Schema.prototype.nodeType = function nodeType(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks(schema, marks2) {
  var found2 = [];
  for (var i2 = 0; i2 < marks2.length; i2++) {
    var name = marks2[i2], mark3 = schema.marks[name], ok3 = mark3;
    if (mark3) {
      found2.push(mark3);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks2[i2] + "'");
    }
  }
  return found2;
}
var DOMParser$1 = function DOMParser2(schema, rules) {
  var this$1$1 = this;
  this.schema = schema;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
  this.normalizeLists = !this.tags.some(function(r2) {
    if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node) {
      return false;
    }
    var node5 = schema.nodes[r2.node];
    return node5.contentMatch.matchType(node5);
  });
};
DOMParser$1.prototype.parse = function parse2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$1.prototype.parseSlice = function parseSlice(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context.finish());
};
DOMParser$1.prototype.matchTag = function matchTag(dom, context, after2) {
  for (var i2 = after2 ? this.tags.indexOf(after2) + 1 : 0; i2 < this.tags.length; i2++) {
    var rule = this.tags[i2];
    if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$1.prototype.matchStyle = function matchStyle(prop, value, context, after2) {
  for (var i2 = after2 ? this.styles.indexOf(after2) + 1 : 0; i2 < this.styles.length; i2++) {
    var rule = this.styles[i2];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$1.schemaRules = function schemaRules(schema) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
    for (; i2 < result2.length; i2++) {
      var next2 = result2[i2], nextPriority = next2.priority == null ? 50 : next2.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i2, 0, rule);
  }
  var loop = function(name2) {
    var rules = schema.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema.nodes)
    loop$1();
  return result2;
};
DOMParser$1.fromSchema = function fromSchema(schema) {
  return schema.cached.domParser || (schema.cached.domParser = new DOMParser$1(schema, DOMParser$1.schemaRules(schema)));
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  }
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = function NodeContext2(type, attrs, marks2, pendingMarks, solid, match2, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match2 || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks2;
  this.activeMarks = Mark$1.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext.prototype.findWrapping = function findWrapping2(node5) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node5));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start4 = this.type.contentMatch, wrap;
      if (wrap = start4.findWrapping(node5.type)) {
        this.match = start4;
        return wrap;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node5.type);
};
NodeContext.prototype.finish = function finish(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content2 = Fragment.from(this.content);
  if (!openEnd && this.match) {
    content2 = content2.append(this.match.fillBefore(Fragment.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
};
NodeContext.prototype.popFromStashMark = function popFromStashMark(mark3) {
  for (var i2 = this.stashMarks.length - 1; i2 >= 0; i2--) {
    if (mark3.eq(this.stashMarks[i2])) {
      return this.stashMarks.splice(i2, 1)[0];
    }
  }
};
NodeContext.prototype.applyPending = function applyPending(nextType) {
  for (var i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
    var mark3 = pending[i2];
    if ((this.type ? this.type.allowsMarkType(mark3.type) : markMayApply(mark3.type, nextType)) && !mark3.isInSet(this.activeMarks)) {
      this.activeMarks = mark3.addToSet(this.activeMarks);
      this.pendingMarks = mark3.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext.prototype.inlineContext = function inlineContext(node5) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node5.parentNode && !blockTags.hasOwnProperty(node5.parentNode.nodeName.toLowerCase());
};
var ParseContext = function ParseContext2(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode) {
    topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
  } else {
    topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6.top.get = function() {
  return this.nodes[this.open];
};
ParseContext.prototype.addDOM = function addDOM(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks2 = style2 ? this.readStyles(parseStyles(style2)) : null, top2 = this.top;
    if (marks2 != null) {
      for (var i2 = 0; i2 < marks2.length; i2++) {
        this.addPendingMark(marks2[i2]);
      }
    }
    this.addElement(dom);
    if (marks2 != null) {
      for (var i$1 = 0; i$1 < marks2.length; i$1++) {
        this.removePendingMark(marks2[i$1], top2);
      }
    }
  }
};
ParseContext.prototype.addTextNode = function addTextNode(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync3, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync3 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync3) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext.prototype.leafFallback = function leafFallback(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext.prototype.readStyles = function readStyles(styles) {
  var marks2 = Mark$1.none;
  style:
    for (var i2 = 0; i2 < styles.length; i2 += 2) {
      for (var after2 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i2], styles[i2 + 1], this, after2);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks2);
        if (rule.consuming === false) {
          after2 = rule;
        } else {
          break;
        }
      }
    }
  return marks2;
};
ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync3, nodeType2, markType, mark3;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync3 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark3 = markType.create(rule.attrs);
    this.addPendingMark(mark3);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node5) {
      return this$1$1.insertNode(node5);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync3);
  }
  if (sync3) {
    this.sync(startIn);
    this.open--;
  }
  if (mark3) {
    this.removePendingMark(mark3, startIn);
  }
};
ParseContext.prototype.addAll = function addAll(parent, sync3, startIndex2, endIndex2) {
  var index3 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end3 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end3; dom = dom.nextSibling, ++index3) {
    this.findAtPoint(parent, index3);
    this.addDOM(dom);
    if (sync3 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync3);
    }
  }
  this.findAtPoint(parent, index3);
};
ParseContext.prototype.findPlace = function findPlace(node5) {
  var route, sync3;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node5);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync3 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync3);
  for (var i2 = 0; i2 < route.length; i2++) {
    this.enterInner(route[i2], null, false);
  }
  return true;
};
ParseContext.prototype.insertNode = function insertNode(node5) {
  if (node5.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node5)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node5.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node5.type);
    }
    var marks2 = top2.activeMarks;
    for (var i2 = 0; i2 < node5.marks.length; i2++) {
      if (!top2.type || top2.type.allowsMarkType(node5.marks[i2].type)) {
        marks2 = node5.marks[i2].addToSet(marks2);
      }
    }
    top2.content.push(node5.mark(marks2));
    return true;
  }
  return false;
};
ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type);
  top2.match = top2.match && top2.match.matchType(type, attrs);
  var options = wsOptionsFor(type, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT;
  }
  this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
  var i2 = this.nodes.length - 1;
  if (i2 > this.open) {
    for (; i2 > this.open; i2--) {
      this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext.prototype.finish = function finish2() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext.prototype.sync = function sync2(to) {
  for (var i2 = this.open; i2 >= 0; i2--) {
    if (this.nodes[i2] == to) {
      this.open = i2;
      return;
    }
  }
};
prototypeAccessors$6.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i2 = this.open; i2 >= 0; i2--) {
    var content2 = this.nodes[i2].content;
    for (var j2 = content2.length - 1; j2 >= 0; j2--) {
      pos += content2[j2].nodeSize;
    }
    if (i2) {
      pos++;
    }
  }
  return pos;
};
ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset3) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == parent && this.find[i2].offset == offset3) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findInside = function findInside(parent) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findAround = function findAround(parent, content2, before2) {
  if (parent != content2 && this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        var pos = content2.compareDocumentPosition(this.find[i2].node);
        if (pos & (before2 ? 2 : 4)) {
          this.find[i2].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext.prototype.findInText = function findInText(textNode) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == textNode) {
        this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
    }
  }
};
ParseContext.prototype.matchesContext = function matchesContext(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match2 = function(i2, depth) {
    for (; i2 >= 0; i2--) {
      var part = parts[i2];
      if (part == "") {
        if (i2 == parts.length - 1 || i2 == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match2(i2 - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next2 = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match2(parts.length - 1, this.open);
};
ParseContext.prototype.textblockFromContext = function textblockFromContext() {
  var $context = this.options.context;
  if ($context) {
    for (var d2 = $context.depth; d2 >= 0; d2--) {
      var deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type = this.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
ParseContext.prototype.addPendingMark = function addPendingMark(mark3) {
  var found2 = findSameMarkInSet(mark3, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark3.addToSet(this.top.pendingMarks);
};
ParseContext.prototype.removePendingMark = function removePendingMark(mark3, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark3);
    if (found2 > -1) {
      level.pendingMarks = mark3.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark3.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark3);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
function normalizeList(dom) {
  for (var child3 = dom.firstChild, prevItem = null; child3; child3 = child3.nextSibling) {
    var name = child3.nodeType == 1 ? child3.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child3);
      child3 = prevItem;
    } else if (name == "li") {
      prevItem = child3;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style2)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy2(obj) {
  var copy5 = {};
  for (var prop in obj) {
    copy5[prop] = obj[prop];
  }
  return copy5;
}
function markMayApply(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match2) {
      seen.push(match2);
      for (var i2 = 0; i2 < match2.edgeCount; i2++) {
        var ref = match2.edge(i2);
        var type = ref.type;
        var next2 = ref.next;
        if (type == nodeType2) {
          return true;
        }
        if (seen.indexOf(next2) < 0 && scan(next2)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet(mark3, set2) {
  for (var i2 = 0; i2 < set2.length; i2++) {
    if (mark3.eq(set2[i2])) {
      return set2[i2];
    }
  }
}
var DOMSerializer = function DOMSerializer2(nodes, marks2) {
  this.nodes = nodes || {};
  this.marks = marks2 || {};
};
DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc(options).createDocumentFragment();
  }
  var top2 = target, active = null;
  fragment.forEach(function(node5) {
    if (active || node5.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node5.marks.length) {
        var next2 = node5.marks[rendered];
        if (!this$1$1.marks[next2.type.name]) {
          rendered++;
          continue;
        }
        if (!next2.eq(active[keep]) || next2.type.spec.spanning === false) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top2 = active.pop();
        active.pop();
      }
      while (rendered < node5.marks.length) {
        var add3 = node5.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add3, node5.isInline, options);
        if (markDOM) {
          active.push(add3, top2);
          top2.appendChild(markDOM.dom);
          top2 = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top2.appendChild(this$1$1.serializeNodeInner(node5, options));
  });
  return target;
};
DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node5, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node5.type.name](node5));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node5.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node5, contentDOM, options);
    } else {
      this.serializeFragment(node5.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeNode = function serializeNode(node5, options) {
  if (options === void 0)
    options = {};
  var dom = this.serializeNodeInner(node5, options);
  for (var i2 = node5.marks.length - 1; i2 >= 0; i2--) {
    var wrap = this.serializeMark(node5.marks[i2], node5.isInline, options);
    if (wrap) {
      (wrap.contentDOM || wrap.dom).appendChild(dom);
      dom = wrap.dom;
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeMark = function serializeMark(mark3, inline2, options) {
  if (options === void 0)
    options = {};
  var toDOM = this.marks[mark3.type.name];
  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark3, inline2));
};
DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
  if (xmlNS === void 0)
    xmlNS = null;
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  if (structure.dom && structure.dom.nodeType != null) {
    return structure;
  }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  var attrs = structure[1], start4 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start4 = 2;
    for (var name in attrs) {
      if (attrs[name] != null) {
        var space$1 = name.indexOf(" ");
        if (space$1 > 0) {
          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
        } else {
          dom.setAttribute(name, attrs[name]);
        }
      }
    }
  }
  for (var i2 = start4; i2 < structure.length; i2++) {
    var child3 = structure[i2];
    if (child3 === 0) {
      if (i2 < structure.length - 1 || i2 > start4) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer.renderSpec(doc2, child3, xmlNS);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer.fromSchema = function fromSchema2(schema) {
  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
};
DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
  var result2 = gatherToDOM(schema.nodes);
  if (!result2.text) {
    result2.text = function(node5) {
      return node5.text;
    };
  }
  return result2;
};
DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
  return gatherToDOM(schema.marks);
};
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc(options) {
  return options.document || window.document;
}
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index3, offset3) {
  return index3 + offset3 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var MapResult = function MapResult2(pos, deleted, recover2) {
  if (deleted === void 0)
    deleted = false;
  if (recover2 === void 0)
    recover2 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover2;
};
var StepMap = function StepMap2(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  if (!ranges.length && StepMap2.empty) {
    return StepMap2.empty;
  }
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap.prototype.recover = function recover(value) {
  var diff = 0, index3 = recoverIndex(value);
  if (!this.inverted) {
    for (var i2 = 0; i2 < index3; i2++) {
      diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    }
  }
  return this.ranges[index3 * 3] + diff + recoverOffset(value);
};
StepMap.prototype.mapResult = function mapResult(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap.prototype.map = function map(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap.prototype._map = function _map(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end3 = start4 + oldSize;
    if (pos <= end3) {
      var side = !oldSize ? assoc : pos == start4 ? -1 : pos == end3 ? 1 : assoc;
      var result2 = start4 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover2 = pos == (assoc < 0 ? start4 : end3) ? null : makeRecover(i2 / 3, pos - start4);
      return new MapResult(result2, assoc < 0 ? pos != start4 : pos != end3, recover2);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff);
};
StepMap.prototype.touches = function touches(pos, recover2) {
  var diff = 0, index3 = recoverIndex(recover2);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], end3 = start4 + oldSize;
    if (pos <= end3 && i2 == index3 * 3) {
      return true;
    }
    diff += this.ranges[i2 + newIndex] - oldSize;
  }
  return false;
};
StepMap.prototype.forEach = function forEach3(f2) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2], oldStart = start4 - (this.inverted ? diff : 0), newStart = start4 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
    f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap.prototype.invert = function invert() {
  return new StepMap(this.ranges, !this.inverted);
};
StepMap.prototype.toString = function toString6() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap.offset = function offset2(n2) {
  return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
};
StepMap.empty = new StepMap([]);
var Mapping = function Mapping2(maps, mirror, from5, to) {
  this.maps = maps || [];
  this.from = from5 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping.prototype.slice = function slice3(from5, to) {
  if (from5 === void 0)
    from5 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping(this.maps, this.mirror, from5, to);
};
Mapping.prototype.copy = function copy3() {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping.prototype.appendMap = function appendMap(map14, mirrors) {
  this.to = this.maps.push(map14);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping.prototype.appendMapping = function appendMapping(mapping) {
  for (var i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : null);
  }
};
Mapping.prototype.getMirror = function getMirror(n2) {
  if (this.mirror) {
    for (var i2 = 0; i2 < this.mirror.length; i2++) {
      if (this.mirror[i2] == n2) {
        return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping.prototype.setMirror = function setMirror(n2, m2) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n2, m2);
};
Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
  for (var i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : null);
  }
};
Mapping.prototype.invert = function invert2() {
  var inverse = new Mapping();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping.prototype.map = function map2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i2 = this.from; i2 < this.to; i2++) {
    pos = this.maps[i2].map(pos, assoc);
  }
  return pos;
};
Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping.prototype._map = function _map2(pos, assoc, simple) {
  var deleted = false;
  for (var i2 = this.from; i2 < this.to; i2++) {
    var map14 = this.maps[i2], result2 = map14.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i2);
      if (corr != null && corr > i2 && corr < this.to) {
        i2 = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult(pos, deleted);
};
function TransformError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = TransformError.prototype;
  return err2;
}
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = function Transform2(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping();
};
var prototypeAccessors$4 = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$4.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform.prototype.step = function step(object) {
  var result2 = this.maybeStep(object);
  if (result2.failed) {
    throw new TransformError(result2.failed);
  }
  return this;
};
Transform.prototype.maybeStep = function maybeStep(step2) {
  var result2 = step2.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step2, result2.doc);
  }
  return result2;
};
prototypeAccessors$4.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform.prototype.addStep = function addStep(step2, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step2);
  this.mapping.appendMap(step2.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform.prototype, prototypeAccessors$4);
function mustOverride() {
  throw new Error("Override me");
}
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = function Step2() {
};
Step.prototype.apply = function apply(_doc) {
  return mustOverride();
};
Step.prototype.getMap = function getMap() {
  return StepMap.empty;
};
Step.prototype.invert = function invert3(_doc) {
  return mustOverride();
};
Step.prototype.map = function map3(_mapping) {
  return mustOverride();
};
Step.prototype.merge = function merge2(_other) {
  return null;
};
Step.prototype.toJSON = function toJSON5() {
  return mustOverride();
};
Step.fromJSON = function fromJSON5(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type = stepsByID[json.stepType];
  if (!type) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type.fromJSON(schema, json);
};
Step.jsonID = function jsonID(id2, stepClass) {
  if (id2 in stepsByID) {
    throw new RangeError("Duplicate use of step JSON ID " + id2);
  }
  stepsByID[id2] = stepClass;
  stepClass.prototype.jsonID = id2;
  return stepClass;
};
var StepResult = function StepResult2(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult.ok = function ok2(doc2) {
  return new StepResult(doc2, null);
};
StepResult.fail = function fail(message) {
  return new StepResult(null, message);
};
StepResult.fromReplace = function fromReplace(doc2, from5, to, slice5) {
  try {
    return StepResult.ok(doc2.replace(from5, to, slice5));
  } catch (e2) {
    if (e2 instanceof ReplaceError) {
      return StepResult.fail(e2.message);
    }
    throw e2;
  }
};
var ReplaceStep = /* @__PURE__ */ function(Step3) {
  function ReplaceStep2(from5, to, slice5, structure) {
    Step3.call(this);
    this.from = from5;
    this.to = to;
    this.slice = slice5;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceStep2.__proto__ = Step3;
  ReplaceStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to)) {
      return StepResult.fail("Structure replace would overwrite content");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap2() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert4(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map14(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from5.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from5.pos, Math.max(from5.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge4(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice5 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice5, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON7() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step);
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = /* @__PURE__ */ function(Step3) {
  function ReplaceAroundStep2(from5, to, gapFrom, gapTo, slice5, insert, structure) {
    Step3.call(this);
    this.from = from5;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice5;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceAroundStep2.__proto__ = Step3;
  ReplaceAroundStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply8(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
      return StepResult.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult.fail("Content does not fit in gap");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap2() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert4(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map14(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from5.deleted && to.deleted || gapFrom < from5.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from5.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON7() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from5, to) {
  var $from = doc2.resolve(from5), dist = to - from5, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next2 = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next2 || next2.isLeaf) {
        return true;
      }
      next2 = next2.firstChild;
      dist--;
    }
  }
  return false;
}
function canCut(node5, start4, end3) {
  return (start4 == 0 || node5.canReplace(start4, node5.childCount)) && (end3 == node5.childCount || node5.canReplace(0, end3));
}
function liftTarget(range) {
  var parent = range.parent;
  var content2 = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth; ; --depth) {
    var node5 = range.$from.node(depth);
    var index3 = range.$from.index(depth), endIndex2 = range.$to.indexAfter(depth);
    if (depth < range.depth && node5.canReplace(index3, endIndex2, content2)) {
      return depth;
    }
    if (depth == 0 || node5.type.spec.isolating || !canCut(node5, index3, endIndex2)) {
      break;
    }
  }
}
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start4 = gapStart, end3 = gapEnd;
  var before2 = Fragment.empty, openStart = 0;
  for (var d2 = depth, splitting = false; d2 > target; d2--) {
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before2 = Fragment.from($from.node(d2).copy(before2));
      openStart++;
    } else {
      start4--;
    }
  }
  var after2 = Fragment.empty, openEnd = 0;
  for (var d$12 = depth, splitting$1 = false; d$12 > target; d$12--) {
    if (splitting$1 || $to.after(d$12 + 1) < $to.end(d$12)) {
      splitting$1 = true;
      after2 = Fragment.from($to.node(d$12).copy(after2));
      openEnd++;
    } else {
      end3++;
    }
  }
  return this.step(new ReplaceAroundStep(start4, end3, gapStart, gapEnd, new Slice(before2.append(after2), openStart, openEnd), before2.size - openStart, true));
};
function findWrapping3(range, nodeType2, attrs, innerRange) {
  if (innerRange === void 0)
    innerRange = range;
  var around = findWrappingOutside(range, nodeType2);
  var inner = around && findWrappingInside(innerRange, nodeType2);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex2 = range.startIndex;
  var endIndex2 = range.endIndex;
  var around = parent.contentMatchAt(startIndex2).findWrapping(type);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex2, endIndex2, outer) ? around : null;
}
function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex2 = range.startIndex;
  var endIndex2 = range.endIndex;
  var inner = parent.child(startIndex2);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i2 = startIndex2; innerMatch && i2 < endIndex2; i2++) {
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
Transform.prototype.wrap = function(range, wrappers) {
  var content2 = Fragment.empty;
  for (var i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content2.size) {
      var match2 = wrappers[i2].type.contentMatch.matchFragment(content2);
      if (!match2 || !match2.validEnd) {
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
    }
    content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
  }
  var start4 = range.start, end3 = range.end;
  return this.step(new ReplaceAroundStep(start4, end3, start4, end3, new Slice(content2, 0, 0), wrappers.length, true));
};
Transform.prototype.setBlockType = function(from5, to, type, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from5;
  if (!type.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from5, to, function(node5, pos) {
    if (node5.isTextblock && !node5.hasMarkup(type, attrs) && canChangeType(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node5.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node5.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType(doc2, pos, type) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type);
}
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks2) {
  var node5 = this.doc.nodeAt(pos);
  if (!node5) {
    throw new RangeError("No node at given position");
  }
  if (!type) {
    type = node5.type;
  }
  var newNode = type.create(attrs, null, marks2 || node5.marks);
  if (node5.isLeaf) {
    return this.replaceWith(pos, pos + node5.nodeSize, newNode);
  }
  if (!type.validContent(node5.content)) {
    throw new RangeError("Invalid content for node type " + type.name);
  }
  return this.step(new ReplaceAroundStep(pos, pos + node5.nodeSize, pos + 1, pos + node5.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
};
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d2 = $pos.depth - 1, i2 = depth - 2; d2 > base2; d2--, i2--) {
    var node5 = $pos.node(d2), index$1 = $pos.index(d2);
    if (node5.type.spec.isolating) {
      return false;
    }
    var rest = node5.content.cutByIndex(index$1, node5.childCount);
    var after2 = typesAfter && typesAfter[i2] || node5;
    if (after2 != node5) {
      rest = rest.replaceChild(0, after2.type.create(after2.attrs));
    }
    if (!node5.canReplace(index$1 + 1, node5.childCount) || !after2.type.validContent(rest)) {
      return false;
    }
  }
  var index3 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
Transform.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before2 = Fragment.empty, after2 = Fragment.empty;
  for (var d2 = $pos.depth, e2 = $pos.depth - depth, i2 = depth - 1; d2 > e2; d2--, i2--) {
    before2 = Fragment.from($pos.node(d2).copy(before2));
    var typeAfter = typesAfter && typesAfter[i2];
    after2 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after2) : $pos.node(d2).copy(after2));
  }
  return this.step(new ReplaceStep(pos, pos, new Slice(before2.append(after2), depth, depth), true));
};
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function joinable(a2, b2) {
  return a2 && b2 && !a2.isLeaf && a2.canAppend(b2);
}
Transform.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step2 = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  return this.step(step2);
};
function insertPoint(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d2 = $pos.depth - 1; d2 >= 0; d2--) {
      var index3 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index3, index3, nodeType2)) {
        return $pos.before(d2 + 1);
      }
      if (index3 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$12 = $pos.depth - 1; d$12 >= 0; d$12--) {
      var index$1 = $pos.indexAfter(d$12);
      if ($pos.node(d$12).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$12 + 1);
      }
      if (index$1 < $pos.node(d$12).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice5) {
  var $pos = doc2.resolve(pos);
  if (!slice5.content.size) {
    return pos;
  }
  var content2 = slice5.content;
  for (var i2 = 0; i2 < slice5.openStart; i2++) {
    content2 = content2.firstChild.content;
  }
  for (var pass = 1; pass <= (slice5.openStart == 0 && slice5.size ? 2 : 1); pass++) {
    for (var d2 = $pos.depth; d2 >= 0; d2--) {
      var bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content2);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content2.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
      }
    }
  }
  return null;
}
function mapFragment(fragment, f2, parent) {
  var mapped = [];
  for (var i2 = 0; i2 < fragment.childCount; i2++) {
    var child3 = fragment.child(i2);
    if (child3.content.size) {
      child3 = child3.copy(mapFragment(child3.content, f2, child3));
    }
    if (child3.isInline) {
      child3 = f2(child3, parent, i2);
    }
    mapped.push(child3);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = /* @__PURE__ */ function(Step3) {
  function AddMarkStep2(from5, to, mark3) {
    Step3.call(this);
    this.from = from5;
    this.to = to;
    this.mark = mark3;
  }
  if (Step3)
    AddMarkStep2.__proto__ = Step3;
  AddMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node5, parent2) {
      if (!node5.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node5;
      }
      return node5.mark(this$1$1.mark.addToSet(node5.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  AddMarkStep2.prototype.invert = function invert4() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map14(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from5.deleted && to.deleted || from5.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from5.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge4(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step);
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = /* @__PURE__ */ function(Step3) {
  function RemoveMarkStep2(from5, to, mark3) {
    Step3.call(this);
    this.from = from5;
    this.to = to;
    this.mark = mark3;
  }
  if (Step3)
    RemoveMarkStep2.__proto__ = Step3;
  RemoveMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply8(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node5) {
      return node5.mark(this$1$1.mark.removeFromSet(node5.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  RemoveMarkStep2.prototype.invert = function invert4() {
    return new AddMarkStep(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map14(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from5.deleted && to.deleted || from5.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from5.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge4(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON8(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
Transform.prototype.addMark = function(from5, to, mark3) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from5, to, function(node5, pos, parent) {
    if (!node5.isInline) {
      return;
    }
    var marks2 = node5.marks;
    if (!mark3.isInSet(marks2) && parent.type.allowsMarkType(mark3.type)) {
      var start4 = Math.max(pos, from5), end3 = Math.min(pos + node5.nodeSize, to);
      var newSet = mark3.addToSet(marks2);
      for (var i2 = 0; i2 < marks2.length; i2++) {
        if (!marks2[i2].isInSet(newSet)) {
          if (removing && removing.to == start4 && removing.mark.eq(marks2[i2])) {
            removing.to = end3;
          } else {
            removed.push(removing = new RemoveMarkStep(start4, end3, marks2[i2]));
          }
        }
      }
      if (adding && adding.to == start4) {
        adding.to = end3;
      } else {
        added.push(adding = new AddMarkStep(start4, end3, mark3));
      }
    }
  });
  removed.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  added.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  return this;
};
Transform.prototype.removeMark = function(from5, to, mark3) {
  var this$1$1 = this;
  if (mark3 === void 0)
    mark3 = null;
  var matched = [], step2 = 0;
  this.doc.nodesBetween(from5, to, function(node5, pos) {
    if (!node5.isInline) {
      return;
    }
    step2++;
    var toRemove = null;
    if (mark3 instanceof MarkType) {
      var set2 = node5.marks, found2;
      while (found2 = mark3.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark3) {
      if (mark3.isInSet(node5.marks)) {
        toRemove = [mark3];
      }
    } else {
      toRemove = node5.marks;
    }
    if (toRemove && toRemove.length) {
      var end3 = Math.min(pos + node5.nodeSize, to);
      for (var i2 = 0; i2 < toRemove.length; i2++) {
        var style2 = toRemove[i2], found$1 = void 0;
        for (var j2 = 0; j2 < matched.length; j2++) {
          var m2 = matched[j2];
          if (m2.step == step2 - 1 && style2.eq(matched[j2].style)) {
            found$1 = m2;
          }
        }
        if (found$1) {
          found$1.to = end3;
          found$1.step = step2;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from5), to: end3, step: step2 });
        }
      }
    }
  });
  matched.forEach(function(m2) {
    return this$1$1.step(new RemoveMarkStep(m2.from, m2.to, m2.style));
  });
  return this;
};
Transform.prototype.clearIncompatible = function(pos, parentType, match2) {
  if (match2 === void 0)
    match2 = parentType.contentMatch;
  var node5 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i2 = 0; i2 < node5.childCount; i2++) {
    var child3 = node5.child(i2), end3 = cur + child3.nodeSize;
    var allowed = match2.matchType(child3.type, child3.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end3, Slice.empty));
    } else {
      match2 = allowed;
      for (var j2 = 0; j2 < child3.marks.length; j2++) {
        if (!parentType.allowsMarkType(child3.marks[j2].type)) {
          this.step(new RemoveMarkStep(cur, end3, child3.marks[j2]));
        }
      }
    }
    cur = end3;
  }
  if (!match2.validEnd) {
    var fill = match2.fillBefore(Fragment.empty, true);
    this.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep(doc2, from5, to, slice5) {
  if (to === void 0)
    to = from5;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  if (from5 == to && !slice5.size) {
    return null;
  }
  var $from = doc2.resolve(from5), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice5)) {
    return new ReplaceStep(from5, to, slice5);
  }
  return new Fitter($from, $to, slice5).fit();
}
Transform.prototype.replace = function(from5, to, slice5) {
  if (to === void 0)
    to = from5;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  var step2 = replaceStep(this.doc, from5, to, slice5);
  if (step2) {
    this.step(step2);
  }
  return this;
};
Transform.prototype.replaceWith = function(from5, to, content2) {
  return this.replace(from5, to, new Slice(Fragment.from(content2), 0, 0));
};
Transform.prototype.delete = function(from5, to) {
  return this.replace(from5, to, Slice.empty);
};
Transform.prototype.insert = function(pos, content2) {
  return this.replaceWith(pos, pos, content2);
};
function fitsTrivially($from, $to, slice5) {
  return !slice5.openStart && !slice5.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice5.content);
}
var Fitter = function Fitter2($from, $to, slice5) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice5;
  this.frontier = [];
  for (var i2 = 0; i2 <= $from.depth; i2++) {
    var node5 = $from.node(i2);
    this.frontier.push({
      type: node5.type,
      match: node5.contentMatchAt($from.indexAfter(i2))
    });
  }
  this.placed = Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$2 = { depth: { configurable: true } };
prototypeAccessors$1$2.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter.prototype.fit = function fit() {
  while (this.unplaced.size) {
    var fit2 = this.findFittable();
    if (fit2) {
      this.placeNodes(fit2);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content2 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content2.childCount == 1) {
    content2 = content2.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice5 = new Slice(content2, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice5, placedSize);
  }
  if (slice5.size || $from.pos != this.$to.pos) {
    return new ReplaceStep($from.pos, $to.pos, slice5);
  }
};
Fitter.prototype.findFittable = function findFittable() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first2 = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref = this.frontier[frontierDepth];
        var type = ref.type;
        var match2 = ref.match;
        var wrap = void 0, inject = void 0;
        if (pass == 1 && (first2 ? match2.matchType(first2.type) || (inject = match2.fillBefore(Fragment.from(first2), false)) : type.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject };
        } else if (pass == 2 && first2 && (wrap = match2.findWrapping(first2.type))) {
          return { sliceDepth, frontierDepth, parent, wrap };
        }
        if (parent && match2.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter.prototype.openMore = function openMore() {
  var ref = this.unplaced;
  var content2 = ref.content;
  var openStart = ref.openStart;
  var openEnd = ref.openEnd;
  var inner = contentAt(content2, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice(content2, openStart + 1, Math.max(openEnd, inner.size + openStart >= content2.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter.prototype.dropNode = function dropNode() {
  var ref = this.unplaced;
  var content2 = ref.content;
  var openStart = ref.openStart;
  var openEnd = ref.openEnd;
  var inner = contentAt(content2, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content2.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice(dropFromFragment(content2, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice(dropFromFragment(content2, openStart, 1), openStart, openEnd);
  }
};
Fitter.prototype.placeNodes = function placeNodes(ref) {
  var sliceDepth = ref.sliceDepth;
  var frontierDepth = ref.frontierDepth;
  var parent = ref.parent;
  var inject = ref.inject;
  var wrap = ref.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap) {
    for (var i2 = 0; i2 < wrap.length; i2++) {
      this.openFrontierNode(wrap[i2]);
    }
  }
  var slice5 = this.unplaced, fragment = parent ? parent.content : slice5.content;
  var openStart = slice5.openStart - sliceDepth;
  var taken = 0, add3 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match2 = ref$1.match;
  var type = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
      add3.push(inject.child(i$1));
    }
    match2 = match2.matchFragment(inject);
  }
  var openEndCount = fragment.size + sliceDepth - (slice5.content.size - slice5.openEnd);
  while (taken < fragment.childCount) {
    var next2 = fragment.child(taken), matches2 = match2.matchType(next2.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next2.content.size) {
      match2 = matches2;
      add3.push(closeNodeStart(next2.mark(type.allowedMarks(next2.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
  this.frontier[frontierDepth].match = match2;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$22 = 0, cur = fragment; i$22 < openEndCount; i$22++) {
    var node5 = cur.lastChild;
    this.frontier.push({ type: node5.type, match: node5.contentMatchAt(node5.childCount) });
    cur = node5.content;
  }
  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice5.content, sliceDepth, taken), slice5.openStart, slice5.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice5.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice5.openEnd : sliceDepth - 1);
};
Fitter.prototype.mustMoveInline = function mustMoveInline() {
  if (!this.$to.parent.isTextblock) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref = this.$to;
  var depth = ref.depth;
  var after2 = this.$to.after(depth);
  while (depth > 1 && after2 == this.$to.end(--depth)) {
    ++after2;
  }
  return after2;
};
Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
  scan:
    for (var i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
      var ref = this.frontier[i2];
      var match2 = ref.match;
      var type = ref.type;
      var dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
      var fit2 = contentAfterFits($to, i2, type, match2, dropInner);
      if (!fit2) {
        continue;
      }
      for (var d2 = i2 - 1; d2 >= 0; d2--) {
        var ref$1 = this.frontier[d2];
        var match$12 = ref$1.match;
        var type$1 = ref$1.type;
        var matches2 = contentAfterFits($to, d2, type$1, match$12, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i2, fit: fit2, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
    }
};
Fitter.prototype.close = function close2($to) {
  var close3 = this.findCloseLevel($to);
  if (!close3) {
    return null;
  }
  while (this.depth > close3.depth) {
    this.closeFrontierNode();
  }
  if (close3.fit.childCount) {
    this.placed = addToFragment(this.placed, close3.depth, close3.fit);
  }
  $to = close3.move;
  for (var d2 = close3.depth + 1; d2 <= $to.depth; d2++) {
    var node5 = $to.node(d2), add3 = node5.type.contentMatch.fillBefore(node5.content, true, $to.index(d2));
    this.openFrontierNode(node5.type, node5.attrs, add3);
  }
  return $to;
};
Fitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content2) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type);
  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content2)));
  this.frontier.push({ type, match: type.contentMatch });
};
Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
  var open = this.frontier.pop();
  var add3 = open.match.fillBefore(Fragment.empty, true);
  if (add3.childCount) {
    this.placed = addToFragment(this.placed, this.frontier.length, add3);
  }
};
Object.defineProperties(Fitter.prototype, prototypeAccessors$1$2);
function dropFromFragment(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content2) {
  if (depth == 0) {
    return fragment.append(content2);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content2)));
}
function contentAt(fragment, depth) {
  for (var i2 = 0; i2 < depth; i2++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart(node5, openStart, openEnd) {
  if (openStart <= 0) {
    return node5;
  }
  var frag = node5.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node5.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node5.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
  }
  return node5.copy(frag);
}
function contentAfterFits($to, depth, type, match2, open) {
  var node5 = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node5.childCount && !type.compatibleContent(node5.type)) {
    return null;
  }
  var fit2 = match2.fillBefore(node5.content, true, index3);
  return fit2 && !invalidMarks(type, node5.content, index3) ? fit2 : null;
}
function invalidMarks(type, fragment, start4) {
  for (var i2 = start4; i2 < fragment.childCount; i2++) {
    if (!type.allowsMarks(fragment.child(i2).marks)) {
      return true;
    }
  }
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
Transform.prototype.replaceRange = function(from5, to, slice5) {
  if (!slice5.size) {
    return this.deleteRange(from5, to);
  }
  var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice5)) {
    return this.step(new ReplaceStep(from5, to, slice5));
  }
  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    var spec = $from.node(d2).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d2) > -1) {
      preferredTarget = d2;
    } else if ($from.before(d2) == pos) {
      targetDepths.splice(1, 0, -d2);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice5.openStart;
  for (var content2 = slice5.content, i2 = 0; ; i2++) {
    var node5 = content2.firstChild;
    leftNodes.push(node5);
    if (i2 == slice5.openStart) {
      break;
    }
    content2 = node5.content;
  }
  for (var d$12 = preferredDepth - 1; d$12 >= 0; d$12--) {
    var type = leftNodes[d$12].type, def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type) {
      preferredDepth = d$12;
    } else if (def || !type.isTextblock) {
      break;
    }
  }
  for (var j2 = slice5.openStart; j2 >= 0; j2--) {
    var openDepth = (j2 + preferredDepth + 1) % (slice5.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice5.content, 0, slice5.openStart, openDepth), openDepth, slice5.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$22 = targetDepths.length - 1; i$22 >= 0; i$22--) {
    this.replace(from5, to, slice5);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$22];
    if (depth < 0) {
      continue;
    }
    from5 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    var match2 = parent.contentMatchAt(0);
    var start4 = match2.fillBefore(fragment).append(fragment);
    fragment = start4.append(match2.matchFragment(start4).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
Transform.prototype.replaceRangeWith = function(from5, to, node5) {
  if (!node5.isInline && from5 == to && this.doc.resolve(from5).parent.content.size) {
    var point = insertPoint(this.doc, from5, node5.type);
    if (point != null) {
      from5 = to = point;
    }
  }
  return this.replaceRange(from5, to, new Slice(Fragment.from(node5), 0, 0));
};
Transform.prototype.deleteRange = function(from5, to) {
  var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i2 = 0; i2 < covered.length; i2++) {
    var depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from5 - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2) {
      return this.delete($from.before(d2), to);
    }
  }
  return this.delete(from5, to);
};
function coveredDepths($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d2 = minDepth; d2 >= 0; d2--) {
    var start4 = $from.start(d2);
    if (start4 < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating) {
      break;
    }
    if (start4 == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start4 - 1) {
      result2.push(d2);
    }
  }
  return result2;
}
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = function Selection2($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$3 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$3.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$3.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$3.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$3.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$3.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$3.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$3.empty.get = function() {
  var ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    if (ranges[i2].$from.pos != ranges[i2].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection.prototype.content = function content() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection.prototype.replace = function replace2(tr, content2) {
  if (content2 === void 0)
    content2 = Slice.empty;
  var lastNode = content2.content.lastChild, lastParent = null;
  for (var i2 = 0; i2 < content2.openEnd; i2++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref = ranges[i$1];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content2);
    if (i$1 == 0) {
      selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection.prototype.replaceWith = function replaceWith(tr, node5) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    var ref = ranges[i2];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from5 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i2) {
      tr.deleteRange(from5, to);
    } else {
      tr.replaceRangeWith(from5, to, node5);
      selectionToInsertionEnd$1(tr, mapFrom, node5.isInline ? -1 : 1);
    }
  }
};
Selection.findFrom = function findFrom($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection.near = function near($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
};
Selection.atStart = function atStart(doc2) {
  return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
};
Selection.atEnd = function atEnd(doc2) {
  return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
};
Selection.fromJSON = function fromJSON6(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection.jsonID = function jsonID2(id2, selectionClass) {
  if (id2 in classesById) {
    throw new RangeError("Duplicate use of selection JSON ID " + id2);
  }
  classesById[id2] = selectionClass;
  selectionClass.prototype.jsonID = id2;
  return selectionClass;
};
Selection.prototype.getBookmark = function getBookmark() {
  return TextSelection.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection.prototype, prototypeAccessors$3);
Selection.prototype.visible = true;
var SelectionRange = function SelectionRange2($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection = /* @__PURE__ */ function(Selection3) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection3.call(this, $anchor, $head);
  }
  if (Selection3)
    TextSelection2.__proto__ = Selection3;
  TextSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map14(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection3.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace3(tr, content2) {
    if (content2 === void 0)
      content2 = Slice.empty;
    Selection3.prototype.replace.call(this, tr, content2);
    if (content2 == Slice.empty) {
      var marks2 = this.$from.marksAcross(this.$to);
      if (marks2) {
        tr.ensureMarks(marks2);
      }
    }
  };
  TextSelection2.prototype.eq = function eq12(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark2() {
    return new TextBookmark(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON7() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create6(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection3.findFrom($head, bias, true) || Selection3.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection3.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection3.findFrom($anchor, -bias, true) || Selection3.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection);
Selection.jsonID("text", TextSelection);
var TextBookmark = function TextBookmark2(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark.prototype.map = function map4(mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark.prototype.resolve = function resolve3(doc2) {
  return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection = /* @__PURE__ */ function(Selection3) {
  function NodeSelection2($pos) {
    var node5 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node5.nodeSize);
    Selection3.call(this, $pos, $end);
    this.node = node5;
  }
  if (Selection3)
    NodeSelection2.__proto__ = Selection3;
  NodeSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map14(doc2, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection3.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content2() {
    return new Slice(Fragment.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq12(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON7() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark2() {
    return new NodeBookmark(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create6(doc2, from5) {
    return new this(doc2.resolve(from5));
  };
  NodeSelection2.isSelectable = function isSelectable(node5) {
    return !node5.isText && node5.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection);
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = function NodeBookmark2(anchor) {
  this.anchor = anchor;
};
NodeBookmark.prototype.map = function map5(mapping) {
  var ref = mapping.mapResult(this.anchor);
  var deleted = ref.deleted;
  var pos = ref.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
};
NodeBookmark.prototype.resolve = function resolve4(doc2) {
  var $pos = doc2.resolve(this.anchor), node5 = $pos.nodeAfter;
  if (node5 && NodeSelection.isSelectable(node5)) {
    return new NodeSelection($pos);
  }
  return Selection.near($pos);
};
var AllSelection = /* @__PURE__ */ function(Selection3) {
  function AllSelection2(doc2) {
    Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection3)
    AllSelection2.__proto__ = Selection3;
  AllSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace3(tr, content2) {
    if (content2 === void 0)
      content2 = Slice.empty;
    if (content2 == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection3.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection3.prototype.replace.call(this, tr, content2);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON7() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON8(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map14(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq12(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark2() {
    return AllBookmark;
  };
  return AllSelection2;
}(Selection);
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map6() {
    return this;
  },
  resolve: function resolve5(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node5, pos, index3, dir, text3) {
  if (node5.inlineContent) {
    return TextSelection.create(doc2, pos);
  }
  for (var i2 = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node5.childCount : i2 >= 0; i2 += dir) {
    var child3 = node5.child(i2);
    if (!child3.isAtom) {
      var inner = findSelectionIn(doc2, child3, pos + dir, dir < 0 ? child3.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection.isSelectable(child3)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child3.nodeSize : 0));
    }
    pos += child3.nodeSize * dir;
  }
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step2 = tr.steps[last];
  if (!(step2 instanceof ReplaceStep || step2 instanceof ReplaceAroundStep)) {
    return;
  }
  var map14 = tr.mapping.maps[last], end3;
  map14.forEach(function(_from, _to, _newFrom, newTo) {
    if (end3 == null) {
      end3 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
var Transaction = /* @__PURE__ */ function(Transform3) {
  function Transaction2(state) {
    Transform3.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform3)
    Transaction2.__proto__ = Transform3;
  Transaction2.prototype = Object.create(Transform3 && Transform3.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection2(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks2) {
    this.storedMarks = marks2;
    this.updated |= UPDATED_MARKS;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks2(marks2) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks2)) {
      this.setStoredMarks(marks2);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark3) {
    return this.ensureMarks(mark3.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark3) {
    return this.ensureMarks(mark3.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS) > 0;
  };
  Transaction2.prototype.addStep = function addStep2(step2, doc2) {
    Transform3.prototype.addStep.call(this, step2, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice5) {
    this.selection.replace(this, slice5);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node5, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node5 = node5.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    }
    selection.replaceWith(this, node5);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text3, from5, to) {
    if (to === void 0)
      to = from5;
    var schema = this.doc.type.schema;
    if (from5 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from5, to);
      }
      var marks2 = this.storedMarks;
      if (!marks2) {
        var $from = this.doc.resolve(from5);
        marks2 = to == from5 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from5, to, schema.text(text3, marks2));
      if (!this.selection.empty) {
        this.setSelection(Selection.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta2(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _2 in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView2() {
    this.updated |= UPDATED_SCROLL;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform);
function bind(f2, self) {
  return !self || !f2 ? f2 : f2.bind(self);
}
var FieldDesc = function FieldDesc2(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};
var baseFields = [
  new FieldDesc("doc", {
    init: function init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply: function apply2(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init: function init2(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply: function apply3(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init: function init3(config) {
      return config.storedMarks || null;
    },
    apply: function apply4(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init: function init4() {
      return 0;
    },
    apply: function apply5(tr, prev2) {
      return tr.scrolledIntoView ? prev2 + 1 : prev2;
    }
  })
];
var Configuration = function Configuration2(schema, plugins) {
  var this$1$1 = this;
  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState = function EditorState2(config) {
  this.config = config;
};
var prototypeAccessors$1$1 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$1.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$1.plugins.get = function() {
  return this.config.plugins;
};
EditorState.prototype.apply = function apply6(tr) {
  return this.applyTransaction(tr).state;
};
EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
    if (i2 != ignore) {
      var plugin = this.config.plugins[i2];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
      var plugin = this.config.plugins[i2];
      if (plugin.spec.appendTransaction) {
        var n2 = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
        var tr = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i2)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j2 = 0; j2 < this.config.plugins.length; j2++) {
              seen.push(j2 < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i2] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState.prototype.applyInner = function applyInner(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i2 = 0; i2 < fields.length; i2++) {
    var field = fields[i2];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
    applyListeners[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$1.tr.get = function() {
  return new Transaction(this);
};
EditorState.create = function create4(config) {
  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState($config);
  for (var i2 = 0; i2 < $config.fields.length; i2++) {
    instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
  }
  return instance;
};
EditorState.prototype.reconfigure = function reconfigure(config) {
  var $config = new Configuration(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i2 = 0; i2 < fields.length; i2++) {
    var name = fields[i2].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
  }
  return instance;
};
EditorState.prototype.toJSON = function toJSON6(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m2) {
      return m2.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState.fromJSON = function fromJSON7(config, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration(config.schema, config.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node$1.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance;
};
EditorState.addApplyListener = function addApplyListener(f2) {
  applyListeners.push(f2);
};
EditorState.removeApplyListener = function removeApplyListener(f2) {
  var found2 = applyListeners.indexOf(f2);
  if (found2 > -1) {
    applyListeners.splice(found2, 1);
  }
};
Object.defineProperties(EditorState.prototype, prototypeAccessors$1$1);
var applyListeners = [];
function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) {
      val = val.bind(self);
    } else if (prop == "handleDOMEvents") {
      val = bindProps(val, self, {});
    }
    target[prop] = val;
  }
  return target;
}
var Plugin = function Plugin2(spec) {
  this.props = {};
  if (spec.props) {
    bindProps(spec.props, this, this.props);
  }
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};
Plugin.prototype.getState = function getState(state) {
  return state[this.key];
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys) {
    return name + "$" + ++keys[name];
  }
  keys[name] = 0;
  return name + "$";
}
var PluginKey = function PluginKey2(name) {
  if (name === void 0)
    name = "key";
  this.key = createKey(name);
};
PluginKey.prototype.get = function get(state) {
  return state.config.pluginsByKey[this.key];
};
PluginKey.prototype.getState = function getState2(state) {
  return state[this.key];
};
function deleteSelection$2(state, dispatch2) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward$2(state, dispatch2, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  var before2 = $cut.nodeBefore;
  if (!before2.type.spec.isolating && deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before2, "end") || NodeSelection.isSelectable(before2))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before2, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before2.nodeSize));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos - before2.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node5, side, only) {
  for (; node5; node5 = side == "start" ? node5.firstChild : node5.lastChild) {
    if (node5.isTextblock) {
      return true;
    }
    if (only && node5.childCount != 1) {
      return false;
    }
  }
  return false;
}
function selectNodeBackward$2(state, dispatch2, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty2 = ref.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
      return false;
    }
    $cut = findCutBefore($head);
  }
  var node5 = $cut && $cut.nodeBefore;
  if (!node5 || !NodeSelection.isSelectable(node5)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node5.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0) {
        return $pos.doc.resolve($pos.before(i2 + 1));
      }
      if ($pos.node(i2).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward$2(state, dispatch2, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after2 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after2, "start") || NodeSelection.isSelectable(after2))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after2, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after2.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward$2(state, dispatch2, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty2 = ref.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
      return false;
    }
    $cut = findCutAfter($head);
  }
  var node5 = $cut && $cut.nodeAfter;
  if (!node5 || !NodeSelection.isSelectable(node5)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      var parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i2 + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function lift$2(state, dispatch2) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  var range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  }
  return true;
}
function newlineInCode$2(state, dispatch2) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function defaultBlockAt(match2) {
  for (var i2 = 0; i2 < match2.edgeCount; i2++) {
    var ref = match2.edge(i2);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function exitCode$2(state, dispatch2) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after2 = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after2));
  if (!above.canReplaceWith(after2, after2, type)) {
    return false;
  }
  if (dispatch2) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear$2(state, dispatch2) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) {
    return false;
  }
  if (dispatch2) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock$2(state, dispatch2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before2 = $cursor.before();
    if (canSplit(state.doc, before2)) {
      if (dispatch2) {
        dispatch2(state.tr.split(before2).scrollIntoView());
      }
      return true;
    }
  }
  var range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  }
  return true;
}
function splitBlock$2(state, dispatch2) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    var atEnd2 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd2 && deflt ? [{ type: deflt }] : null;
    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd2 && !$from.parentOffset && $from.parent.type != deflt) {
        var first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function selectParentNode$2(state, dispatch2) {
  var ref = state.selection;
  var $from = ref.$from;
  var to = ref.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) {
    return false;
  }
  pos = $from.before(same);
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  }
  return true;
}
function selectAll$2(state, dispatch2) {
  if (dispatch2) {
    dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch2) {
  var before2 = $pos.nodeBefore, after2 = $pos.nodeAfter, index3 = $pos.index();
  if (!before2 || !after2 || !before2.type.compatibleContent(after2.type)) {
    return false;
  }
  if (!before2.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch2) {
      dispatch2(state.tr.delete($pos.pos - before2.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after2.isTextblock || canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.clearIncompatible($pos.pos, before2.type, before2.contentMatchAt(before2.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch2) {
  var before2 = $cut.nodeBefore, after2 = $cut.nodeAfter, conn, match2;
  if (before2.type.spec.isolating || after2.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch2)) {
    return true;
  }
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match2 = before2.contentMatchAt(before2.childCount)).findWrapping(after2.type)) && match2.matchType(conn[0] || after2.type).validEnd) {
    if (dispatch2) {
      var end3 = $cut.pos + after2.nodeSize, wrap = Fragment.empty;
      for (var i2 = conn.length - 1; i2 >= 0; i2--) {
        wrap = Fragment.from(conn[i2].create(null, wrap));
      }
      wrap = Fragment.from(before2.copy(wrap));
      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end3, $cut.pos, end3, new Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end3 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch2) {
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  if (canDelAfter && textblockAt(after2, "start", true) && textblockAt(before2, "end")) {
    var at2 = before2, wrap$1 = [];
    for (; ; ) {
      wrap$1.push(at2);
      if (at2.isTextblock) {
        break;
      }
      at2 = at2.lastChild;
    }
    var afterText = after2, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        var end$1 = Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
          end$1 = Fragment.from(wrap$1[i$1].copy(end$1));
        }
        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after2.nodeSize, $cut.pos + afterDepth, $cut.pos + after2.nodeSize - afterDepth, new Slice(end$1, wrap$1.length, 0), 0, true));
        dispatch2(tr$1.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth) {
        return false;
      }
      depth--;
    }
    if (!$pos.node(depth).isTextblock) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    }
    return true;
  };
}
var selectTextblockStart$2 = selectTextblockSide(-1);
var selectTextblockEnd$2 = selectTextblockSide(1);
function wrapIn$2(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && findWrapping3(range, nodeType2, attrs);
    if (!wrapping) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
    }
    return true;
  };
}
function setBlockType(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var from5 = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from5, to, function(node5, pos) {
      if (applicable) {
        return false;
      }
      if (!node5.isTextblock || node5.hasMarkup(nodeType2, attrs)) {
        return;
      }
      if (node5.type == nodeType2) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index3 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType2);
      }
    });
    if (!applicable) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setBlockType(from5, to, nodeType2, attrs).scrollIntoView());
    }
    return true;
  };
}
function chainCommands() {
  var commands = [], len = arguments.length;
  while (len--)
    commands[len] = arguments[len];
  return function(state, dispatch2, view) {
    for (var i2 = 0; i2 < commands.length; i2++) {
      if (commands[i2](state, dispatch2, view)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection$2, joinBackward$2, selectNodeBackward$2);
var del = chainCommands(deleteSelection$2, joinForward$2, selectNodeForward$2);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode$2, createParagraphNear$2, liftEmptyBlock$2, splitBlock$2),
  "Mod-Enter": exitCode$2,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll$2
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart$2,
  "Ctrl-e": selectTextblockEnd$2
};
for (var key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
function wrapInList$2(listType, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range) {
      return false;
    }
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0) {
        return false;
      }
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) {
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      }
      doJoin = true;
    }
    var wrap = findWrapping3(outerRange, listType, attrs, range);
    if (!wrap) {
      return false;
    }
    if (dispatch2) {
      dispatch2(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
    }
    return true;
  };
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content2 = Fragment.empty;
  for (var i2 = wrappers.length - 1; i2 >= 0; i2--) {
    content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
  }
  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content2, 0, 0), wrappers.length, true));
  var found2 = 0;
  for (var i$1 = 0; i$1 < wrappers.length; i$1++) {
    if (wrappers[i$1].type == listType) {
      found2 = i$1 + 1;
    }
  }
  var splitDepth = wrappers.length - found2;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (var i$22 = range.startIndex, e2 = range.endIndex, first2 = true; i$22 < e2; i$22++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i$22).nodeSize;
  }
  return tr;
}
function liftListItem$2(itemType) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node5) {
      return node5.childCount && node5.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    if (!dispatch2) {
      return true;
    }
    if ($from.node(range.depth - 1).type == itemType) {
      return liftToOuterList(state, dispatch2, itemType, range);
    } else {
      return liftOutOfList(state, dispatch2, range);
    }
  };
}
function liftToOuterList(state, dispatch2, itemType, range) {
  var tr = state.tr, end3 = range.end, endOfList = range.$to.end(range.depth);
  if (end3 < endOfList) {
    tr.step(new ReplaceAroundStep(end3 - 1, endOfList, end3, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  dispatch2(tr.lift(range, liftTarget(range)).scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range) {
  var tr = state.tr, list = range.parent;
  for (var pos = range.end, i2 = range.endIndex - 1, e2 = range.startIndex; i2 > e2; i2--) {
    pos -= list.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) {
    return false;
  }
  var atStart2 = range.startIndex == 0, atEnd2 = range.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart2 ? 0 : 1), indexBefore + 1, item.content.append(atEnd2 ? Fragment.empty : Fragment.from(list)))) {
    return false;
  }
  var start4 = $start.pos, end3 = start4 + item.nodeSize;
  tr.step(new ReplaceAroundStep(start4 - (atStart2 ? 1 : 0), end3 + (atEnd2 ? 1 : 0), start4 + 1, end3 - 1, new Slice((atStart2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd2 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart2 ? 0 : 1, atEnd2 ? 0 : 1), atStart2 ? 0 : 1));
  dispatch2(tr.scrollIntoView());
  return true;
}
function sinkListItem$2(itemType) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node5) {
      return node5.childCount && node5.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    var startIndex2 = range.startIndex;
    if (startIndex2 == 0) {
      return false;
    }
    var parent = range.parent, nodeBefore = parent.child(startIndex2 - 1);
    if (nodeBefore.type != itemType) {
      return false;
    }
    if (dispatch2) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = Fragment.from(nestedBefore ? itemType.create() : null);
      var slice5 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before2 = range.start, after2 = range.end;
      dispatch2(state.tr.step(new ReplaceAroundStep(before2 - (nestedBefore ? 3 : 1), after2, before2, after2, slice5, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var result = {};
if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie$2 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie$2 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome$1 = !ie$2 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome$1;
  result.chrome_version = chrome$1 && +chrome$1[1];
  result.safari = !ie$2 && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.mac = result.ios || /Mac/.test(navigator.platform);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}
var domIndex = function(node5) {
  for (var index3 = 0; ; index3++) {
    node5 = node5.previousSibling;
    if (!node5) {
      return index3;
    }
  }
};
var parentNode = function(node5) {
  var parent = node5.assignedSlot || node5.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node5, from5, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node5, to == null ? node5.nodeValue.length : to);
  range.setStart(node5, from5 || 0);
  return range;
};
var isEquivalentPosition = function(node5, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node5, off2, targetNode, targetOff, -1) || scanFor(node5, off2, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node5, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node5 == targetNode && off2 == targetOff) {
      return true;
    }
    if (off2 == (dir < 0 ? 0 : nodeSize(node5))) {
      var parent = node5.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node5) || atomElements.test(node5.nodeName) || node5.contentEditable == "false") {
        return false;
      }
      off2 = domIndex(node5) + (dir < 0 ? 0 : 1);
      node5 = parent;
    } else if (node5.nodeType == 1) {
      node5 = node5.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node5.contentEditable == "false") {
        return false;
      }
      off2 = dir < 0 ? nodeSize(node5) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isOnEdge(node5, offset3, parent) {
  for (var atStart2 = offset3 == 0, atEnd2 = offset3 == nodeSize(node5); atStart2 || atEnd2; ) {
    if (node5 == parent) {
      return true;
    }
    var index3 = domIndex(node5);
    node5 = node5.parentNode;
    if (!node5) {
      return false;
    }
    atStart2 = atStart2 && index3 == 0;
    atEnd2 = atEnd2 && index3 == nodeSize(node5);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node5) {
  var rect = node5.getBoundingClientRect();
  var scaleX2 = rect.width / node5.offsetWidth || 1;
  var scaleY2 = rect.height / node5.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node5.clientWidth * scaleX2,
    top: rect.top,
    bottom: rect.top + node5.clientHeight * scaleY2
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc2) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    var dom = view.root.elementFromPoint(x2, y2);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i2 = 0; i2 < stack.length; i2++) {
    var ref = stack[i2];
    var dom = ref.dom;
    var top2 = ref.top;
    var left2 = ref.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left2) {
      dom.scrollLeft = left2;
    }
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node5, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset3 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child3 = node5.firstChild, childIndex = 0; child3; child3 = child3.nextSibling, childIndex++) {
    var rects = void 0;
    if (child3.nodeType == 1) {
      rects = child3.getClientRects();
    } else if (child3.nodeType == 3) {
      rects = textRange(child3).getClientRects();
    } else {
      continue;
    }
    for (var i2 = 0; i2 < rects.length; i2++) {
      var rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child3;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child3.nodeType == 1 && dx) {
            offset3 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset3 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node5, offset: offset3 };
  }
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node5, coords) {
  var len = node5.nodeValue.length;
  var range = document.createRange();
  for (var i2 = 0; i2 < len; i2++) {
    range.setEnd(node5, i2 + 1);
    range.setStart(node5, i2);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect(coords, rect)) {
      return { node: node5, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node5, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node5 = ref.node;
  var offset3 = ref.offset;
  var bias = -1;
  if (node5.nodeType == 1 && !node5.firstChild) {
    var rect = node5.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node5, offset3, bias);
}
function posFromCaret(view, node5, offset3, coords) {
  var outside = -1;
  for (var cur = node5; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node5, offset3);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      var child3 = element.childNodes[i2];
      if (child3.nodeType == 1) {
        var rects = child3.getClientRects();
        for (var j2 = 0; j2 < rects.length; j2++) {
          var rect = rects[j2];
          if (inRect(coords, rect)) {
            return elementFromPoint(child3, coords, rect);
          }
        }
      }
      if ((i2 = (i2 + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign2, assign$12;
  var doc2 = view.dom.ownerDocument, node5, offset3;
  if (doc2.caretPositionFromPoint) {
    try {
      var pos$1 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign2 = pos$1, node5 = assign2.offsetNode, offset3 = assign2.offset;
      }
    } catch (_2) {
    }
  }
  if (!node5 && doc2.caretRangeFromPoint) {
    var range = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      assign$12 = range, node5 = assign$12.startContainer, offset3 = assign$12.startOffset;
    }
  }
  var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari) {
    for (var p2 = elt; node5 && p2; p2 = parentNode(p2)) {
      if (p2.draggable) {
        node5 = offset3 = null;
      }
    }
  }
  elt = targetKludge(elt, coords);
  if (node5) {
    if (result.gecko && node5.nodeType == 1) {
      offset3 = Math.min(offset3, node5.childNodes.length);
      if (offset3 < node5.childNodes.length) {
        var next2 = node5.childNodes[offset3], box$1;
        if (next2.nodeName == "IMG" && (box$1 = next2.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset3++;
        }
      }
    }
    if (node5 == view.dom && offset3 == node5.childNodes.length - 1 && node5.lastChild.nodeType == 1 && coords.top > node5.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset3 == 0 || node5.nodeType != 1 || node5.childNodes[offset3 - 1].nodeName != "BR") {
      pos = posFromCaret(view, node5, offset3, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node5 = ref.node;
  var offset3 = ref.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node5.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node5.nodeValue) || (side < 0 ? !offset3 : offset3 == node5.nodeValue.length))) {
      var rect = singleRect(textRange(node5, offset3, offset3), side);
      if (result.gecko && offset3 && /\s/.test(node5.nodeValue[offset3 - 1]) && offset3 < node5.nodeValue.length) {
        var rectBefore = singleRect(textRange(node5, offset3 - 1, offset3 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node5, offset3, offset3 + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from5 = offset3, to = offset3, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset3) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset3 == node5.nodeValue.length) {
        from5--;
        takeSide = 1;
      } else if (side < 0) {
        from5--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node5, from5, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset3 && (side < 0 || offset3 == nodeSize(node5))) {
      var before2 = node5.childNodes[offset3 - 1];
      if (before2.nodeType == 1) {
        return flattenH(before2.getBoundingClientRect(), false);
      }
    }
    if (offset3 < nodeSize(node5)) {
      var after2 = node5.childNodes[offset3];
      if (after2.nodeType == 1) {
        return flattenH(after2.getBoundingClientRect(), true);
      }
    }
    return flattenH(node5.getBoundingClientRect(), side >= 0);
  }
  if (offset3 && (side < 0 || offset3 == nodeSize(node5))) {
    var before$1 = node5.childNodes[offset3 - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV(singleRect(target, 1), false);
    }
  }
  if (offset3 < nodeSize(node5)) {
    var after$1 = node5.childNodes[offset3];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) {
      after$1 = after$1.nextSibling;
    }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node5.nodeType == 3 ? textRange(node5) : node5, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0) {
    return rect;
  }
  var x2 = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function flattenH(rect, top2) {
  if (rect.height == 0) {
    return rect;
  }
  var y2 = top2 ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f2) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child3 = dom.firstChild; child3; child3 = child3.nextSibling) {
      var boxes = void 0;
      if (child3.nodeType == 1) {
        boxes = child3.getClientRects();
      } else if (child3.nodeType == 3) {
        boxes = textRange(child3, 0, child3.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i2 = 0; i2 < boxes.length; i2++) {
        var box = boxes[i2];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset3 = $head.parentOffset, atStart2 = !offset3, atEnd2 = offset3 == $head.parent.content.size;
  var sel = view.root.getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
var ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};
var prototypeAccessors = { size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
ViewDesc.prototype.matchesWidget = function matchesWidget() {
  return false;
};
ViewDesc.prototype.matchesMark = function matchesMark() {
  return false;
};
ViewDesc.prototype.matchesNode = function matchesNode() {
  return false;
};
ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
  return false;
};
ViewDesc.prototype.parseRule = function parseRule() {
  return null;
};
ViewDesc.prototype.stopEvent = function stopEvent() {
  return false;
};
prototypeAccessors.size.get = function() {
  var size = 0;
  for (var i2 = 0; i2 < this.children.length; i2++) {
    size += this.children[i2].size;
  }
  return size;
};
prototypeAccessors.border.get = function() {
  return 0;
};
ViewDesc.prototype.destroy = function destroy() {
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    this.children[i2].destroy();
  }
};
ViewDesc.prototype.posBeforeChild = function posBeforeChild(child3) {
  for (var i2 = 0, pos = this.posAtStart; i2 < this.children.length; i2++) {
    var cur = this.children[i2];
    if (cur == child3) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset3, bias) {
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset3 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset3];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (dom == this.dom && this.contentDOM) {
    atEnd2 = offset3 > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset3 == 0) {
      for (var search = dom; ; search = search.parentNode) {
        if (search == this.dom) {
          atEnd2 = false;
          break;
        }
        if (search.parentNode.firstChild != search) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset3 == dom.childNodes.length) {
      for (var search$1 = dom; ; search$1 = search$1.parentNode) {
        if (search$1 == this.dom) {
          atEnd2 = true;
          break;
        }
        if (search$1.parentNode.lastChild != search$1) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
  for (var first2 = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first2 && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
        first2 = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc.prototype.getDesc = function getDesc(dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this) {
      return desc;
    }
  }
};
ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset3, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset3, bias);
    }
  }
  return -1;
};
ViewDesc.prototype.descAt = function descAt(pos) {
  for (var i2 = 0, offset3 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (offset3 == pos && end3 != offset3) {
      while (!child3.border && child3.children.length) {
        child3 = child3.children[0];
      }
      return child3;
    }
    if (pos < end3) {
      return child3.descAt(pos - offset3 - child3.border);
    }
    offset3 = end3;
  }
};
ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  var i2 = 0, offset3 = 0;
  for (var curPos = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = curPos + child3.size;
    if (end3 > pos || child3 instanceof TrailingHackViewDesc) {
      offset3 = pos - curPos;
      break;
    }
    curPos = end3;
  }
  if (offset3) {
    return this.children[i2].domFromPos(offset3 - this.children[i2].border, side);
  }
  for (var prev2 = void 0; i2 && !(prev2 = this.children[i2 - 1]).size && prev2 instanceof WidgetViewDesc && prev2.widget.type.side >= 0; i2--) {
  }
  if (side <= 0) {
    var prev$1, enter3 = true;
    for (; ; i2--, enter3 = false) {
      prev$1 = i2 ? this.children[i2 - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (prev$1 && side && enter3 && !prev$1.border && !prev$1.domAtom) {
      return prev$1.domFromPos(prev$1.size, side);
    }
    return { node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0 };
  } else {
    var next2, enter$12 = true;
    for (; ; i2++, enter$12 = false) {
      next2 = i2 < this.children.length ? this.children[i2] : null;
      if (!next2 || next2.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (next2 && enter$12 && !next2.border && !next2.domAtom) {
      return next2.domFromPos(0, side);
    }
    return { node: this.contentDOM, offset: next2 ? domIndex(next2.dom) : this.contentDOM.childNodes.length };
  }
};
ViewDesc.prototype.parseRange = function parseRange(from5, to, base2) {
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from5, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset3 = base2, i2 = 0; ; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (fromOffset == -1 && from5 <= end3) {
      var childBase = offset3 + child3.border;
      if (from5 >= childBase && to <= end3 - child3.border && child3.node && child3.contentDOM && this.contentDOM.contains(child3.contentDOM)) {
        return child3.parseRange(from5, to, childBase);
      }
      from5 = offset3;
      for (var j2 = i2; j2 > 0; j2--) {
        var prev2 = this.children[j2 - 1];
        if (prev2.size && prev2.dom.parentNode == this.contentDOM && !prev2.emptyChildAt(1)) {
          fromOffset = domIndex(prev2.dom) + 1;
          break;
        }
        from5 -= prev2.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && (end3 > to || i2 == this.children.length - 1)) {
      to = end3;
      for (var j$1 = i2 + 1; j$1 < this.children.length; j$1++) {
        var next2 = this.children[j$1];
        if (next2.size && next2.dom.parentNode == this.contentDOM && !next2.emptyChildAt(-1)) {
          toOffset = domIndex(next2.dom);
          break;
        }
        to += next2.size;
      }
      if (toOffset == -1) {
        toOffset = this.contentDOM.childNodes.length;
      }
      break;
    }
    offset3 = end3;
  }
  return { node: this.contentDOM, from: from5, to, fromOffset, toOffset };
};
ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child3 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child3.size == 0 || child3.emptyChildAt(side);
};
ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
  var ref = this.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset3 = ref.offset;
  if (node5.nodeType != 1 || offset3 == node5.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node5.childNodes[offset3];
};
ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
  var from5 = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i2 = 0, offset3 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (from5 > offset3 && to < end3) {
      return child3.setSelection(anchor - offset3 - child3.border, head - offset3 - child3.border, root, force);
    }
    offset3 = end3;
  }
  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root.getSelection();
  var brKludge = false;
  if ((result.gecko || result.safari) && anchor == head) {
    var node5 = anchorDOM.node;
    var offset$12 = anchorDOM.offset;
    if (node5.nodeType == 3) {
      brKludge = offset$12 && node5.nodeValue[offset$12 - 1] == "\n";
      if (brKludge && offset$12 == node5.nodeValue.length) {
        for (var scan = node5, after2 = void 0; scan; scan = scan.parentNode) {
          if (after2 = scan.nextSibling) {
            if (after2.nodeName == "BR") {
              anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex(after2) + 1 };
            }
            break;
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) {
            break;
          }
        }
      }
    } else {
      var prev2 = node5.childNodes[offset$12 - 1];
      brKludge = prev2 && (prev2.nodeName == "BR" || prev2.contentEditable == "false");
    }
  }
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") {
      force = true;
    }
  }
  if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) {
        domSel.extend(headDOM.node, headDOM.offset);
      }
      domSelExtended = true;
    } catch (err2) {
      if (!(err2 instanceof DOMException)) {
        throw err2;
      }
    }
  }
  if (!domSelExtended) {
    if (anchor > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};
ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
  return !this.contentDOM && mutation.type != "selection";
};
prototypeAccessors.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc.prototype.markDirty = function markDirty(from5, to) {
  for (var offset3 = 0, i2 = 0; i2 < this.children.length; i2++) {
    var child3 = this.children[i2], end3 = offset3 + child3.size;
    if (offset3 == end3 ? from5 <= end3 && to >= offset3 : from5 < end3 && to > offset3) {
      var startInside = offset3 + child3.border, endInside = end3 - child3.border;
      if (from5 >= startInside && to <= endInside) {
        this.dirty = from5 == offset3 || to == end3 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from5 == startInside && to == endInside && (child3.contentLost || child3.dom.parentNode != this.contentDOM)) {
          child3.dirty = NODE_DIRTY;
        } else {
          child3.markDirty(from5 - startInside, to - startInside);
        }
        return;
      } else {
        child3.dirty = child3.dom == child3.contentDOM && child3.dom.parentNode == this.contentDOM && !child3.children.length ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset3 = end3;
  }
  this.dirty = CONTENT_DIRTY;
};
ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
  var level = 1;
  for (var node5 = this.parent; node5; node5 = node5.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node5.dirty < dirty) {
      node5.dirty = dirty;
    }
  }
};
prototypeAccessors.domAtom.get = function() {
  return false;
};
prototypeAccessors.ignoreForCoords.get = function() {
  return false;
};
Object.defineProperties(ViewDesc.prototype, prototypeAccessors);
var nothing = [];
var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function WidgetViewDesc2(parent, widget2, view, pos) {
    var self, dom = widget2.type.toDOM;
    if (typeof dom == "function") {
      dom = dom(view, function() {
        if (!self) {
          return pos;
        }
        if (self.parent) {
          return self.parent.posBeforeChild(self);
        }
      });
    }
    if (!widget2.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.widget = widget2;
    self = this;
  }
  if (ViewDesc3)
    WidgetViewDesc2.__proto__ = ViewDesc3;
  WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { domAtom: { configurable: true } };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
    return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    var stop2 = this.widget.spec.stopEvent;
    return stop2 ? stop2(event) : false;
  };
  WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  WidgetViewDesc2.prototype.destroy = function destroy4() {
    this.widget.type.destroy(this.dom);
    ViewDesc3.prototype.destroy.call(this);
  };
  prototypeAccessors$12.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc);
var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function CompositionViewDesc2(parent, dom, textDOM, text3) {
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  if (ViewDesc3)
    CompositionViewDesc2.__proto__ = ViewDesc3;
  CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
  var prototypeAccessors$22 = { size: { configurable: true } };
  prototypeAccessors$22.size.get = function() {
    return this.text.length;
  };
  CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset3) {
    if (dom != this.textDOM) {
      return this.posAtStart + (offset3 ? this.size : 0);
    }
    return this.posAtStart + offset3;
  };
  CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.textDOM, offset: pos };
  };
  CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
  return CompositionViewDesc2;
}(ViewDesc);
var MarkViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function MarkViewDesc2(parent, mark3, dom, contentDOM) {
    ViewDesc3.call(this, parent, [], dom, contentDOM);
    this.mark = mark3;
  }
  if (ViewDesc3)
    MarkViewDesc2.__proto__ = ViewDesc3;
  MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create6(parent, mark3, inline2, view) {
    var custom = view.nodeViews[mark3.type.name];
    var spec = custom && custom(mark3, view, inline2);
    if (!spec || !spec.dom) {
      spec = DOMSerializer.renderSpec(document, mark3.type.spec.toDOM(mark3, inline2));
    }
    return new MarkViewDesc2(parent, mark3, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule2() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) {
      return null;
    }
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark3) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark3);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty2(from5, to) {
    ViewDesc3.prototype.markDirty.call(this, from5, to);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY;
    }
  };
  MarkViewDesc2.prototype.slice = function slice5(from5, to, view) {
    var copy5 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) {
      nodes = replaceNodes(nodes, to, size, view);
    }
    if (from5 > 0) {
      nodes = replaceNodes(nodes, 0, from5, view);
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      nodes[i2].parent = copy5;
    }
    copy5.children = nodes;
    return copy5;
  };
  return MarkViewDesc2;
}(ViewDesc);
var NodeViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
    ViewDesc3.call(this, parent, node5.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM2;
    this.node = node5;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view, pos);
    }
  }
  if (ViewDesc3)
    NodeViewDesc2.__proto__ = ViewDesc3;
  NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
  NodeViewDesc2.create = function create6(parent, node5, outerDeco, innerDeco, view, pos) {
    var assign2;
    var custom = view.nodeViews[node5.type.name], descObj;
    var spec = custom && custom(node5, view, function() {
      if (!descObj) {
        return pos;
      }
      if (descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node5.isText) {
      if (!dom) {
        dom = document.createTextNode(node5.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      assign2 = DOMSerializer.renderSpec(document, node5.type.spec.toDOM(node5)), dom = assign2.dom, contentDOM = assign2.contentDOM;
    }
    if (!contentDOM && !node5.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable")) {
        dom.contentEditable = false;
      }
      if (node5.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM2 = dom;
    dom = applyOuterDeco(dom, outerDeco, node5);
    if (spec) {
      return descObj = new CustomNodeViewDesc(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos + 1);
    } else if (node5.isText) {
      return new TextViewDesc(parent, node5, outerDeco, innerDeco, dom, nodeDOM2, view);
    } else {
      return new NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule2() {
    var this$1$1 = this;
    if (this.node.type.spec.reparseInView) {
      return null;
    }
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre") {
      rule.preserveWhitespace = "full";
    }
    if (!this.contentDOM) {
      rule.getContent = function() {
        return this$1$1.node.content;
      };
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (var i2 = this.children.length - 1; i2 >= 0; i2--) {
        var child3 = this.children[i2];
        if (this.dom.contains(child3.dom.parentNode)) {
          rule.contentElement = child3.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement) {
        rule.getContent = function() {
          return Fragment.empty;
        };
      }
    }
    return rule;
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode2(node5, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node5.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$32.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$32.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
    var this$1$1 = this;
    var inline2 = this.node.inlineContent, off2 = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function(widget2, i2, insideNode) {
      if (widget2.spec.marks) {
        updater.syncToMarks(widget2.spec.marks, inline2, view);
      } else if (widget2.type.side >= 0 && !insideNode) {
        updater.syncToMarks(i2 == this$1$1.node.childCount ? Mark$1.none : this$1$1.node.child(i2).marks, inline2, view);
      }
      updater.placeWidget(widget2, view, off2);
    }, function(child3, outerDeco, innerDeco, i2) {
      updater.syncToMarks(child3.marks, inline2, view);
      var compIndex;
      if (updater.findNodeMatch(child3, outerDeco, innerDeco, i2))
        ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child3.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child3, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child3, outerDeco, innerDeco, view, i2))
        ;
      else {
        updater.addNode(child3, outerDeco, innerDeco, view, off2);
      }
      off2 += child3.nodeSize;
    });
    updater.syncToMarks(nothing, inline2, view);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition) {
        this.protectLocalComposition(view, localComposition);
      }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) {
        iosHacks(this.dom);
      }
    }
  };
  NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
    var ref = view.state.selection;
    var from5 = ref.from;
    var to = ref.to;
    if (!(view.state.selection instanceof TextSelection) || from5 < pos || to > pos + this.node.content.size) {
      return;
    }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) {
      return;
    }
    if (this.node.inlineContent) {
      var text3 = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text3, from5 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1 };
    }
  };
  NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
    var node5 = ref.node;
    var pos = ref.pos;
    var text3 = ref.text;
    if (this.getDesc(node5)) {
      return;
    }
    var topNode = node5;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) {
        break;
      }
      while (topNode.previousSibling) {
        topNode.parentNode.removeChild(topNode.previousSibling);
      }
      while (topNode.nextSibling) {
        topNode.parentNode.removeChild(topNode.nextSibling);
      }
      if (topNode.pmViewDesc) {
        topNode.pmViewDesc = null;
      }
    }
    var desc = new CompositionViewDesc(this, topNode, node5, text3);
    view.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
  };
  NodeViewDesc2.prototype.update = function update2(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node5, outerDeco, innerDeco, view);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node5, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node5;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view, this.posAtStart);
    }
    this.dirty = NOT_DIRTY;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.draggable = true;
    }
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.removeAttribute("draggable");
    }
  };
  prototypeAccessors$32.domAtom.get = function() {
    return this.node.isAtom;
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
  return NodeViewDesc2;
}(ViewDesc);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function TextViewDesc2(parent, node5, outerDeco, innerDeco, dom, nodeDOM2, view) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, null, nodeDOM2, view);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  var prototypeAccessors$42 = { domAtom: { configurable: true } };
  TextViewDesc2.prototype.parseRule = function parseRule2() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) {
      skip = skip.parentNode;
    }
    return { skip: skip || true };
  };
  TextViewDesc2.prototype.update = function update2(node5, outerDeco, _2, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node5.text != this.node.text) && node5.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node5.text;
      if (view.trackWrites == this.nodeDOM) {
        view.trackWrites = null;
      }
    }
    this.node = node5;
    this.dirty = NOT_DIRTY;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset3, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset3, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset3, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  TextViewDesc2.prototype.slice = function slice5(from5, to, view) {
    var node5 = this.node.cut(from5, to), dom = document.createTextNode(node5.text);
    return new TextViewDesc2(this.parent, node5, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  TextViewDesc2.prototype.markDirty = function markDirty2(from5, to) {
    NodeViewDesc2.prototype.markDirty.call(this, from5, to);
    if (this.dom != this.nodeDOM && (from5 == 0 || to == this.nodeDOM.nodeValue.length)) {
      this.dirty = NODE_DIRTY;
    }
  };
  prototypeAccessors$42.domAtom.get = function() {
    return false;
  };
  Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
  return TextViewDesc2;
}(NodeViewDesc);
var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function TrailingHackViewDesc2() {
    ViewDesc3.apply(this, arguments);
  }
  if (ViewDesc3)
    TrailingHackViewDesc2.__proto__ = ViewDesc3;
  TrailingHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
  var prototypeAccessors$52 = { domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
  TrailingHackViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  TrailingHackViewDesc2.prototype.matchesHack = function matchesHack2(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  };
  prototypeAccessors$52.domAtom.get = function() {
    return true;
  };
  prototypeAccessors$52.ignoreForCoords.get = function() {
    return this.dom.nodeName == "IMG";
  };
  Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
  return TrailingHackViewDesc2;
}(ViewDesc);
var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update2(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) {
      return false;
    }
    if (this.spec.update) {
      var result2 = this.spec.update(node5, outerDeco, innerDeco);
      if (result2) {
        this.updateInner(node5, outerDeco, innerDeco, view);
      }
      return result2;
    } else if (!this.contentDOM && !node5.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node5, outerDeco, innerDeco, view);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy4() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i2 = 0; i2 < descs.length; i2++) {
    var desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node5, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
  for (var i2 = 0; i2 < outerDeco.length; i2++) {
    var attrs = outerDeco[i2].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel(node5.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM2;
  }
  var curDOM = nodeDOM2;
  for (var i2 = 0; i2 < curComputed.length; i2++) {
    var deco = curComputed[i2], prev2 = prevComputed[i2];
    if (i2) {
      var parent = void 0;
      if (prev2 && prev2.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev2 = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev2 || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev2, cur) {
  for (var name in prev2) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev2[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev2.class != cur.class) {
    var prevList = prev2.class ? prev2.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i2 = 0; i2 < prevList.length; i2++) {
      if (curList.indexOf(prevList[i2]) == -1) {
        dom.classList.remove(prevList[i2]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
    if (dom.classList.length == 0) {
      dom.removeAttribute("class");
    }
  }
  if (prev2.style != cur.style) {
    if (prev2.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev2.style)) {
        dom.style.removeProperty(m2[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node5) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node5, dom.nodeType != 1));
}
function sameOuterDeco(a2, b2) {
  if (a2.length != b2.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].type.eq(b2[i2].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
var ViewTreeUpdater = function ViewTreeUpdater2(top2, lockedNode) {
  this.top = top2;
  this.lock = lockedNode;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatch = preMatch(top2.node.content, top2);
};
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start4, end3) {
  if (start4 == end3) {
    return;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    this.top.children[i2].destroy();
  }
  this.top.children.splice(start4, end3 - start4);
  this.changed = true;
};
ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks2, inline2, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks2.length);
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false) {
    keep++;
  }
  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks2.length) {
    this.stack.push(this.top, this.index + 1);
    var found2 = -1;
    for (var i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
      if (this.top.children[i2].matchesMark(marks2[depth])) {
        found2 = i2;
        break;
      }
    }
    if (found2 > -1) {
      if (found2 > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found2);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks2[depth], inline2, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node5, outerDeco, innerDeco, index3) {
  var found2 = -1, targetDesc;
  if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node5, outerDeco, innerDeco)) {
    found2 = this.top.children.indexOf(targetDesc, this.index);
  } else {
    for (var i2 = this.index, e2 = Math.min(this.top.children.length, i2 + 5); i2 < e2; i2++) {
      var child3 = this.top.children[i2];
      if (child3.matchesNode(node5, outerDeco, innerDeco) && !this.preMatch.matched.has(child3)) {
        found2 = i2;
        break;
      }
    }
  }
  if (found2 < 0) {
    return false;
  }
  this.destroyBetween(this.index, found2);
  this.index++;
  return true;
};
ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node5, outerDeco, innerDeco, index3, view) {
  var child3 = this.top.children[index3];
  if (!child3.update(node5, outerDeco, innerDeco, view)) {
    return false;
  }
  this.destroyBetween(this.index, index3);
  this.index = index3 + 1;
  return true;
};
ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
  for (; ; ) {
    var parent = domNode.parentNode;
    if (!parent) {
      return -1;
    }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) {
        for (var i2 = this.index; i2 < this.top.children.length; i2++) {
          if (this.top.children[i2] == desc) {
            return i2;
          }
        }
      }
      return -1;
    }
    domNode = parent;
  }
};
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node5, outerDeco, innerDeco, view, index3) {
  for (var i2 = this.index; i2 < this.top.children.length; i2++) {
    var next2 = this.top.children[i2];
    if (next2 instanceof NodeViewDesc) {
      var preMatch2 = this.preMatch.matched.get(next2);
      if (preMatch2 != null && preMatch2 != index3) {
        return false;
      }
      var nextDOM = next2.dom;
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node5.isText && next2.node && next2.node.isText && next2.nodeDOM.nodeValue == node5.text && next2.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next2.outerDeco));
      if (!locked && next2.update(node5, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i2);
        if (next2.dom != nextDOM) {
          this.changed = true;
        }
        this.index++;
        return true;
      }
      break;
    }
  }
  return false;
};
ViewTreeUpdater.prototype.addNode = function addNode2(node5, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node5, outerDeco, innerDeco, view, pos));
  this.changed = true;
};
ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
  var next2 = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next2 && next2.matchesWidget(widget2) && (widget2 == next2.widget || !next2.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget2, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false") {
      this.addHackNode("IMG");
    }
    this.addHackNode("BR");
  }
};
ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") {
      dom.className = "ProseMirror-separator";
      dom.alt = "";
    }
    if (nodeName == "BR") {
      dom.className = "ProseMirror-trailingBreak";
    }
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc, descI = curDesc.children.length;
  var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      var desc = void 0;
      for (; ; ) {
        if (descI) {
          var next2 = curDesc.children[descI - 1];
          if (next2 instanceof MarkViewDesc) {
            curDesc = next2;
            descI = next2.children.length;
          } else {
            desc = next2;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      var node5 = desc.node;
      if (!node5) {
        continue;
      }
      if (node5 != frag.child(fI - 1)) {
        break;
      }
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a2, b2) {
  return a2.type.side - b2.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals3 = deco.locals(parent), offset3 = 0;
  if (locals3.length == 0) {
    for (var i2 = 0; i2 < parent.childCount; i2++) {
      var child3 = parent.child(i2);
      onNode(child3, locals3, deco.forChild(offset3, child3), i2);
      offset3 += child3.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals3.length && locals3[decoIndex].to == offset3) {
      var widget2 = locals3[decoIndex++], widgets = void 0;
      while (decoIndex < locals3.length && locals3[decoIndex].to == offset3) {
        (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget2, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index3 = void 0;
    if (restNode) {
      index3 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$22 = 0; i$22 < active.length; i$22++) {
      if (active[i$22].to <= offset3) {
        active.splice(i$22--, 1);
      }
    }
    while (decoIndex < locals3.length && locals3[decoIndex].from <= offset3 && locals3[decoIndex].to > offset3) {
      active.push(locals3[decoIndex++]);
    }
    var end3 = offset3 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end3;
      if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
        cutAt = locals3[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end3) {
        restNode = child$1.cut(cutAt - offset3);
        child$1 = child$1.cut(0, cutAt - offset3);
        end3 = cutAt;
        index3 = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d2) {
      return !d2.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset3, child$1), index3);
    offset3 = end3;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node5, offset3) {
  for (; ; ) {
    if (node5.nodeType == 3) {
      return node5;
    }
    if (node5.nodeType == 1 && offset3 > 0) {
      if (node5.childNodes.length > offset3 && node5.childNodes[offset3].nodeType == 3) {
        return node5.childNodes[offset3];
      }
      node5 = node5.childNodes[offset3 - 1];
      offset3 = nodeSize(node5);
    } else if (node5.nodeType == 1 && offset3 < node5.childNodes.length) {
      node5 = node5.childNodes[offset3];
      offset3 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from5, to) {
  for (var i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
    var child3 = frag.child(i2++), childStart = pos;
    pos += child3.nodeSize;
    if (!child3.isText) {
      continue;
    }
    var str = child3.text;
    while (i2 < frag.childCount) {
      var next2 = frag.child(i2++);
      pos += next2.nodeSize;
      if (!next2.isText) {
        break;
      }
      str += next2.text;
    }
    if (pos >= from5) {
      var found2 = childStart < to ? str.lastIndexOf(text3, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text3.length + childStart >= from5) {
        return childStart + found2;
      }
      if (from5 == to && str.length >= to + text3.length - childStart && str.slice(to - childStart, to - childStart + text3.length) == text3) {
        return to;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes, from5, to, view, replacement) {
  var result2 = [];
  for (var i2 = 0, off2 = 0; i2 < nodes.length; i2++) {
    var child3 = nodes[i2], start4 = off2, end3 = off2 += child3.size;
    if (start4 >= to || end3 <= from5) {
      result2.push(child3);
    } else {
      if (start4 < from5) {
        result2.push(child3.slice(0, from5 - start4, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end3 > to) {
        result2.push(child3.slice(to - start4, child3.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node) {
      nearestDesc2 = nearestDesc2.parent;
    }
    if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      var pos = nearestDesc2.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) {
    return;
  }
  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {
    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditable(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset3 = ref.offset;
  var after2 = offset3 < node5.childNodes.length ? node5.childNodes[offset3] : null;
  var before2 = offset3 ? node5.childNodes[offset3 - 1] : null;
  if (result.safari && after2 && after2.contentEditable == "false") {
    return setEditable(after2);
  }
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2) {
      return setEditable(after2);
    } else if (before2) {
      return setEditable(before2);
    }
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node5 = domSel.anchorNode, offset3 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node5 || domSel.anchorOffset != offset3) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node5 = view.cursorWrapper.dom, img = node5.nodeName == "IMG";
  if (img) {
    range.setEnd(node5.parentNode, domIndex(node5) + 1);
  } else {
    range.setEnd(node5, 0);
  }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node5.disabled = true;
    node5.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f2) {
    return f2(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply7(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next2 = moveSelectionBlock(view.state, dir);
      if (next2 && next2 instanceof NodeSelection) {
        return apply7(view, next2);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node5 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node5 || node5.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node5.nodeSize : $head.pos;
      if (!(node5.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node5)) {
        return apply7(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node5.nodeSize) : $head));
      } else if (result.webkit) {
        return apply7(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node5.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply7(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) {
      return apply7(view, next$1);
    }
    return false;
  }
}
function nodeLen(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset3 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node5.nodeType == 1 && offset3 < nodeLen(node5) && isIgnorable(node5.childNodes[offset3])) {
    force = true;
  }
  for (; ; ) {
    if (offset3 > 0) {
      if (node5.nodeType != 1) {
        break;
      } else {
        var before2 = node5.childNodes[offset3 - 1];
        if (isIgnorable(before2)) {
          moveNode = node5;
          moveOffset = --offset3;
        } else if (before2.nodeType == 3) {
          node5 = before2;
          offset3 = node5.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node5)) {
      break;
    } else {
      var prev2 = node5.previousSibling;
      while (prev2 && isIgnorable(prev2)) {
        moveNode = node5.parentNode;
        moveOffset = domIndex(prev2);
        prev2 = prev2.previousSibling;
      }
      if (!prev2) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset3 = 0;
      } else {
        node5 = prev2;
        offset3 = nodeLen(node5);
      }
    }
  }
  if (force) {
    setSelFocus(view, sel, node5, offset3);
  } else if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset3 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var len = nodeLen(node5);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset3 < len) {
      if (node5.nodeType != 1) {
        break;
      }
      var after2 = node5.childNodes[offset3];
      if (isIgnorable(after2)) {
        moveNode = node5;
        moveOffset = ++offset3;
      } else {
        break;
      }
    } else if (isBlockNode(node5)) {
      break;
    } else {
      var next2 = node5.nextSibling;
      while (next2 && isIgnorable(next2)) {
        moveNode = next2.parentNode;
        moveOffset = domIndex(next2) + 1;
        next2 = next2.nextSibling;
      }
      if (!next2) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset3 = len = 0;
      } else {
        node5 = next2;
        offset3 = 0;
        len = nodeLen(node5);
      }
    }
  }
  if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node5, offset3) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node5, offset3);
    range.setStart(node5, offset3);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node5, offset3);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM(view);
    }
  }, 50);
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next2 = moveSelectionBlock(view.state, dir);
    if (next2 && next2 instanceof NodeSelection) {
      return apply7(view, next2);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply7(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node5, state) {
  view.domObserver.stop();
  node5.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child3 = focusNode.firstChild;
    switchEditable(view, child3, true);
    setTimeout(function() {
      return switchEditable(view, child3, false);
    }, 20);
  }
}
function getMods(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || result.mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || result.mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37) {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39) {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38) {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40) {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from5 = ref.from;
  var to = ref.to;
  var domSel = view.root.getSelection(), find3 = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find3 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find3.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off2 = toOffset; off2 > fromOffset; off2--) {
      var node5 = parent.childNodes[off2 - 1], desc = node5.pmViewDesc;
      if (node5.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from5);
  var sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    editableContent: true,
    findPositions: find3,
    ruleFromNode,
    context: $from
  });
  if (find3 && find3[0].pos != null) {
    var anchor$1 = find3[0].pos, head = find3[1] && find3[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from5, head: head + from5 };
  }
  return { doc: doc2, sel, from: from5, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from5, to, typeOver, addedNodes) {
  if (from5 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from5);
  var shared = $before.sharedDepth(to);
  from5 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse4 = parseBetween(view, from5, to);
  if (result.chrome && view.cursorWrapper && parse4.sel && parse4.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse4.sel = { anchor: parse4.sel.anchor + size, head: parse4.sel.anchor + size };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse4.from, parse4.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse4.doc.content, parse4.from, preferredPos, preferredSide);
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n2) {
    return n2.nodeName == "DIV" || n2.nodeName == "P";
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse4.sel && parse4.sel.anchor != parse4.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse4.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse4.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse4.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse4.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse4.from && parse4.doc.textBetween(change.start - parse4.from - 1, change.start - parse4.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse4.doc.resolveNoCache(change.start - parse4.from);
  var $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n2) {
    return n2.nodeName == "DIV" || n2.nodeName == "P";
  })) || !inlineChange && $from.pos < parse4.doc.content.size && (nextSel = Selection.findFrom(parse4.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse4.sel && parse4.sel.anchor == parse4.sel.head && parse4.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f2) {
        return f2(view, chFrom, chTo, text$1);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse4.doc.slice(change.start - parse4.from, change.endB - parse4.from));
  }
  if (parse4.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse4.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev2) {
  var curMarks = cur.firstChild.marks, prevMarks = prev2.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark3, update2;
  for (var i2 = 0; i2 < prevMarks.length; i2++) {
    added = prevMarks[i2].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark3 = added[0];
    type = "add";
    update2 = function(node5) {
      return node5.mark(mark3.addToSet(node5.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark3 = removed[0];
    type = "remove";
    update2 = function(node5) {
      return node5.mark(mark3.removeFromSet(node5.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$22 = 0; i$22 < prev2.childCount; i$22++) {
    updated.push(update2(prev2.child(i$22)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark: mark3, type };
  }
}
function looksLikeJoin(old, start4, end3, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end3 - start4 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start4);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening($next, true, false) < end3) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next2 && !next2.isLeaf) {
      next2 = next2.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff(a2, b2, pos, preferredPos, preferredSide) {
  var start4 = a2.findDiffStart(b2, pos);
  if (start4 == null) {
    return null;
  }
  var ref = a2.findDiffEnd(b2, pos + a2.size, pos + b2.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start4 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start4;
  }
  if (endA < start4 && a2.size < b2.size) {
    var move2 = preferredPos <= start4 && preferredPos >= endA ? start4 - preferredPos : 0;
    start4 -= move2;
    endB = start4 + (endB - endA);
    endA = start4;
  } else if (endB < start4) {
    var move$1 = preferredPos <= start4 && preferredPos >= endB ? start4 - preferredPos : 0;
    start4 -= move$1;
    endA = start4 + (endA - endB);
    endB = start4;
  }
  return { start: start4, endA, endB };
}
function serializeForClipboard(view, slice5) {
  var context = [];
  var content2 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node5 = content2.firstChild;
    context.push(node5.type.name, node5.attrs != node5.type.defaultAttrs ? node5.attrs : null);
    content2 = node5.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content2, { document: doc2 }));
  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      var wrapper = doc2.createElement(needsWrap[i2]);
      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }
      wrap.appendChild(wrapper);
      if (needsWrap[i2] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice5);
  }) || slice5.content.textBetween(0, slice5.content.size, "\n\n");
  return { dom: wrap, text: text3 };
}
function parseFromClipboard(view, text3, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice5;
  if (!html && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function(f2) {
      text3 = f2(text3, inCode || plainText);
    });
    if (inCode) {
      return text3 ? new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    }
    var parsed = view.someProp("clipboardTextParser", function(f2) {
      return f2(text3, $context, plainText);
    });
    if (parsed) {
      slice5 = parsed;
    } else {
      var marks2 = $context.marks();
      var ref = view.state;
      var schema = ref.schema;
      var serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach(function(block) {
        var p2 = dom.appendChild(document.createElement("p"));
        if (block) {
          p2.appendChild(serializer.serializeNode(schema.text(block, marks2)));
        }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f2) {
      html = f2(html);
    });
    dom = readHTML(html);
    if (result.webkit) {
      restoreReplacedSpaces(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice5) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice5 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode2(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName)) {
          return { ignore: true };
        }
      }
    });
  }
  if (sliceData) {
    slice5 = addContext(closeSlice(slice5, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice5 = Slice.maxOpen(normalizeSiblings(slice5.content, $context), true);
    if (slice5.openStart || slice5.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node5 = slice5.content.firstChild; openStart < slice5.openStart && !node5.type.spec.isolating; openStart++, node5 = node5.firstChild) {
      }
      for (var node$1 = slice5.content.lastChild; openEnd < slice5.openEnd && !node$1.type.spec.isolating; openEnd++, node$1 = node$1.lastChild) {
      }
      slice5 = closeSlice(slice5, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", function(f2) {
    slice5 = f2(slice5);
  });
  return slice5;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d3) {
    var parent = $context.node(d3);
    var match2 = parent.contentMatchAt($context.index(d3));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node5) {
      if (!result2) {
        return;
      }
      var wrap = match2.findWrapping(node5.type), inLast;
      if (!wrap) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node5, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node5, wrap);
        result2.push(wrapped);
        match2 = match2.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d2 = $context.depth; d2 >= 0; d2--) {
    var returned = loop(d2);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers(node5, wrap, from5) {
  if (from5 === void 0)
    from5 = 0;
  for (var i2 = wrap.length - 1; i2 >= from5; i2--) {
    node5 = wrap[i2].create(null, Fragment.from(node5));
  }
  return node5;
}
function addToSibling(wrap, lastWrap, node5, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node5, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap.length - 1 ? node5.type : wrap[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node5, wrap, depth + 1))));
    }
  }
}
function closeRight(node5, depth) {
  if (depth == 0) {
    return node5;
  }
  var fragment = node5.content.replaceChild(node5.childCount - 1, closeRight(node5.lastChild, depth - 1));
  var fill = node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true);
  return node5.copy(fragment.append(fill));
}
function closeRange(fragment, side, from5, to, depth, openEnd) {
  var node5 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node5.content;
  if (depth < to - 1) {
    inner = closeRange(inner, side, from5, to, depth + 1, openEnd);
  }
  if (depth >= from5) {
    inner = side < 0 ? node5.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node5.copy(inner));
}
function closeSlice(slice5, openStart, openEnd) {
  if (openStart < slice5.openStart) {
    slice5 = new Slice(closeRange(slice5.content, -1, openStart, slice5.openStart, 0, slice5.openEnd), openStart, slice5.openEnd);
  }
  if (openEnd < slice5.openEnd) {
    slice5 = new Slice(closeRange(slice5.content, 1, openEnd, slice5.openEnd, 0, 0), slice5.openStart, openEnd);
  }
  return slice5;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) {
    html = html.slice(metas[0].length);
  }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html = wrap.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html + wrap.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html;
  if (wrap) {
    for (var i2 = 0; i2 < wrap.length; i2++) {
      elt = elt.querySelector(wrap[i2]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node5 = nodes[i2];
    if (node5.childNodes.length == 1 && node5.textContent == "\xA0" && node5.parentNode) {
      node5.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node5);
    }
  }
}
function addContext(slice5, context) {
  if (!slice5.size) {
    return slice5;
  }
  var schema = slice5.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e2) {
    return slice5;
  }
  var content2 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  for (var i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    var type = schema.nodes[array[i2]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content2 = Fragment.from(type.create(array[i2 + 1], content2));
    openStart++;
    openEnd++;
  }
  return new Slice(content2, openStart, openEnd);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = result.ie && result.ie_version <= 11;
var SelectionState = function SelectionState2() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};
SelectionState.prototype.set = function set(sel) {
  this.anchorNode = sel.anchorNode;
  this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode;
  this.focusOffset = sel.focusOffset;
};
SelectionState.prototype.eq = function eq5(sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
};
var DOMObserver = function DOMObserver2(view, handleDOMChange) {
  var this$1$1 = this;
  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      this$1$1.queue.push(mutations[i2]);
    }
    if (result.ie && result.ie_version <= 11 && mutations.some(function(m2) {
      return m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length;
    })) {
      this$1$1.flushSoon();
    } else {
      this$1$1.flush();
    }
  });
  this.currentSelection = new SelectionState();
  if (useCharData) {
    this.onCharData = function(e2) {
      this$1$1.queue.push({ target: e2.target, type: "characterData", oldValue: e2.prevValue });
      this$1$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};
DOMObserver.prototype.flushSoon = function flushSoon() {
  var this$1$1 = this;
  if (this.flushingSoon < 0) {
    this.flushingSoon = window.setTimeout(function() {
      this$1$1.flushingSoon = -1;
      this$1$1.flush();
    }, 20);
  }
};
DOMObserver.prototype.forceFlush = function forceFlush() {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};
DOMObserver.prototype.start = function start3() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions);
  }
  if (useCharData) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.connectSelection();
};
DOMObserver.prototype.stop = function stop() {
  var this$1$1 = this;
  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i2 = 0; i2 < take.length; i2++) {
        this.queue.push(take[i2]);
      }
      window.setTimeout(function() {
        return this$1$1.flush();
      }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.disconnectSelection();
};
DOMObserver.prototype.connectSelection = function connectSelection() {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
  var this$1$1 = this;
  this.suppressingSelectionUpdates = true;
  setTimeout(function() {
    return this$1$1.suppressingSelectionUpdates = false;
  }, 50);
};
DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
  if (!hasFocusAndSelection(this.view)) {
    return;
  }
  if (this.suppressingSelectionUpdates) {
    return selectionToDOM(this.view);
  }
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
      return this.flushSoon();
    }
  }
  this.flush();
};
DOMObserver.prototype.setCurSelection = function setCurSelection() {
  this.currentSelection.set(this.view.root.getSelection());
};
DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
  if (sel.rangeCount == 0) {
    return true;
  }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
    this.setCurSelection();
    return true;
  }
};
DOMObserver.prototype.flush = function flush() {
  if (!this.view.docView || this.flushingSoon > -1) {
    return;
  }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }
  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
  var from5 = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      var result$1 = this.registerMutation(mutations[i2], added);
      if (result$1) {
        from5 = from5 < 0 ? result$1.from : Math.min(result$1.from, from5);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) {
          typeOver = true;
        }
      }
    }
  }
  if (result.gecko && added.length > 1) {
    var brs = added.filter(function(n2) {
      return n2.nodeName == "BR";
    });
    if (brs.length == 2) {
      var a2 = brs[0];
      var b2 = brs[1];
      if (a2.parentNode && a2.parentNode.parentNode == b2.parentNode) {
        b2.remove();
      } else {
        a2.remove();
      }
    }
  }
  if (from5 > -1 || newSel) {
    if (from5 > -1) {
      this.view.docView.markDirty(from5, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from5, to, typeOver, added);
    if (this.view.docView && this.view.docView.dirty) {
      this.view.updateState(this.view.state);
    } else if (!this.currentSelection.eq(sel)) {
      selectionToDOM(this.view);
    }
    this.currentSelection.set(sel);
  }
};
DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
  if (added.indexOf(mut.target) > -1) {
    return null;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
    return null;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return null;
  }
  if (mut.type == "childList") {
    for (var i2 = 0; i2 < mut.addedNodes.length; i2++) {
      added.push(mut.addedNodes[i2]);
    }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
      return { from: desc.posBefore, to: desc.posAfter };
    }
    var prev2 = mut.previousSibling, next2 = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
        var previousSibling = ref.previousSibling;
        var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
          prev2 = previousSibling;
        }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
          next2 = nextSibling;
        }
      }
    }
    var fromOffset = prev2 && prev2.parentNode == mut.target ? domIndex(prev2) + 1 : 0;
    var from5 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next2 && next2.parentNode == mut.target ? domIndex(next2) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return { from: from5, to };
  } else if (mut.type == "attributes") {
    return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
  } else {
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      typeOver: mut.target.nodeValue == mut.oldValue
    };
  }
};
var cssChecked = false;
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
var handlers = {}, editHandlers = {};
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver(view, function(from5, to, typeOver, added) {
    return readDOMChange(view, from5, to, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers)
    loop(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers) {
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.eventHandlers[type]) {
        view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node5 = event.target; node5 != view.dom; node5 = node5.parentNode) {
    if (!node5 || node5.nodeType == 11 || node5.pmViewDesc && node5.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
    handlers[event.type](view, event);
  }
}
editHandlers.keydown = function(view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) {
    return;
  }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (result.android && result.chrome && event.keyCode == 13) {
    return;
  }
  if (event.keyCode != 229) {
    view.domObserver.forceFlush();
  }
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function(f2) {
          return f2(view, keyEvent(13, "Enter"));
        });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f2) {
    return f2(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = function(view, e2) {
  if (e2.keyCode == 16) {
    view.shiftKey = false;
  }
};
editHandlers.keypress = function(view, event) {
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
    return;
  }
  if (view.someProp("handleKeyPress", function(f2) {
    return f2(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function(f2) {
      return f2(view, sel.$from.pos, sel.$to.pos, text3);
    })) {
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop = function(i3) {
    if (view.someProp(propName, function(f2) {
      return i3 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i3), event, true) : f2(view, pos, $pos.node(i3), $pos.before(i3), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var returned = loop(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node5 = $pos.nodeAfter;
  if (node5 && node5.isAtom && NodeSelection.isSelectable(node5)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node5)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i2);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f2) {
    return f2(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f2) {
    return f2(view, pos, event);
  });
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f2) {
    return f2(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    var nodePos = $pos.before(i2);
    if (node5.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node5.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node5)) {
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
handlers.mousedown = function(view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") {
      type = "doubleClick";
    } else if (view.lastClick.type == "doubleClick") {
      type = "tripleClick";
    }
  }
  view.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) {
    return;
  }
  if (type == "singleClick") {
    if (view.mouseDown) {
      view.mouseDown.done();
    }
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = function MouseDown2(view, pos, event, flushed) {
  var this$1$1 = this;
  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;
  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        if (this$1$1.view.mouseDown == this$1$1) {
          this$1$1.target.setAttribute("contentEditable", "false");
        }
      }, 20);
    }
    this.view.domObserver.start();
  }
  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};
MouseDown.prototype.done = function done() {
  var this$1$1 = this;
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.removeAttribute("draggable");
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) {
    setTimeout(function() {
      return selectionToDOM(this$1$1.view);
    });
  }
  this.view.mouseDown = null;
};
MouseDown.prototype.up = function up(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) {
    pos = this.view.posAtCoords(eventCoords(event));
  }
  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};
MouseDown.prototype.move = function move(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) {
    this.done();
  }
};
handlers.touchdown = function(view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = function(view) {
  return forceDOMFlush(view);
};
function inOrNearComposition(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = result.android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m2) {
      return m2.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node5 = sel.focusNode, offset3 = sel.focusOffset; node5 && node5.nodeType == 1 && offset3 != 0; ) {
          var before2 = offset3 < 0 ? node5.lastChild : node5.childNodes[offset3 - 1];
          if (!before2) {
            break;
          }
          if (before2.nodeType == 3) {
            sel.collapse(before2, before2.nodeValue.length);
            break;
          } else {
            node5 = before2;
            offset3 = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = function(view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
  }
}
function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate) {
  if (result.android && view.domObserver.flushingSoon >= 0) {
    return;
  }
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    if (wrap.parentNode) {
      wrap.parentNode.removeChild(wrap);
    }
    view.focus();
  }, 50);
}
var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
handlers.copy = editHandlers.cut = function(view, e2) {
  var sel = view.state.selection, cut3 = e2.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI ? null : e2.clipboardData;
  var slice5 = sel.content();
  var ref = serializeForClipboard(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  if (data) {
    e2.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy(view, dom);
  }
  if (cut3) {
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode(slice5) {
  return slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1 ? slice5.content.firstChild : null;
}
function capturePaste(view, e2) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste(view, target.value, null, e2);
    } else {
      doPaste(view, target.textContent, target.innerHTML, e2);
    }
  }, 50);
}
function doPaste(view, text3, html, e2) {
  var slice5 = parseFromClipboard(view, text3, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f2) {
    return f2(view, e2, slice5 || Slice.empty);
  })) {
    return true;
  }
  if (!slice5) {
    return false;
  }
  var singleNode = sliceSingleNode(slice5);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice5);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = function(view, e2) {
  if (view.composing && !result.android) {
    return;
  }
  var data = brokenClipboardAPI ? null : e2.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e2)) {
    e2.preventDefault();
  } else {
    capturePaste(view, e2);
  }
};
var Dragging = function Dragging2(slice5, move2) {
  this.slice = slice5;
  this.move = move2;
};
var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
handlers.dragstart = function(view, e2) {
  var mouseDown = view.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e2.dataTransfer) {
    return;
  }
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e2));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e2.target && e2.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e2.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
  }
  var slice5 = view.state.selection.content();
  var ref = serializeForClipboard(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  e2.dataTransfer.clearData();
  e2.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  e2.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) {
    e2.dataTransfer.setData("text/plain", text3);
  }
  view.dragging = new Dragging(slice5, !e2[dragCopyModifier]);
};
handlers.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging) {
      view.dragging = null;
    }
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function(_2, e2) {
  return e2.preventDefault();
};
editHandlers.drop = function(view, e2) {
  var dragging = view.dragging;
  view.dragging = null;
  if (!e2.dataTransfer) {
    return;
  }
  var eventPos = view.posAtCoords(eventCoords(e2));
  if (!eventPos) {
    return;
  }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice5 = dragging && dragging.slice;
  if (slice5) {
    view.someProp("transformPasted", function(f2) {
      slice5 = f2(slice5);
    });
  } else {
    slice5 = parseFromClipboard(view, e2.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e2.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move2 = dragging && !e2[dragCopyModifier];
  if (view.someProp("handleDrop", function(f2) {
    return f2(view, e2, slice5 || Slice.empty, move2);
  })) {
    e2.preventDefault();
    return;
  }
  if (!slice5) {
    return;
  }
  e2.preventDefault();
  var insertPos = slice5 ? dropPoint(view.state.doc, $mouse.pos, slice5) : $mouse.pos;
  if (insertPos == null) {
    insertPos = $mouse.pos;
  }
  var tr = view.state.tr;
  if (move2) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode2 = slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode2) {
    tr.replaceRangeWith(pos, pos, slice5.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice5);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice5.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice5.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    var end3 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return end3 = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = function(view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
        selectionToDOM(view);
      }
    }, 20);
  }
};
handlers.blur = function(view, e2) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e2.relatedTarget && view.dom.contains(e2.relatedTarget)) {
      view.domObserver.currentSelection.set({});
    }
    view.focused = false;
  }
};
handlers.beforeinput = function(view, event) {
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.domChangeCount;
    setTimeout(function() {
      if (view.domChangeCount != domChangeCount) {
        return;
      }
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(8, "Backspace"));
      })) {
        return;
      }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      if ($cursor && $cursor.pos > 0) {
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }
    }, 50);
  }
};
for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}
function compareObjs(a2, b2) {
  if (a2 == b2) {
    return true;
  }
  for (var p2 in a2) {
    if (a2[p2] !== b2[p2]) {
      return false;
    }
  }
  for (var p$12 in b2) {
    if (!(p$12 in a2)) {
      return false;
    }
  }
  return true;
}
var WidgetType = function WidgetType2(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};
WidgetType.prototype.map = function map7(mapping, span, offset3, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref.pos;
  var deleted = ref.deleted;
  return deleted ? null : new Decoration(pos - offset3, pos - offset3, this);
};
WidgetType.prototype.valid = function valid() {
  return true;
};
WidgetType.prototype.eq = function eq6(other) {
  return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
};
WidgetType.prototype.destroy = function destroy2(node5) {
  if (this.spec.destroy) {
    this.spec.destroy(node5);
  }
};
var InlineType = function InlineType2(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
InlineType.prototype.map = function map8(mapping, span, offset3, oldOffset) {
  var from5 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset3;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset3;
  return from5 >= to ? null : new Decoration(from5, to, this);
};
InlineType.prototype.valid = function valid2(_2, span) {
  return span.from < span.to;
};
InlineType.prototype.eq = function eq7(other) {
  return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
InlineType.is = function is(span) {
  return span.type instanceof InlineType;
};
var NodeType2 = function NodeType3(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
NodeType2.prototype.map = function map9(mapping, span, offset3, oldOffset) {
  var from5 = mapping.mapResult(span.from + oldOffset, 1);
  if (from5.deleted) {
    return null;
  }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from5.pos) {
    return null;
  }
  return new Decoration(from5.pos - offset3, to.pos - offset3, this);
};
NodeType2.prototype.valid = function valid3(node5, span) {
  var ref = node5.content.findIndex(span.from);
  var index3 = ref.index;
  var offset3 = ref.offset;
  var child3;
  return offset3 == span.from && !(child3 = node5.child(index3)).isText && offset3 + child3.nodeSize == span.to;
};
NodeType2.prototype.eq = function eq8(other) {
  return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
var Decoration = function Decoration2(from5, to, type) {
  this.from = from5;
  this.to = to;
  this.type = type;
};
var prototypeAccessors$1 = { spec: { configurable: true }, inline: { configurable: true } };
Decoration.prototype.copy = function copy4(from5, to) {
  return new Decoration(from5, to, this.type);
};
Decoration.prototype.eq = function eq9(other, offset3) {
  if (offset3 === void 0)
    offset3 = 0;
  return this.type.eq(other.type) && this.from + offset3 == other.from && this.to + offset3 == other.to;
};
Decoration.prototype.map = function map10(mapping, offset3, oldOffset) {
  return this.type.map(mapping, this, offset3, oldOffset);
};
Decoration.widget = function widget(pos, toDOM, spec) {
  return new Decoration(pos, pos, new WidgetType(toDOM, spec));
};
Decoration.inline = function inline(from5, to, attrs, spec) {
  return new Decoration(from5, to, new InlineType(attrs, spec));
};
Decoration.node = function node4(from5, to, attrs, spec) {
  return new Decoration(from5, to, new NodeType2(attrs, spec));
};
prototypeAccessors$1.spec.get = function() {
  return this.type.spec;
};
prototypeAccessors$1.inline.get = function() {
  return this.type instanceof InlineType;
};
Object.defineProperties(Decoration.prototype, prototypeAccessors$1);
var none = [], noSpec = {};
var DecorationSet = function DecorationSet2(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};
DecorationSet.create = function create5(doc2, decorations) {
  return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
};
DecorationSet.prototype.find = function find(start4, end3, predicate) {
  var result2 = [];
  this.findInner(start4 == null ? 0 : start4, end3 == null ? 1e9 : end3, result2, 0, predicate);
  return result2;
};
DecorationSet.prototype.findInner = function findInner(start4, end3, result2, offset3, predicate) {
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var span = this.local[i2];
    if (span.from <= end3 && span.to >= start4 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset3, span.to + offset3));
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end3 && this.children[i$1 + 1] > start4) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start4 - childOff, end3 - childOff, result2, offset3 + childOff, predicate);
    }
  }
};
DecorationSet.prototype.map = function map11(mapping, doc2, options) {
  if (this == empty || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
};
DecorationSet.prototype.mapInner = function mapInner(mapping, node5, offset3, oldOffset, options) {
  var newLocal;
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var mapped = this.local[i2].map(mapping, offset3, oldOffset);
    if (mapped && mapped.type.valid(node5, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this.local[i2].spec);
    }
  }
  if (this.children.length) {
    return mapChildren(this.children, newLocal, mapping, node5, offset3, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
  }
};
DecorationSet.prototype.add = function add2(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty) {
    return DecorationSet.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet.prototype.addInner = function addInner(doc2, decorations, offset3) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset3, found2;
    if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
    }
    childIndex += 3;
  });
  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset3);
  for (var i2 = 0; i2 < local.length; i2++) {
    if (!local[i2].type.valid(doc2, local[i2])) {
      local.splice(i2--, 1);
    }
  }
  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
};
DecorationSet.prototype.remove = function remove(decorations) {
  if (decorations.length == 0 || this == empty) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet.prototype.removeInner = function removeInner(decorations, offset3) {
  var children = this.children, local = this.local;
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    var found2 = void 0, from5 = children[i2] + offset3, to = children[i2 + 1] + offset3;
    for (var j2 = 0, span = void 0; j2 < decorations.length; j2++) {
      if (span = decorations[j2]) {
        if (span.from > from5 && span.to < to) {
          decorations[j2] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this.children) {
      children = this.children.slice();
    }
    var removed = children[i2 + 2].removeInner(found2, from5 + 1);
    if (removed != empty) {
      children[i2 + 2] = removed;
    } else {
      children.splice(i2, 3);
      i2 -= 3;
    }
  }
  if (local.length) {
    for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
      if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].eq(span$1, offset3)) {
            if (local == this.local) {
              local = this.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet(local, children) : empty;
};
DecorationSet.prototype.forChild = function forChild(offset3, node5) {
  if (this == empty) {
    return this;
  }
  if (node5.isLeaf) {
    return DecorationSet.empty;
  }
  var child3, local;
  for (var i2 = 0; i2 < this.children.length; i2 += 3) {
    if (this.children[i2] >= offset3) {
      if (this.children[i2] == offset3) {
        child3 = this.children[i2 + 2];
      }
      break;
    }
  }
  var start4 = offset3 + 1, end3 = start4 + node5.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end3 && dec.to > start4 && dec.type instanceof InlineType) {
      var from5 = Math.max(start4, dec.from) - start4, to = Math.min(end3, dec.to) - start4;
      if (from5 < to) {
        (local || (local = [])).push(dec.copy(from5, to));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet(local.sort(byPos));
    return child3 ? new DecorationGroup([localSet, child3]) : localSet;
  }
  return child3 || empty;
};
DecorationSet.prototype.eq = function eq10(other) {
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!this.local[i2].eq(other.local[i2])) {
      return false;
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
      return false;
    }
  }
  return true;
};
DecorationSet.prototype.locals = function locals(node5) {
  return removeOverlap(this.localsInner(node5));
};
DecorationSet.prototype.localsInner = function localsInner(node5) {
  if (this == empty) {
    return none;
  }
  if (node5.inlineContent || !this.local.some(InlineType.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!(this.local[i2].type instanceof InlineType)) {
      result2.push(this.local[i2]);
    }
  }
  return result2;
};
var empty = new DecorationSet();
DecorationSet.empty = empty;
DecorationSet.removeOverlap = removeOverlap;
var DecorationGroup = function DecorationGroup2(members) {
  this.members = members;
};
DecorationGroup.prototype.map = function map12(mapping, doc2) {
  var mappedDecos = this.members.map(function(member) {
    return member.map(mapping, doc2, noSpec);
  });
  return DecorationGroup.from(mappedDecos);
};
DecorationGroup.prototype.forChild = function forChild2(offset3, child3) {
  if (child3.isLeaf) {
    return DecorationSet.empty;
  }
  var found2 = [];
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var result2 = this.members[i2].forChild(offset3, child3);
    if (result2 == empty) {
      continue;
    }
    if (result2 instanceof DecorationGroup) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup.from(found2);
};
DecorationGroup.prototype.eq = function eq11(other) {
  if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.members.length; i2++) {
    if (!this.members[i2].eq(other.members[i2])) {
      return false;
    }
  }
  return true;
};
DecorationGroup.prototype.locals = function locals2(node5) {
  var result2, sorted = true;
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var locals3 = this.members[i2].localsInner(node5);
    if (!locals3.length) {
      continue;
    }
    if (!result2) {
      result2 = locals3;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j2 = 0; j2 < locals3.length; j2++) {
        result2.push(locals3[j2]);
      }
    }
  }
  return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
};
DecorationGroup.from = function from3(members) {
  switch (members.length) {
    case 0:
      return empty;
    case 1:
      return members[0];
    default:
      return new DecorationGroup(members);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node5, offset3, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i3 = 0; i3 < children.length; i3 += 3) {
      var end3 = children[i3 + 1], dSize = void 0;
      if (end3 < 0 || oldStart > end3 + oldOffset) {
        continue;
      }
      var start4 = children[i3] + oldOffset;
      if (oldEnd >= start4) {
        children[i3 + 1] = oldStart <= start4 ? -2 : -1;
      } else if (newStart >= offset3 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i3] += dSize;
        children[i3 + 1] += dSize;
      }
    }
  };
  for (var i2 = 0; i2 < mapping.maps.length; i2++) {
    mapping.maps[i2].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] < 0) {
      if (children[i$1 + 1] == -2) {
        mustRebuild = true;
        children[i$1 + 1] = -1;
        continue;
      }
      var from5 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from5 - offset3;
      if (fromLocal < 0 || fromLocal >= node5.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset3;
      var ref = node5.content.findIndex(fromLocal);
      var index3 = ref.index;
      var childOffset = ref.offset;
      var childNode = node5.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from5 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset3, oldOffset, options);
    var built = buildTree(decorations, node5, 0, options);
    newLocal = built.local;
    for (var i$22 = 0; i$22 < children.length; i$22 += 3) {
      if (children[i$22 + 1] < 0) {
        children.splice(i$22, 3);
        i$22 -= 3;
      }
    }
    for (var i$3 = 0, j2 = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j2 < children.length && children[j2] < from$1) {
        j2 += 3;
      }
      children.splice(j2, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset3) {
  if (!offset3 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i2 = 0; i2 < spans.length; i2++) {
    var span = spans[i2];
    result2.push(new Decoration(span.from + offset3, span.to + offset3, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset3, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (var i3 = 0; i3 < set2.local.length; i3++) {
      var mapped = set2.local[i3].map(mapping, offset3, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set2.local[i3].spec);
      }
    }
    for (var i$1 = 0; i$1 < set2.children.length; i$1 += 3) {
      gather(set2.children[i$1 + 2], set2.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    if (children[i2 + 1] == -1) {
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node5, offset3) {
  if (node5.isLeaf) {
    return null;
  }
  var end3 = offset3 + node5.nodeSize, found2 = null;
  for (var i2 = 0, span = void 0; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset3 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i2 = 0; i2 < array.length; i2++) {
    if (array[i2] != null) {
      result2.push(array[i2]);
    }
  }
  return result2;
}
function buildTree(spans, node5, offset3, options) {
  var children = [], hasNulls = false;
  node5.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset3);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset3 + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset3).sort(byPos);
  for (var i2 = 0; i2 < locals3.length; i2++) {
    if (!locals3[i2].type.valid(node5, locals3[i2])) {
      if (options.onRemove) {
        options.onRemove(locals3[i2].spec);
      }
      locals3.splice(i2--, 1);
    }
  }
  return locals3.length || children.length ? new DecorationSet(locals3, children) : empty;
}
function byPos(a2, b2) {
  return a2.from - b2.from || a2.to - b2.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i2 = 0; i2 < working.length - 1; i2++) {
    var span = working[i2];
    if (span.from != span.to) {
      for (var j2 = i2 + 1; j2 < working.length; j2++) {
        var next2 = working[j2];
        if (next2.from == span.from) {
          if (next2.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j2] = next2.copy(next2.from, span.to);
            insertAhead(working, j2 + 1, next2.copy(span.to, next2.to));
          }
          continue;
        } else {
          if (next2.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i2] = span.copy(span.from, next2.from);
            insertAhead(working, j2, span.copy(next2.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i2, deco) {
  while (i2 < array.length && byPos(deco, array[i2]) > 0) {
    i2++;
  }
  array.splice(i2, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f2) {
    var result2 = f2(view.state);
    if (result2 && result2 != empty) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup.from(found2);
}
var EditorView = function EditorView2(place, props) {
  this._props = props;
  this.state = props.state;
  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.trackWrites = null;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput(this);
  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$2 = { props: { configurable: true }, root: { configurable: true }, isDestroyed: { configurable: true } };
prototypeAccessors$2.props.get = function() {
  if (this._props.state != this.state) {
    var prev2 = this._props;
    this._props = {};
    for (var name in prev2) {
      this._props[name] = prev2[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView.prototype.update = function update(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners(this);
  }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};
EditorView.prototype.setProps = function setProps(props) {
  var updated = {};
  for (var name in this._props) {
    updated[name] = this._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView.prototype.updateState = function updateState(state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};
EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
  var this$1$1 = this;
  var prev2 = this.state, redraw = false, updateSel = false;
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }
  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
  var scroll = reconfigured ? "reset" : state.scrollToSelection > prev2.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev2.selection)) {
    updateSel = true;
  }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
  if (updateSel) {
    this.domObserver.stop();
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev2.selection.empty && !state.selection.empty && selectionContextChanged(prev2.selection, state.selection);
    if (updateDoc) {
      var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) {
        forceSelUpdate = true;
      }
    }
    if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }
  this.updatePluginViews(prev2);
  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof NodeSelection) {
      scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
    }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};
EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
  var view;
  while (view = this.pluginViews.pop()) {
    if (view.destroy) {
      view.destroy();
    }
  }
};
EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i2 = 0; i2 < this.directPlugins.length; i2++) {
      var plugin = this.directPlugins[i2];
      if (plugin.spec.view) {
        this.pluginViews.push(plugin.spec.view(this));
      }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) {
        this.pluginViews.push(plugin$1.spec.view(this));
      }
    }
  } else {
    for (var i$22 = 0; i$22 < this.pluginViews.length; i$22++) {
      var pluginView = this.pluginViews[i$22];
      if (pluginView.update) {
        pluginView.update(this, prevState);
      }
    }
  }
};
EditorView.prototype.someProp = function someProp(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  for (var i2 = 0; i2 < this.directPlugins.length; i2++) {
    var prop$1 = this.directPlugins[i2].props[propName];
    if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
      return value;
    }
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i$1 = 0; i$1 < plugins.length; i$1++) {
      var prop$2 = plugins[i$1].props[propName];
      if (prop$2 != null && (value = f2 ? f2(prop$2) : prop$2)) {
        return value;
      }
    }
  }
};
EditorView.prototype.hasFocus = function hasFocus() {
  return this.root.activeElement == this.dom;
};
EditorView.prototype.focus = function focus() {
  this.domObserver.stop();
  if (this.editable) {
    focusPreventScroll(this.dom);
  }
  selectionToDOM(this);
  this.domObserver.start();
};
prototypeAccessors$2.root.get = function() {
  var cached = this._root;
  if (cached == null) {
    for (var search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
        if (!search.getSelection) {
          Object.getPrototypeOf(search).getSelection = function() {
            return document.getSelection();
          };
        }
        return this._root = search;
      }
    }
  }
  return cached || document;
};
EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
  return posAtCoords(this, coords);
};
EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
  if (side === void 0)
    side = 1;
  return coordsAtPos(this, pos, side);
};
EditorView.prototype.domAtPos = function domAtPos(pos, side) {
  if (side === void 0)
    side = 0;
  return this.docView.domFromPos(pos, side);
};
EditorView.prototype.nodeDOM = function nodeDOM(pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null;
};
EditorView.prototype.posAtDOM = function posAtDOM(node5, offset3, bias) {
  if (bias === void 0)
    bias = -1;
  var pos = this.docView.posFromDOM(node5, offset3, bias);
  if (pos == null) {
    throw new RangeError("DOM position not inside the editor");
  }
  return pos;
};
EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
  return endOfTextblock(this, state || this.state, dir);
};
EditorView.prototype.destroy = function destroy3() {
  if (!this.docView) {
    return;
  }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
prototypeAccessors$2.isDestroyed.get = function() {
  return this.docView == null;
};
EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
  return dispatchEvent(this, event);
};
EditorView.prototype.dispatch = function dispatch(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction.call(this, tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView.prototype, prototypeAccessors$2);
function computeDocDeco(view) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        }
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews(a2, b2) {
  var nA = 0, nB = 0;
  for (var prop in a2) {
    if (a2[prop] != b2[prop]) {
      return true;
    }
    nA++;
  }
  for (var _2 in b2) {
    nB++;
  }
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) {
    throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac$1 || +chrome[1] < 57) || gecko && mac$1;
for (var i$1 = 0; i$1 < 10; i$1++)
  base[48 + i$1] = base[96 + i$1] = String(i$1);
for (var i$1 = 1; i$1 <= 24; i$1++)
  base[i$1 + 111] = "F" + i$1;
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie$1) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta;
  for (var i2 = 0; i2 < parts.length - 1; i2++) {
    var mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize(map14) {
  var copy5 = /* @__PURE__ */ Object.create(null);
  for (var prop in map14) {
    copy5[normalizeKeyName$1(prop)] = map14[prop];
  }
  return copy5;
}
function modifiers(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map14 = normalize(bindings);
  return function(view, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map14[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
      var fromCode = map14[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) {
        return true;
      }
    } else if (isChar && event.shiftKey) {
      var withShift = map14[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) {
        return true;
      }
    }
    return false;
  };
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = __spreadValues({}, target);
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind(__spreadProps(__spreadValues({}, context), {
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    }));
    return value;
  }
  return extension.config[field];
}
class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range, options) {
  const { from: from5, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text3 = "";
  let separated = true;
  startNode.nodesBetween(from5, to, (node5, pos, parent, index3) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node5.type.name];
    if (textSerializer) {
      if (node5.isBlock && !separated) {
        text3 += blockSeparator;
        separated = true;
      }
      text3 += textSerializer({
        node: node5,
        pos,
        parent,
        index: index3
      });
    } else if (node5.isText) {
      text3 += (_a = node5 === null || node5 === void 0 ? void 0 : node5.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from5, pos) - pos, to - pos);
      separated = false;
    } else if (node5.isBlock && !separated) {
      text3 += blockSeparator;
      separated = true;
    }
  });
  return text3;
}
function getTextSeralizersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node5]) => node5.spec.toText).map(([name, node5]) => [name, node5.spec.toText]));
}
const ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from5 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSeralizersFromSchema(schema);
            const range = { from: from5, to };
            return getTextBetween(doc2, range, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var blur$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur
});
const clearContent = (emitUpdate = false) => ({ commands }) => {
  return commands.setContent("", emitUpdate);
};
var clearContent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clearContent
});
const clearNodes = () => ({ state, tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node5, pos) => {
      if (node5.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node5.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node5.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var clearNodes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clearNodes
});
const command = (fn3) => (props) => {
  return fn3(props);
};
var command$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  command
});
const createParagraphNear = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$2(state, dispatch2);
};
var createParagraphNear$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createParagraphNear
});
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
const deleteNode = (typeOrName) => ({ tr, state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node5 = $pos.node(depth);
    if (node5.type === type) {
      if (dispatch2) {
        const from5 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from5, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteNode
});
const deleteRange = (range) => ({ tr, dispatch: dispatch2 }) => {
  const { from: from5, to } = range;
  if (dispatch2) {
    tr.delete(from5, to);
  }
  return true;
};
var deleteRange$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteRange
});
const deleteSelection = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$2(state, dispatch2);
};
var deleteSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteSelection
});
const enter2 = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var enter$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  enter: enter2
});
const exitCode = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$2(state, dispatch2);
};
var exitCode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  exitCode
});
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks2, type, attributes = {}) {
  return marks2.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks2, type, attributes = {}) {
  return !!findMarkInSet(marks2, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  const start4 = $pos.parent.childAfter($pos.parentOffset);
  if (!start4.node) {
    return;
  }
  const mark3 = findMarkInSet(start4.node.marks, type, attributes);
  if (!mark3) {
    return;
  }
  let startIndex2 = $pos.index();
  let startPos = $pos.start() + start4.offset;
  let endIndex2 = startIndex2 + 1;
  let endPos = startPos + start4.node.nodeSize;
  findMarkInSet(start4.node.marks, type, attributes);
  while (startIndex2 > 0 && mark3.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex2).marks, type, attributes)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr;
  const { $from, from: from5, to } = selection;
  if (dispatch2) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from5 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var extendMarkRange$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  extendMarkRange
});
const first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    if (items[i2](props)) {
      return true;
    }
  }
  return false;
};
var first$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  first
});
function isClass(value) {
  var _a;
  if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== "class") {
    return false;
  }
  return true;
}
function isObject(value) {
  return value && typeof value === "object" && !Array.isArray(value) && !isClass(value);
}
function isTextSelection(value) {
  return isObject(value) && value instanceof TextSelection;
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function minMax(value = 0, min3 = 0, max3 = 0) {
  return Math.min(Math.max(value, min3), max3);
}
function resolveFocusPosition(doc2, position2 = null) {
  if (!position2) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position2 === "start" || position2 === true) {
    return selectionAtStart;
  }
  if (position2 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position2 === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position2, minPos, maxPos), minMax(position2, minPos, maxPos));
}
const focus2 = (position2 = null, options) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  options = __spreadValues({
    scrollIntoView: true
  }, options);
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position2 === null || position2 === false) {
    return true;
  }
  if (dispatch2 && position2 === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(editor.state.doc, position2) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var focus$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  focus: focus2
});
const forEach4 = (items, fn3) => (props) => {
  return items.every((item, index3) => fn3(item, __spreadProps(__spreadValues({}, props), { index: index3 })));
};
var forEach$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  forEach: forEach4
});
const insertContent = (value, options) => ({ tr, commands }) => {
  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
var insertContent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  insertContent
});
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content2, schema, options) {
  options = __spreadValues({
    slice: true,
    parseOptions: {}
  }, options);
  if (typeof content2 === "object" && content2 !== null) {
    try {
      if (Array.isArray(content2)) {
        return Fragment.fromArray(content2.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content2);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content2, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content2 === "string") {
    const parser = DOMParser$1.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content2), options.parseOptions).content : parser.parse(elementFromString(content2), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step2 = tr.steps[last];
  if (!(step2 instanceof ReplaceStep || step2 instanceof ReplaceAroundStep)) {
    return;
  }
  const map14 = tr.mapping.maps[last];
  let end3 = 0;
  map14.forEach((_from, _to, _newFrom, newTo) => {
    if (end3 === 0) {
      end3 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
const isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
const insertContentAt = (position2, value, options) => ({ tr, dispatch: dispatch2, editor }) => {
  if (dispatch2) {
    options = __spreadValues({
      parseOptions: {},
      updateSelection: true
    }, options);
    const content2 = createNodeFromContent(value, editor.schema, {
      parseOptions: __spreadValues({
        preserveWhitespace: "full"
      }, options.parseOptions)
    });
    if (content2.toString() === "<>") {
      return true;
    }
    let { from: from5, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content2) ? content2 : [content2];
    nodes.forEach((node5) => {
      node5.check();
      isOnlyTextContent = isOnlyTextContent ? node5.isText && node5.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node5.isBlock : false;
    });
    if (from5 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from5);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from5 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      tr.insertText(value, from5, to);
    } else {
      tr.replaceWith(from5, to, content2);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
  }
  return true;
};
var insertContentAt$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  insertContentAt
});
const joinBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$2(state, dispatch2);
};
var joinBackward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  joinBackward
});
const joinForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$2(state, dispatch2);
};
var joinForward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  joinForward
});
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result2 = parts[parts.length - 1];
  if (result2 === "Space") {
    result2 = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result2 = `Alt-${result2}`;
  }
  if (ctrl) {
    result2 = `Ctrl-${result2}`;
  }
  if (meta) {
    result2 = `Meta-${result2}`;
  }
  if (shift2) {
    result2 = `Shift-${result2}`;
  }
  return result2;
}
const keyboardShortcut = (name) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f2) => f2(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step2) => {
    const newStep = step2.map(tr.mapping);
    if (newStep && dispatch2) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
var keyboardShortcut$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  keyboardShortcut
});
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from5, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from5, to, (node5, pos) => {
    if (node5.isText) {
      return;
    }
    const relativeFrom = Math.max(from5, pos);
    const relativeTo = Math.min(to, pos + node5.nodeSize);
    nodeRanges.push({
      node: node5,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from5;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
const lift = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$2(state, dispatch2);
};
var lift$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  lift
});
const liftEmptyBlock = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$2(state, dispatch2);
};
var liftEmptyBlock$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  liftEmptyBlock
});
const liftListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$2(type)(state, dispatch2);
};
var liftListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  liftListItem
});
const newlineInCode = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$2(state, dispatch2);
};
var newlineInCode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  newlineInCode
});
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch: dispatch2 }) => {
  let nodeType2 = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType2 = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node5, pos) => {
        if (nodeType2 && nodeType2 === node5.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node5.attrs, attributes));
        }
        if (markType && node5.marks.length) {
          node5.marks.forEach((mark3) => {
            if (markType === mark3.type) {
              tr.addMark(pos, pos + node5.nodeSize, markType.create(deleteProps(mark3.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var resetAttributes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  resetAttributes
});
const scrollIntoView = () => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr.scrollIntoView();
  }
  return true;
};
var scrollIntoView$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  scrollIntoView
});
const selectAll = () => ({ tr, commands }) => {
  return commands.setTextSelection({
    from: 0,
    to: tr.doc.content.size
  });
};
var selectAll$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectAll
});
const selectNodeBackward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$2(state, dispatch2);
};
var selectNodeBackward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectNodeBackward
});
const selectNodeForward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$2(state, dispatch2);
};
var selectNodeForward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectNodeForward
});
const selectParentNode = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$2(state, dispatch2);
};
var selectParentNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectParentNode
});
const selectTextblockEnd = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$2(state, dispatch2);
};
var selectTextblockEnd$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectTextblockEnd
});
const selectTextblockStart = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$2(state, dispatch2);
};
var selectTextblockStart$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectTextblockStart
});
function createDocument(content2, schema, parseOptions = {}) {
  return createNodeFromContent(content2, schema, { slice: false, parseOptions });
}
const setContent = (content2, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch: dispatch2 }) => {
  const { doc: doc2 } = tr;
  const document2 = createDocument(content2, editor.schema, parseOptions);
  const selection = TextSelection.create(doc2, 0, doc2.content.size);
  if (dispatch2) {
    tr.setSelection(selection).replaceSelectionWith(document2, false).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
var setContent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setContent
});
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from5, to, empty: empty2 } = state.selection;
  const marks2 = [];
  if (empty2) {
    if (state.storedMarks) {
      marks2.push(...state.storedMarks);
    }
    marks2.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from5, to, (node5) => {
      marks2.push(...node5.marks);
    });
  }
  const mark3 = marks2.find((markItem) => markItem.type.name === type.name);
  if (!mark3) {
    return {};
  }
  return __spreadValues({}, mark3.attrs);
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(type.create(__spreadValues(__spreadValues({}, oldAttributes), attributes)));
    } else {
      ranges.forEach((range) => {
        const from5 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from5, to, (node5, pos) => {
          const trimmedFrom = Math.max(pos, from5);
          const trimmedTo = Math.min(pos + node5.nodeSize, to);
          const someHasMark = node5.marks.find((mark3) => mark3.type === type);
          if (someHasMark) {
            node5.marks.forEach((mark3) => {
              if (type === mark3.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create(__spreadValues(__spreadValues({}, mark3.attrs), attributes)));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return true;
};
var setMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setMark
});
const setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
var setMeta$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setMeta
});
const setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands }) => {
    const canSetBlock = setBlockType(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, attributes)(updatedState, dispatch2);
  }).run();
};
var setNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setNode
});
const setNodeSelection = (position2) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const minPos = Selection.atStart(doc2).from;
    const maxPos = Selection.atEnd(doc2).to;
    const resolvedPos = minMax(position2, minPos, maxPos);
    const selection = NodeSelection.create(doc2, resolvedPos);
    tr.setSelection(selection);
  }
  return true;
};
var setNodeSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setNodeSelection
});
const setTextSelection = (position2) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const { from: from5, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from5, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setTextSelection
});
const sinkListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$2(type)(state, dispatch2);
};
var sinkListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sinkListItem
});
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function defaultBlockAt$1(match2) {
  for (let i2 = 0; i2 < match2.edgeCount; i2 += 1) {
    const { type } = match2.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function ensureMarks(state, splittableMarks) {
  const marks2 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks2) {
    const filteredMarks = marks2.filter((mark3) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark3.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    const atEnd2 = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd2 && deflt ? [{
      type: deflt,
      attrs: newAttributes
    }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd2 && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return true;
};
var splitBlock$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  splitBlock
});
const splitListItem = (typeOrName) => ({ tr, state, dispatch: dispatch2, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node5 = state.selection.node;
  if (node5 && node5.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d2 = $from.depth - depthBefore; d2 >= $from.depth - 3; d2 -= 1) {
        wrap = Fragment.from($from.node(d2).copy(wrap));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start4 = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start4, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start4, tr.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    tr.split($from.pos, 2, types).scrollIntoView();
  }
  return true;
};
var splitListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  splitListItem
});
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
    const node5 = $pos.node(i2);
    if (predicate(node5)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node: node5
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
const joinListBackwards = (tr, listType) => {
  const list = findParentNode((node5) => node5.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before2 = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before2 === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before2);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
const joinListForwards = (tr, listType) => {
  const list = findParentNode((node5) => node5.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after2 = tr.doc.resolve(list.start).after(list.depth);
  if (after2 === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after2);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after2);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after2);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch: dispatch2, chain, commands, can }) => {
  const { extensions: extensions2 } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node5) => isList(node5.type.name, extensions2))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleList$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleList
});
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark3) => {
      if (!type) {
        return true;
      }
      return type.name === mark3.type.name;
    }).find((mark3) => objectIncludes(mark3.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from5 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from5, to, (node5, pos) => {
      if (!node5.isText && !node5.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from5, pos);
      const relativeTo = Math.min(to, pos + node5.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node5.marks.map((mark3) => ({
        mark: mark3,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleMark
});
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.setNode(toggleType);
  }
  return commands.setNode(type, attributes);
};
var toggleNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleNode
});
const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var toggleWrap$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleWrap
});
const undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i2 = 0; i2 < plugins.length; i2 += 1) {
    const plugin = plugins[i2];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
          tr.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
        }
        if (undoable.text) {
          const marks2 = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks2));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var undoInputRule$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  undoInputRule
});
const unsetAllMarks = () => ({ tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetAllMarks$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unsetAllMarks
});
const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from5, to } = selection;
    const attrs = (_a = $from.marks().find((mark3) => mark3.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from5 = range.from;
      to = range.to;
    }
    tr.removeMark(from5, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
var unsetMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unsetMark
});
const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  let nodeType2 = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType2 = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range) => {
      const from5 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from5, to, (node5, pos) => {
        if (nodeType2 && nodeType2 === node5.type) {
          tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, node5.attrs), attributes));
        }
        if (markType && node5.marks.length) {
          node5.marks.forEach((mark3) => {
            if (markType === mark3.type) {
              const trimmedFrom = Math.max(pos, from5);
              const trimmedTo = Math.min(pos + node5.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create(__spreadValues(__spreadValues({}, mark3.attrs), attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var updateAttributes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  updateAttributes
});
const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$2(type, attributes)(state, dispatch2);
};
var wrapIn$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  wrapIn
});
const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$2(type, attributes)(state, dispatch2);
};
var wrapInList$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  wrapInList
});
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, blur$1), clearContent$1), clearNodes$1), command$1), createParagraphNear$1), deleteNode$1), deleteRange$1), deleteSelection$1), enter$1), exitCode$1), extendMarkRange$1), first$1), focus$1), forEach$1), insertContent$1), insertContentAt$1), joinBackward$1), joinForward$1), keyboardShortcut$1), lift$1), liftEmptyBlock$1), liftListItem$1), newlineInCode$1), resetAttributes$1), scrollIntoView$1), selectAll$1), selectNodeBackward$1), selectNodeForward$1), selectParentNode$1), selectTextblockEnd$1), selectTextblockStart$1), setContent$1), setMark$1), setMeta$1), setNode$1), setNodeSelection$1), setTextSelection$1), sinkListItem$1), splitBlock$1), splitListItem$1), toggleList$1), toggleMark$1), toggleNode$1), toggleWrap$1), undoInputRule$1), unsetAllMarks$1), unsetMark$1), updateAttributes$1), wrapIn$1), wrapInList$1);
  }
});
const Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return __spreadProps(__spreadValues({}, state), {
    schema: state.schema,
    plugins: state.plugins,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  });
}
class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const chainedCommand = (...args) => {
        const props = this.buildProps(tr, shouldDispatch);
        const callback = command2(...args)(props);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    }))), {
      run: run2
    });
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = void 0;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch2);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)(__spreadProps(__spreadValues({}, props), { dispatch: dispatch2 }))];
    }));
    return __spreadProps(__spreadValues({}, formattedCommands), {
      chain: () => this.createChain(tr, dispatch2)
    });
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    if (state.storedMarks) {
      tr.setStoredMarks(state.storedMarks);
    }
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
}
const Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      () => commands.command(({ tr }) => {
        const { selection, doc: doc2 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const isAtStart = Selection.atStart(doc2).from === pos;
        if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = __spreadProps(__spreadValues({}, baseKeymap), {
      Home: () => this.editor.commands.selectTextblockStart(),
      End: () => this.editor.commands.selectTextblockEnd()
    });
    const macKeymap = __spreadProps(__spreadValues({}, baseKeymap), {
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    });
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty2, from: from5, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from5 === allFrom && to === allEnd;
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (empty2 || !allWasSelected || !isEmpty) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
const Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => {
            if (this.editor.isEditable) {
              return {
                tabindex: "0"
              };
            }
          }
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from5, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from5, to, (node6) => {
    nodes.push(node6);
  });
  const node5 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node5) {
    return {};
  }
  return __spreadValues({}, node5.attrs);
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText(node5, options) {
  const range = {
    from: 0,
    to: node5.content.size
  };
  return getTextBetween(node5, range, options);
}
function isNodeEmpty(node5) {
  var _a;
  const defaultContent = (_a = node5.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content2 = node5.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content2);
}
function createStyleTag(style2) {
  const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
  if (tipTapStyleTag !== null) {
    return tipTapStyleTag;
  }
  const styleNode = document.createElement("style");
  styleNode.setAttribute("data-tiptap-style", "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text3, find3) => {
  if (isRegExp(find3)) {
    return find3.exec(text3);
  }
  const inputRuleMatch = find3(text3);
  if (!inputRuleMatch) {
    return null;
  }
  const result2 = [];
  result2.push(inputRuleMatch.text);
  result2.index = inputRuleMatch.index;
  result2.input = text3;
  result2.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result2.push(inputRuleMatch.replaceWith);
  }
  return result2;
};
function run$1$1(config) {
  var _a;
  const { editor, from: from5, to, text: text3, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from5);
  if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark3) => mark3.type.spec.code))) {
    return false;
  }
  let matched = false;
  const maxMatch = 500;
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, void 0, " ") + text3;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match2 = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match2) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range = {
      from: from5 - (match2[0].length - text3.length),
      to
    };
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match: match2,
      commands,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from: from5,
      to,
      text: text3
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev2) {
        const stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev2;
      }
    },
    props: {
      handleTextInput(view, from5, to, text3) {
        return run$1$1({
          editor,
          from: from5,
          to,
          text: text3,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const pasteRuleMatcherHandler = (text3, find3) => {
  if (isRegExp(find3)) {
    return [...text3.matchAll(find3)];
  }
  const matches2 = find3(text3);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result2 = [];
    result2.push(pasteRuleMatch.text);
    result2.index = pasteRuleMatch.index;
    result2.input = text3;
    result2.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result2.push(pasteRuleMatch.replaceWith);
    }
    return result2;
  });
};
function run$2(config) {
  const { editor, state, from: from5, to, rule } = config;
  const { commands, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from5, to, (node5, pos) => {
    if (!node5.isTextblock || node5.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from5, pos);
    const resolvedTo = Math.min(to, pos + node5.content.size);
    const textToMatch = node5.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
    matches2.forEach((match2) => {
      if (match2.index === void 0) {
        return;
      }
      const start4 = resolvedFrom + match2.index + 1;
      const end3 = start4 + match2[0].length;
      const range = {
        from: state.tr.mapping.map(start4),
        to: state.tr.mapping.map(end3)
      };
      const handler = rule.handler({
        state,
        range,
        match: match2,
        commands,
        chain,
        can
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  const plugins = rules.map((rule) => {
    return new Plugin({
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            return false;
          },
          paste: (view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from5 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from5) || !to || from5 === to.b) {
          return;
        }
        const tr = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr
        });
        const handler = run$2({
          editor,
          state: chainableState,
          from: Math.max(from5 - 1, 0),
          to: to.b,
          rule
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        return tr;
      }
    });
  });
  return plugins;
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute)
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute)
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = __spreadValues({}, items);
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        mergedAttributes[key] = [mergedAttributes[key], value].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule2, extensionAttributes) {
  if (parseRule2.style) {
    return parseRule2;
  }
  return __spreadProps(__spreadValues({}, parseRule2), {
    getAttrs: (node5) => {
      const oldAttributes = parseRule2.getAttrs ? parseRule2.getAttrs(node5) : parseRule2.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node5) : fromString(node5.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return __spreadProps(__spreadValues({}, items), {
          [item.name]: value
        });
      }, {});
      return __spreadValues(__spreadValues({}, oldAttributes), newAttributes);
    }
  });
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  }));
}
function getSchemaByResolvedExtensions(extensions2) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraNodeFields = extensions2.reduce((fields, e2) => {
      const extendNodeSchema = getExtensionField(e2, "extendNodeSchema", context);
      return __spreadValues(__spreadValues({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
    }, {});
    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraNodeFields), {
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    }));
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node5) => renderHTML({
        node: node5,
        HTMLAttributes: getRenderedAttributes(node5, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks2 = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraMarkFields = extensions2.reduce((fields, e2) => {
      const extendMarkSchema = getExtensionField(e2, "extendMarkSchema", context);
      return __spreadValues(__spreadValues({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
    }, {});
    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraMarkFields), {
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    }));
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark3) => renderHTML({
        mark: mark3,
        HTMLAttributes: getRenderedAttributes(mark3, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks: marks2
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function findDuplicates(items) {
  const filtered = items.filter((el2, index3) => items.indexOf(el2) !== index3);
  return [...new Set(filtered)];
}
class ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [
          extension,
          ...this.flatten(addExtensions())
        ];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a2, b2) => {
      const priorityA = getExtensionField(a2, "priority") || defaultPriority;
      const priorityB = getExtensionField(b2, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return __spreadValues(__spreadValues({}, commands), addCommands());
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        const keyMapPlugin = keymap(bindings);
        plugins.push(keyMapPlugin);
      }
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node5, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node5, extensionAttributes);
        return addNodeView()({
          editor,
          node: node5,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
}
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn3) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn3);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn3) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn3) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn3);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
class Editor$1 extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style);
    }
  }
  setOptions(options = {}) {
    this.options = __spreadValues(__spreadValues({}, this.options), options);
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  setEditable(editable) {
    this.setOptions({ editable });
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, this.state.plugins) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, __spreadProps(__spreadValues({}, this.options.editorProps), {
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc2,
        selection
      })
    }));
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    const dom = this.view.dom;
    dom.editor = this;
  }
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(fn3) {
    this.isCapturingTransaction = true;
    fn3();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  dispatchTransaction(transaction) {
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step2) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step2);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus3 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus3) {
      this.emit("focus", {
        editor: this,
        event: focus3.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: __spreadValues(__spreadValues({}, textSerializers), getTextSeralizersFromSchema(this.schema))
    });
  }
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
}
class Node2 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node2(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
class Mark2 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark2(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getMarksBetween(from5, to, doc2) {
  const marks2 = [];
  if (from5 === to) {
    doc2.resolve(from5).marks().forEach((mark3) => {
      const $pos = doc2.resolve(from5 - 1);
      const range = getMarkRange($pos, mark3.type);
      if (!range) {
        return;
      }
      marks2.push(__spreadValues({
        mark: mark3
      }, range));
    });
  } else {
    doc2.nodesBetween(from5, to, (node5, pos) => {
      marks2.push(...node5.marks.map((mark3) => ({
        from: pos,
        to: pos + node5.nodeSize,
        mark: mark3
      })));
    });
  }
  return marks2;
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      const tr = state.tr.delete(range.from, range.to);
      const $start = tr.doc.resolve(range.from);
      const blockRange2 = $start.blockRange();
      const wrapping = blockRange2 && findWrapping3(blockRange2, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange2, wrapping);
      const before2 = tr.doc.resolve(range.from - 1).nodeBefore;
      if (before2 && before2.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match2, before2))) {
        tr.join(range.from - 1);
      }
    }
  });
}
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step2) => {
      transform.step(step2);
    });
  });
  return transform;
}
function findChildrenInRange(node5, range, predicate) {
  const nodesWithPos = [];
  node5.nodesBetween(range.from, range.to, (child3, pos) => {
    if (predicate(child3)) {
      nodesWithPos.push({
        node: child3,
        pos
      });
    }
  });
  return nodesWithPos;
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index3) => {
    const rest = uniqueChanges.filter((_2, i2) => i2 !== index3);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps: steps2 } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index3) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from5, to } = steps2[index3];
      if (from5 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from5, to });
    } else {
      stepMap.forEach((from5, to) => {
        ranges.push({ from: from5, to });
      });
    }
    ranges.forEach(({ from: from5, to }) => {
      const newStart = mapping.slice(index3).map(from5, -1);
      const newEnd = mapping.slice(index3).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function isNodeSelection(value) {
  return isObject(value) && value instanceof NodeSelection;
}
function posToDOMRect(view, from5, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from5, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start4 = view.coordsAtPos(resolvedFrom);
  const end3 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start4.top, end3.top);
  const bottom2 = Math.max(start4.bottom, end3.bottom);
  const left2 = Math.min(start4.left, end3.left);
  const right2 = Math.max(start4.right, end3.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x2 = left2;
  const y2 = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x: x2,
    y: y2
  };
  return __spreadProps(__spreadValues({}, data), {
    toJSON: () => data
  });
}
class BubbleMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from5, to }) => {
      const { doc: doc2, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc2.textBetween(from5, to).length && isTextSelection(state.selection);
      if (!view2.hasFocus() || empty2 || isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, __spreadValues({
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle"
    }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b;
    const { state, composing } = view;
    const { doc: doc2, selection } = state;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (composing || isSame) {
      return;
    }
    this.createTooltip();
    const { ranges } = selection;
    const from5 = Math.min(...ranges.map((range) => range.$from.pos));
    const to = Math.max(...ranges.map((range) => range.$to.pos));
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState,
      from: from5,
      to
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: () => {
        if (isNodeSelection(state.selection)) {
          const node5 = view.nodeDOM(from5);
          if (node5) {
            return node5.getBoundingClientRect();
          }
        }
        return posToDOMRect(view, from5, to);
      }
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView(__spreadValues({ view }, options))
  });
};
Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
class FloatingMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty: empty2 } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty2 || !isRootDepth || !isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, __spreadValues({
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle"
    }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b;
    const { state } = view;
    const { doc: doc2, selection } = state;
    const { from: from5, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: () => posToDOMRect(view, from5, to)
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const FloatingMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new FloatingMenuView(__spreadValues({ view }, options))
  });
};
Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
const BubbleMenu = (props) => {
  const [element, setElement] = react.exports.useState(null);
  react.exports.useEffect(() => {
    if (!element) {
      return;
    }
    if (props.editor.isDestroyed) {
      return;
    }
    const {
      pluginKey = "bubbleMenu",
      editor,
      tippyOptions = {},
      shouldShow = null
    } = props;
    const plugin = BubbleMenuPlugin({
      pluginKey,
      editor,
      element,
      tippyOptions,
      shouldShow
    });
    editor.registerPlugin(plugin);
    return () => editor.unregisterPlugin(pluginKey);
  }, [props.editor, element]);
  return /* @__PURE__ */ jsx("div", {
    ref: setElement,
    className: props.className,
    style: {
      visibility: "hidden"
    },
    children: props.children
  });
};
class Editor extends Editor$1 {
  constructor() {
    super(...arguments);
    this.contentComponent = null;
  }
}
function useForceUpdate() {
  const [, setValue] = react.exports.useState(0);
  return () => setValue((value) => value + 1);
}
const useEditor = (options = {}, deps = []) => {
  const [editor, setEditor] = react.exports.useState(null);
  const forceUpdate = useForceUpdate();
  react.exports.useEffect(() => {
    const instance = new Editor(options);
    setEditor(instance);
    instance.on("transaction", () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          forceUpdate();
        });
      });
    });
    return () => {
      instance.destroy();
    };
  }, deps);
  return editor;
};
const ReactNodeViewContext = react.exports.createContext({
  onDragStart: void 0
});
const useReactNodeView = () => react.exports.useContext(ReactNodeViewContext);
const Portals = ({
  renderers
}) => {
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: Array.from(renderers).map(([key, renderer]) => {
      return te.createPortal(renderer.reactElement, renderer.element, key);
    })
  });
};
class PureEditorContent extends e$3.Component {
  constructor(props) {
    super(props);
    this.editorContentRef = e$3.createRef();
    this.state = {
      renderers: /* @__PURE__ */ new Map()
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const {
      editor
    } = this.props;
    if (editor && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = this;
      editor.createNodeViews();
    }
  }
  componentWillUnmount() {
    const {
      editor
    } = this.props;
    if (!editor) {
      return;
    }
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const _a = this.props, {
      editor
    } = _a, rest = __objRest(_a, [
      "editor"
    ]);
    return /* @__PURE__ */ jsxs(Fragment$1, {
      children: [/* @__PURE__ */ jsx("div", __spreadValues({
        ref: this.editorContentRef
      }, rest)), /* @__PURE__ */ jsx(Portals, {
        renderers: this.state.renderers
      })]
    });
  }
}
const EditorContent = e$3.memo(PureEditorContent);
e$3.forwardRef((props, ref) => {
  const {
    onDragStart
  } = useReactNodeView();
  const Tag = props.as || "div";
  return /* @__PURE__ */ jsx(Tag, __spreadProps(__spreadValues({}, props), {
    ref,
    "data-node-view-wrapper": "",
    onDragStart,
    style: __spreadProps(__spreadValues({}, props.style), {
      whiteSpace: "normal"
    })
  }));
});
const Text$1 = Node2.create({
  name: "text",
  group: "inline"
});
const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
const Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node5) => node5.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
const Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node5) => node5.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
function State(token2) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token2;
}
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  tt: function tt(input, tokenOrState) {
    if (tokenOrState && tokenOrState.j) {
      this.j[input] = tokenOrState;
      return tokenOrState;
    }
    var token2 = tokenOrState;
    var nextState = this.j[input];
    if (nextState) {
      if (token2) {
        nextState.t = token2;
      }
      return nextState;
    }
    nextState = makeState();
    var templateState = takeT(this, input);
    if (templateState) {
      Object.assign(nextState.j, templateState.j);
      nextState.jr.append(templateState.jr);
      nextState.jr = templateState.jd;
      nextState.t = token2 || templateState.t;
    } else {
      nextState.t = token2;
    }
    this.j[input] = nextState;
    return nextState;
  }
};
var makeState = function makeState2() {
  return new State();
};
var makeAcceptingState = function makeAcceptingState2(token2) {
  return new State(token2);
};
var makeT = function makeT2(startState, input, nextState) {
  if (!startState.j[input]) {
    startState.j[input] = nextState;
  }
};
var makeRegexT = function makeRegexT2(startState, regex, nextState) {
  startState.jr.push([regex, nextState]);
};
var takeT = function takeT2(state, input) {
  var nextState = state.j[input];
  if (nextState) {
    return nextState;
  }
  for (var i2 = 0; i2 < state.jr.length; i2++) {
    var regex = state.jr[i2][0];
    var _nextState = state.jr[i2][1];
    if (regex.test(input)) {
      return _nextState;
    }
  }
  return state.jd;
};
var makeMultiT = function makeMultiT2(startState, chars, nextState) {
  for (var i2 = 0; i2 < chars.length; i2++) {
    makeT(startState, chars[i2], nextState);
  }
};
var makeBatchT = function makeBatchT2(startState, transitions) {
  for (var i2 = 0; i2 < transitions.length; i2++) {
    var input = transitions[i2][0];
    var nextState = transitions[i2][1];
    makeT(startState, input, nextState);
  }
};
var makeChainT = function makeChainT2(state, str, endState, defaultStateFactory) {
  var i2 = 0, len = str.length, nextState;
  while (i2 < len && (nextState = state.j[str[i2]])) {
    state = nextState;
    i2++;
  }
  if (i2 >= len) {
    return [];
  }
  while (i2 < len - 1) {
    nextState = defaultStateFactory();
    makeT(state, str[i2], nextState);
    state = nextState;
    i2++;
  }
  makeT(state, str[len - 1], endState);
};
var DOMAIN = "DOMAIN";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var NUM = "NUM";
var PROTOCOL = "PROTOCOL";
var MAILTO = "MAILTO";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var SYM = "SYM";
var text2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DOMAIN,
  LOCALHOST,
  TLD,
  NUM,
  PROTOCOL,
  MAILTO,
  WS,
  NL,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  SYM
});
var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xF6gensberater-ctb verm\xF6gensberatung-pwb \u03B5\u03BB \u03B5\u03C5 \u0431\u0433 \u0431\u0435\u043B \u0434\u0435\u0442\u0438 \u0435\u044E \u043A\u0430\u0442\u043E\u043B\u0438\u043A \u043A\u043E\u043C \u049B\u0430\u0437 \u043C\u043A\u0434 \u043C\u043E\u043D \u043C\u043E\u0441\u043A\u0432\u0430 \u043E\u043D\u043B\u0430\u0439\u043D \u043E\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043A\u0440 \u10D2\u10D4 \u0570\u0561\u0575 \u05D9\u05E9\u05E8\u05D0\u05DC \u05E7\u05D5\u05DD \u0627\u0628\u0648\u0638\u0628\u064A \u0627\u062A\u0635\u0627\u0644\u0627\u062A \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062F\u0646 \u0627\u0644\u0628\u062D\u0631\u064A\u0646 \u0627\u0644\u062C\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629 \u0627\u0644\u0639\u0644\u064A\u0627\u0646 \u0627\u0644\u0645\u063A\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062A \u0627\u06CC\u0631\u0627\u0646 \u0628\u0627\u0631\u062A \u0628\u0627\u0632\u0627\u0631 \u0628\u06BE\u0627\u0631\u062A \u0628\u064A\u062A\u0643 \u067E\u0627\u06A9\u0633\u062A\u0627\u0646 \u0680\u0627\u0631\u062A \u062A\u0648\u0646\u0633 \u0633\u0648\u062F\u0627\u0646 \u0633\u0648\u0631\u064A\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064A\u0646 \u0642\u0637\u0631 \u0643\u0627\u062B\u0648\u0644\u064A\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064A\u0633\u064A\u0627 \u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092E \u0928\u0947\u091F \u092D\u093E\u0930\u0924 \u092D\u093E\u0930\u0924\u092E\u094D \u092D\u093E\u0930\u094B\u0924 \u0938\u0902\u0917\u0920\u0928 \u09AC\u09BE\u0982\u09B2\u09BE \u09AD\u09BE\u09B0\u09A4 \u09AD\u09BE\u09F0\u09A4 \u0A2D\u0A3E\u0A30\u0A24 \u0AAD\u0ABE\u0AB0\u0AA4 \u0B2D\u0B3E\u0B30\u0B24 \u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE \u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8 \u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD \u0C2D\u0C3E\u0C30\u0C24\u0C4D \u0CAD\u0CBE\u0CB0\u0CA4 \u0D2D\u0D3E\u0D30\u0D24\u0D02 \u0DBD\u0D82\u0D9A\u0DCF \u0E04\u0E2D\u0E21 \u0E44\u0E17\u0E22 \u0EA5\u0EB2\u0EA7 \uB2F7\uB137 \uB2F7\uCEF4 \uC0BC\uC131 \uD55C\uAD6D \u30A2\u30DE\u30BE\u30F3 \u30B0\u30FC\u30B0\u30EB \u30AF\u30E9\u30A6\u30C9 \u30B3\u30E0 \u30B9\u30C8\u30A2 \u30BB\u30FC\u30EB \u30D5\u30A1\u30C3\u30B7\u30E7\u30F3 \u30DD\u30A4\u30F3\u30C8 \u307F\u3093\u306A \u4E16\u754C \u4E2D\u4FE1 \u4E2D\u56FD \u4E2D\u570B \u4E2D\u6587\u7F51 \u4E9A\u9A6C\u900A \u4F01\u4E1A \u4F5B\u5C71 \u4FE1\u606F \u5065\u5EB7 \u516B\u5366 \u516C\u53F8 \u516C\u76CA \u53F0\u6E7E \u53F0\u7063 \u5546\u57CE \u5546\u5E97 \u5546\u6807 \u5609\u91CC \u5609\u91CC\u5927\u9152\u5E97 \u5728\u7EBF \u5927\u4F17\u6C7D\u8F66 \u5927\u62FF \u5929\u4E3B\u6559 \u5A31\u4E50 \u5BB6\u96FB \u5E7F\u4E1C \u5FAE\u535A \u6148\u5584 \u6211\u7231\u4F60 \u624B\u673A \u62DB\u8058 \u653F\u52A1 \u653F\u5E9C \u65B0\u52A0\u5761 \u65B0\u95FB \u65F6\u5C1A \u66F8\u7C4D \u673A\u6784 \u6DE1\u9A6C\u9521 \u6E38\u620F \u6FB3\u9580 \u70B9\u770B \u79FB\u52A8 \u7EC4\u7EC7\u673A\u6784 \u7F51\u5740 \u7F51\u5E97 \u7F51\u7AD9 \u7F51\u7EDC \u8054\u901A \u8BFA\u57FA\u4E9A \u8C37\u6B4C \u8D2D\u7269 \u901A\u8CA9 \u96C6\u56E2 \u96FB\u8A0A\u76C8\u79D1 \u98DE\u5229\u6D66 \u98DF\u54C1 \u9910\u5385 \u9999\u683C\u91CC\u62C9 \u9999\u6E2F".split(" ");
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION = /\uFE0F/;
var DIGIT = /\d/;
var SPACE = /\s/;
function init$2() {
  var customProtocols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var S_START = makeState();
  var S_NUM = makeAcceptingState(NUM);
  var S_DOMAIN = makeAcceptingState(DOMAIN);
  var S_DOMAIN_HYPHEN = makeState();
  var S_WS = makeAcceptingState(WS);
  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]];
  var makeDomainState = function makeDomainState2() {
    var state = makeAcceptingState(DOMAIN);
    state.j = {
      "-": S_DOMAIN_HYPHEN
    };
    state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
    return state;
  };
  var makeNearDomainState = function makeNearDomainState2(token2) {
    var state = makeDomainState();
    state.t = token2;
    return state;
  };
  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ["{", makeAcceptingState(OPENBRACE)], ["[", makeAcceptingState(OPENBRACKET)], ["<", makeAcceptingState(OPENANGLEBRACKET)], ["(", makeAcceptingState(OPENPAREN)], ["}", makeAcceptingState(CLOSEBRACE)], ["]", makeAcceptingState(CLOSEBRACKET)], [">", makeAcceptingState(CLOSEANGLEBRACKET)], [")", makeAcceptingState(CLOSEPAREN)], ["&", makeAcceptingState(AMPERSAND)], ["*", makeAcceptingState(ASTERISK)], ["@", makeAcceptingState(AT)], ["`", makeAcceptingState(BACKTICK)], ["^", makeAcceptingState(CARET)], [":", makeAcceptingState(COLON)], [",", makeAcceptingState(COMMA)], ["$", makeAcceptingState(DOLLAR)], [".", makeAcceptingState(DOT)], ["=", makeAcceptingState(EQUALS)], ["!", makeAcceptingState(EXCLAMATION)], ["-", makeAcceptingState(HYPHEN)], ["%", makeAcceptingState(PERCENT)], ["|", makeAcceptingState(PIPE)], ["+", makeAcceptingState(PLUS)], ["#", makeAcceptingState(POUND)], ["?", makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ["/", makeAcceptingState(SLASH)], [";", makeAcceptingState(SEMI)], ["~", makeAcceptingState(TILDE)], ["_", makeAcceptingState(UNDERSCORE)], ["\\", makeAcceptingState(BACKSLASH)]]);
  makeT(S_START, "\n", makeAcceptingState(NL));
  makeRegexT(S_START, SPACE, S_WS);
  makeT(S_WS, "\n", makeState());
  makeRegexT(S_WS, SPACE, S_WS);
  for (var i2 = 0; i2 < tlds.length; i2++) {
    makeChainT(S_START, tlds[i2], makeNearDomainState(TLD), makeDomainState);
  }
  var S_PROTOCOL_FILE = makeDomainState();
  var S_PROTOCOL_FTP = makeDomainState();
  var S_PROTOCOL_HTTP = makeDomainState();
  var S_MAILTO = makeDomainState();
  makeChainT(S_START, "file", S_PROTOCOL_FILE, makeDomainState);
  makeChainT(S_START, "ftp", S_PROTOCOL_FTP, makeDomainState);
  makeChainT(S_START, "http", S_PROTOCOL_HTTP, makeDomainState);
  makeChainT(S_START, "mailto", S_MAILTO, makeDomainState);
  var S_PROTOCOL_SECURE = makeDomainState();
  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL);
  var S_FULL_MAILTO = makeAcceptingState(MAILTO);
  makeT(S_PROTOCOL_FTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_FTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_HTTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_HTTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_FILE, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_SECURE, ":", S_FULL_PROTOCOL);
  makeT(S_MAILTO, ":", S_FULL_MAILTO);
  var S_CUSTOM_PROTOCOL = makeDomainState();
  for (var _i = 0; _i < customProtocols.length; _i++) {
    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
  }
  makeT(S_CUSTOM_PROTOCOL, ":", S_FULL_PROTOCOL);
  makeChainT(S_START, "localhost", makeNearDomainState(LOCALHOST), makeDomainState);
  makeRegexT(S_START, DIGIT, S_NUM);
  makeRegexT(S_START, LETTER, S_DOMAIN);
  makeRegexT(S_START, EMOJI, S_DOMAIN);
  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_NUM, DIGIT, S_NUM);
  makeRegexT(S_NUM, LETTER, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN);
  makeT(S_NUM, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN_HYPHEN, "-", S_DOMAIN_HYPHEN);
  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);
  S_START.jd = makeAcceptingState(SYM);
  return S_START;
}
function run$1(start4, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c2) {
    return c2.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor2 = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start4;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor2 += iterable[charCursor].length;
      charCursor++;
    }
    cursor2 -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      v: str.substr(cursor2 - tokenLength, tokenLength),
      s: cursor2 - tokenLength,
      e: cursor2
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result2 = [];
  var len = str.length;
  var index3 = 0;
  while (index3 < len) {
    var first2 = str.charCodeAt(index3);
    var second = void 0;
    var char2 = first2 < 55296 || first2 > 56319 || index3 + 1 === len || (second = str.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? str[index3] : str.slice(index3, index3 + 2);
    result2.push(char2);
    index3 += char2.length;
  }
  return result2;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
function noop(val) {
  return val;
}
function inherits(parent, child3) {
  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extended = Object.create(parent.prototype);
  for (var p2 in props) {
    extended[p2] = props[p2];
  }
  extended.constructor = child3;
  child3.prototype = extended;
  return child3;
}
function MultiToken() {
}
MultiToken.prototype = {
  t: "token",
  isLink: false,
  toString: function toString7() {
    return this.v;
  },
  toHref: function toHref() {
    return this.toString();
  },
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject: function toObject() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
};
function createTokenClass(type, props) {
  function Token(value, tokens) {
    this.t = type;
    this.v = value;
    this.tk = tokens;
  }
  inherits(MultiToken, Token, props);
  return Token;
}
var MailtoEmail = createTokenClass("email", {
  isLink: true
});
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  toHref: function toHref3() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    var tokens = this.tk;
    var hasProtocol2 = false;
    var hasSlashSlash = false;
    var result2 = [];
    var i2 = 0;
    while (tokens[i2].t === PROTOCOL) {
      hasProtocol2 = true;
      result2.push(tokens[i2].v);
      i2++;
    }
    while (tokens[i2].t === SLASH) {
      hasSlashSlash = true;
      result2.push(tokens[i2].v);
      i2++;
    }
    for (; i2 < tokens.length; i2++) {
      result2.push(tokens[i2].v);
    }
    result2 = result2.join("");
    if (!(hasProtocol2 || hasSlashSlash)) {
      result2 = "".concat(protocol, "://").concat(result2);
    }
    return result2;
  },
  hasProtocol: function hasProtocol() {
    return this.tk[0].t === PROTOCOL;
  }
});
var multi = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  MailtoEmail,
  Email,
  Text,
  Nl,
  Url
});
function init$1() {
  var S_START = makeState();
  var S_PROTOCOL = makeState();
  var S_MAILTO = makeState();
  var S_PROTOCOL_SLASH = makeState();
  var S_PROTOCOL_SLASH_SLASH = makeState();
  var S_DOMAIN = makeState();
  var S_DOMAIN_DOT = makeState();
  var S_TLD = makeAcceptingState(Url);
  var S_TLD_COLON = makeState();
  var S_TLD_PORT = makeAcceptingState(Url);
  var S_URL = makeAcceptingState(Url);
  var S_URL_NON_ACCEPTING = makeState();
  var S_URL_OPENBRACE = makeState();
  var S_URL_OPENBRACKET = makeState();
  var S_URL_OPENANGLEBRACKET = makeState();
  var S_URL_OPENPAREN = makeState();
  var S_URL_OPENBRACE_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENPAREN_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACE_SYMS = makeState();
  var S_URL_OPENBRACKET_SYMS = makeState();
  var S_URL_OPENANGLEBRACKET_SYMS = makeState();
  var S_URL_OPENPAREN_SYMS = makeState();
  var S_EMAIL_DOMAIN = makeState();
  var S_EMAIL_DOMAIN_DOT = makeState();
  var S_EMAIL = makeAcceptingState(Email);
  var S_EMAIL_COLON = makeState();
  var S_EMAIL_PORT = makeAcceptingState(Email);
  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail);
  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
  var S_LOCALPART = makeState();
  var S_LOCALPART_AT = makeState();
  var S_LOCALPART_DOT = makeState();
  var S_NL = makeAcceptingState(Nl);
  makeT(S_START, NL, S_NL);
  makeT(S_START, PROTOCOL, S_PROTOCOL);
  makeT(S_START, MAILTO, S_MAILTO);
  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH);
  makeT(S_START, TLD, S_DOMAIN);
  makeT(S_START, DOMAIN, S_DOMAIN);
  makeT(S_START, LOCALHOST, S_TLD);
  makeT(S_START, NUM, S_DOMAIN);
  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL);
  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_DOMAIN_DOT, TLD, S_TLD);
  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN);
  makeT(S_TLD, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_TLD, COLON, S_TLD_COLON);
  makeT(S_TLD, SLASH, S_URL);
  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
  makeT(S_TLD_PORT, SLASH, S_URL);
  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT);
  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL);
  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL, qsAccepting, S_URL);
  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
  makeT(S_TLD, AT, S_LOCALPART_AT);
  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART);
  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART, AT, S_LOCALPART_AT);
  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL);
  return S_START;
}
function run(start4, input, tokens) {
  var len = tokens.length;
  var cursor2 = 0;
  var multis = [];
  var textTokens = [];
  while (cursor2 < len) {
    var state = start4;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor2 < len && !(secondState = takeT(state, tokens[cursor2].t))) {
      textTokens.push(tokens[cursor2++]);
    }
    while (cursor2 < len && (nextState = secondState || takeT(state, tokens[cursor2].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor2++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      for (var i2 = cursor2 - multiLength; i2 < cursor2; i2++) {
        textTokens.push(tokens[i2]);
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(parserCreateMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor2 -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor2 - multiLength, cursor2);
      multis.push(parserCreateMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(parserCreateMultiToken(Text, input, textTokens));
  }
  return multis;
}
function parserCreateMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.substr(startIdx, endIdx - startIdx);
  return new Multi(value, tokens);
}
var INIT = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: false
};
function init5() {
  INIT.scanner = {
    start: init$2(INIT.customProtocols),
    tokens: text2
  };
  INIT.parser = {
    start: init$1(),
    tokens: multi
  };
  var utils = {
    createTokenClass
  };
  for (var i2 = 0; i2 < INIT.pluginQueue.length; i2++) {
    INIT.pluginQueue[i2][1]({
      scanner: INIT.scanner,
      parser: INIT.parser,
      utils
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init5();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find2(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  var filtered = [];
  for (var i2 = 0; i2 < tokens.length; i2++) {
    var token2 = tokens[i2];
    if (token2.isLink && (!type || token2.t === type)) {
      filtered.push(token2.toObject());
    }
  }
  return filtered;
}
function test(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr } = newState;
      const transform = combineTransactionSteps(oldState.doc, transactions);
      const { mapping } = transform;
      const changes = getChangedRanges(transform);
      changes.forEach(({ oldRange, newRange }) => {
        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter((item) => item.mark.type === options.type).forEach((oldMark) => {
          const newFrom = mapping.map(oldMark.from);
          const newTo = mapping.map(oldMark.to);
          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter((item) => item.mark.type === options.type);
          if (!newMarks.length) {
            return;
          }
          const newMark = newMarks[0];
          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, void 0, " ");
          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, void 0, " ");
          const wasLink = test(oldLinkText);
          const isLink = test(newLinkText);
          if (wasLink && !isLink) {
            tr.removeMark(newMark.from, newMark.to, options.type);
          }
        });
        findChildrenInRange(newState.doc, newRange, (node5) => node5.isTextblock).forEach((textBlock) => {
          const text3 = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          find2(text3).filter((link) => link.isLink).map((link) => __spreadProps(__spreadValues({}, link), {
            from: textBlock.pos + link.start + 1,
            to: textBlock.pos + link.end + 1
          })).filter((link) => {
            const fromIsInRange = newRange.from >= link.from && newRange.from <= link.to;
            const toIsInRange = newRange.to >= link.from && newRange.to <= link.to;
            return fromIsInRange || toIsInRange;
          }).forEach((link) => {
            tr.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        });
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a;
        const attrs = getAttributes(view.state, options.type.name);
        const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest("a");
        if (link && attrs.href) {
          window.open(attrs.href, attrs.target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice5) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent2 = "";
        slice5.content.forEach((node5) => {
          textContent2 += node5.textContent;
        });
        const link = find2(textContent2).find((item) => item.isLink && item.value === textContent2);
        if (!textContent2 || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
const Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow"
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      }
    };
  },
  parseHTML() {
    return [
      { tag: "a[href]" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "a",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text3) => find2(text3).filter((link) => link.isLink).map((link) => ({
          text: link.value,
          index: link.start,
          data: link
        })),
        type: this.type,
        getAttributes: (match2) => {
          var _a;
          return {
            href: (_a = match2.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});
const Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const inputRegex$3 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/;
const pasteRegex = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
const Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands }) => {
        return commands.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands }) => {
        return commands.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
const TiptapToolbarButton = /* @__PURE__ */ createStyled(UnstyledButton, {
  target: "e1dfshbd0"
})("height:40px;width:28px;flex:none;cursor:pointer;display:flex;align-items:center;justify-content:center;&:hover{color:#FFF;}", (props) => ({
  color: props.active ? "#FFF" : "#CCC",
  background: props.active ? "rgba(255, 255, 255, .1)" : void 0
}), "");
function IconBold({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
      fill: "currentColor"
    })
  });
}
function IconItalic({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
      fill: "currentColor"
    })
  });
}
function IconUnderline({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
      fill: "currentColor"
    })
  });
}
function IconMark({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M15.243 4.515l-6.738 6.737-.707 2.121-1.04 1.041 2.828 2.829 1.04-1.041 2.122-.707 6.737-6.738-4.242-4.242zm6.364 3.535a1 1 0 0 1 0 1.414l-7.779 7.779-2.12.707-1.415 1.414a1 1 0 0 1-1.414 0l-4.243-4.243a1 1 0 0 1 0-1.414l1.414-1.414.707-2.121 7.779-7.779a1 1 0 0 1 1.414 0l5.657 5.657zm-6.364-.707l1.414 1.414-4.95 4.95-1.414-1.414 4.95-4.95zM4.283 16.89l2.828 2.829-1.414 1.414-4.243-1.414 2.828-2.829z",
      fill: "currentColor"
    })
  });
}
function IconLink({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M17.657 14.828l-1.414-1.414L17.657 12A4 4 0 1 0 12 6.343l-1.414 1.414-1.414-1.414 1.414-1.414a6 6 0 0 1 8.485 8.485l-1.414 1.414zm-2.829 2.829l-1.414 1.414a6 6 0 1 1-8.485-8.485l1.414-1.414 1.414 1.414L6.343 12A4 4 0 1 0 12 17.657l1.414-1.414 1.414 1.414zm0-9.9l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
      fill: "currentColor"
    })
  });
}
function IconClear({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M12.651 14.065L11.605 20H9.574l1.35-7.661-7.41-7.41L4.93 3.515 20.485 19.07l-1.414 1.414-6.42-6.42zm-.878-6.535l.27-1.53h-1.8l-2-2H20v2h-5.927L13.5 9.257 11.773 7.53z",
      fill: "currentColor"
    })
  });
}
function IconList({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    })
  });
}
function IconQuote({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M4.583 17.321C3.553 16.227 3 15 3 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179zm10 0C13.553 16.227 13 15 13 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179z",
      fill: "currentColor"
    })
  });
}
function IconOrderedList({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    })
  });
}
function IconHeading({
  size = 24,
  level
}) {
  let path = "";
  if (level === void 0) {
    path = "M17 11V4h2v17h-2v-8H7v8H5V4h2v7z";
  } else if (level === 1) {
    path = "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z";
  } else if (level === 2) {
    path = "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z";
  } else if (level === 3) {
    path = "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z";
  } else if (level === 4) {
    path = "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z";
  } else if (level === 5) {
    path = "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z";
  } else if (level === 6) {
    path = "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z";
  }
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: path,
      fill: "currentColor"
    })
  });
}
function IconAlign({
  size = 24,
  direction = "left"
}) {
  if (direction === "left") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
        fill: "currentColor"
      })
    });
  } else if (direction === "right") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
        fill: "currentColor"
      })
    });
  } else if (direction === "center") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
        fill: "currentColor"
      })
    });
  }
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M3 4h18v2H3V4zm0 15h18v2H3v-2zm0-5h18v2H3v-2zm0-5h18v2H3V9z",
      fill: "currentColor"
    })
  });
}
const baseHeight = 40;
const TiptapDropdown = createStyled("div", {
  target: "e1mfbf6f0"
})({
  position: "relative",
  display: "flex",
  flexDirection: "column",
  background: "#444",
  height: baseHeight,
  flex: "none",
  overflow: "hidden",
  alignItems: "center",
  transition: "height .2s, transform .3s",
  transformOrigin: "50% 0",
  borderRadius: 3,
  "& > *": {
    height: baseHeight - 10
  },
  "& > *:first-of-type": {
    marginTop: 0,
    transition: "margin .3s",
    height: baseHeight
  },
  "&:hover > *:first-of-type": {
    marginTop: -3
  },
  "&:hover": {
    transform: "scale(1.2)"
  }
}, (props) => ({
  "&:hover": {
    height: baseHeight * props.size - 10 * (props.size - 1)
  }
}), "");
var _ref$3 = {
  name: "zdz8xi",
  styles: "height:30px"
};
const TiptapToolbarAlign = ({
  editor
}) => {
  const alignments = ["left", "center", "right", "justify"];
  const currentAlign = alignments.filter((align) => editor.isActive({
    textAlign: align
  }))[0];
  if (!editor.can().setParagraph()) {
    return null;
  }
  return /* @__PURE__ */ jsxs(TiptapDropdown, {
    size: alignments.length,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      title: capitalize(currentAlign),
      type: "button",
      children: /* @__PURE__ */ jsx(IconAlign, {
        size: 16,
        direction: currentAlign
      })
    }), alignments.filter((align) => align !== currentAlign).map((align) => /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().setTextAlign(align).run()),
      css: _ref$3,
      title: capitalize(align),
      children: /* @__PURE__ */ jsx(IconAlign, {
        size: 16,
        direction: align
      })
    }, align))]
  });
};
var _ref$2 = {
  name: "zdz8xi",
  styles: "height:30px"
};
const TiptapToolbarHeadings = ({
  editor
}) => {
  const levels = [2, 3, 4, 5, 6];
  const currentLevel = editor.getAttributes("heading").level;
  if (!("toggleHeading" in editor.can()) || !editor.can().toggleHeading({
    level: 2
  })) {
    return null;
  }
  const clickHandler2 = (level) => prevent(() => {
    if (!level) {
      return;
    }
    editor.chain().focus().toggleHeading({
      level
    }).run();
  });
  return /* @__PURE__ */ jsxs(TiptapDropdown, {
    size: levels.length + 1,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      active: !!currentLevel,
      onClick: clickHandler2(currentLevel),
      children: /* @__PURE__ */ jsx(IconHeading, {
        size: 16,
        level: currentLevel
      })
    }), levels.map((level) => /* @__PURE__ */ jsx(TiptapToolbarButton, {
      active: level === currentLevel,
      onClick: clickHandler2(level),
      css: _ref$2,
      children: /* @__PURE__ */ jsx(IconHeading, {
        size: 16,
        level
      })
    }, level))]
  });
};
function colorToProperty(color) {
  if (typeof color !== "string") {
    return void 0;
  }
  if (color.startsWith("--")) {
    return `var(${color})`;
  }
  return color;
}
var _ref$1 = {
  name: "bjn8wh",
  styles: "position:relative"
};
function TiptapColorPicker({
  editor,
  colors
}) {
  const currentColor = editor == null ? void 0 : editor.getAttributes("textStyle").color;
  const cssColors = react.exports.useMemo(() => colors.map(colorToProperty), [colors]);
  const [expanded, toggleExpanded, setExpanded] = useToggle();
  const handleChange = (color) => {
    toggleExpanded();
    editor.chain().focus().setColor(color).run();
  };
  react.exports.useEffect(() => {
    if (editor.isFocused) {
      setExpanded(false);
    }
  }, [editor.isFocused]);
  if (colors.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxs("div", {
    css: _ref$1,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(toggleExpanded),
      children: /* @__PURE__ */ jsxs("svg", {
        width: 16,
        height: 16,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [/* @__PURE__ */ jsx("path", {
          d: "M15.246 14H8.754L7.154 18H5L11 3H13L19 18H16.846L15.246 14ZM14.446 12L12 5.885L9.554 12H14.446Z",
          fill: "currentColor"
        }), /* @__PURE__ */ jsx("path", {
          d: "M3 20H21V22H3V20Z",
          fill: currentColor || "currentColor"
        })]
      })
    }), expanded && /* @__PURE__ */ jsx(Palette$1, {
      colors: cssColors,
      onChange: handleChange
    })]
  });
}
const PaletteWrapper = createStyled("div", {
  target: "e18i49zb1"
})("position:absolute;top:100%;right:0;background:#444;display:grid;grid-gap:3px;padding:4px;", (props) => ({
  gridTemplateColumns: `repeat(${Math.ceil(props.size / 3)}, 16px)`
}), "");
const PaletteItem$1 = createStyled("button", {
  target: "e18i49zb0"
})({
  name: "1j36tbg",
  styles: "width:16px;height:16px;border:1px solid transparent;cursor:pointer;&:hover{border-color:white;transform:scale(1.5);}"
});
function Palette$1({
  colors,
  onChange
}) {
  const changeHandler = (color) => prevent(() => onChange(color));
  return /* @__PURE__ */ jsx(PaletteWrapper, {
    size: colors.length,
    children: colors.map((color) => /* @__PURE__ */ jsx(PaletteItem$1, {
      onClick: changeHandler(color),
      style: {
        backgroundColor: color
      }
    }, color))
  });
}
const iconSize = 16;
function TiptapToolbar({
  editor,
  colors
}) {
  const [mode, setMode] = react.exports.useState(0);
  const setLinkMode = () => setMode(1);
  const setButtonsMode = () => setMode(0);
  const insertLink = (link) => {
    editor.commands.setLink({
      href: link
    });
  };
  let rootElement = null;
  try {
    rootElement = useRootElement();
  } catch (e2) {
  }
  react.exports.useEffect(() => {
    if (editor.isFocused) {
      setMode(0);
    }
  }, [editor.isFocused]);
  return /* @__PURE__ */ jsx(Toolbar, {
    className: "WysiwygToolbar",
    editor,
    shouldShow: ({
      from: from5,
      to
    }) => from5 !== to,
    tippyOptions: __spreadValues({
      maxWidth: 500
    }, rootElement ? {
      appendTo: () => rootElement
    } : {}),
    children: mode === 1 ? /* @__PURE__ */ jsx(ToolbarLink, {
      onSubmit: insertLink,
      onCancel: setButtonsMode
    }) : /* @__PURE__ */ jsx(ToolbarButtons, {
      editor,
      onLinkClick: setLinkMode,
      colors
    })
  });
}
function ToolbarLink({
  onSubmit,
  onCancel
}) {
  const handleKeyDown = (e2) => {
    if (e2.key === "Escape") {
      onCancel();
    }
  };
  const handleSubmit = (e2) => {
    const data = new FormData(e2.target);
    const link = data.get("link");
    if (link) {
      onSubmit(link.toString());
    } else {
      onCancel(link);
    }
  };
  return /* @__PURE__ */ jsxs(Flex, {
    as: "form",
    onKeyDown: handleKeyDown,
    onSubmit: prevent(handleSubmit),
    children: [/* @__PURE__ */ jsx(LinkInput, {
      name: "link",
      type: "text",
      placeholder: "https://...",
      autoFocus: true
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      children: "Ok"
    })]
  });
}
function ToolbarButtons({
  editor,
  onLinkClick,
  colors
}) {
  const clearFormat = () => editor.chain().focus().clearNodes().unsetAllMarks().run();
  const toggleLink = () => {
    if (editor.isActive("link")) {
      editor.chain().focus().unsetLink().run();
    } else {
      onLinkClick();
    }
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [editor.can().toggleOrderedList() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleOrderedList().run()),
      active: editor.isActive("orderedList"),
      title: "Ordered List",
      children: /* @__PURE__ */ jsx(IconOrderedList, {
        size: iconSize
      })
    }), editor.can().toggleBulletList() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBulletList().run()),
      active: editor.isActive("bulletList"),
      title: "Unordered List",
      children: /* @__PURE__ */ jsx(IconList, {
        size: iconSize
      })
    }), editor.can().toggleBlockquote() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBlockquote().run()),
      active: editor.isActive("blockquote"),
      title: "Blockquote",
      children: /* @__PURE__ */ jsx(IconQuote, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarHeadings, {
      editor
    }), editor.can().toggleBulletList() && /* @__PURE__ */ jsx(Separator, {}), /* @__PURE__ */ jsx(TiptapToolbarAlign, {
      editor
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBold().run()),
      active: editor.isActive("bold"),
      title: "Bold",
      children: /* @__PURE__ */ jsx(IconBold, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleItalic().run()),
      active: editor.isActive("italic"),
      title: "Italic",
      children: /* @__PURE__ */ jsx(IconItalic, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleUnderline().run()),
      active: editor.isActive("underline"),
      title: "Underline",
      children: /* @__PURE__ */ jsx(IconUnderline, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleHighlight().run()),
      active: editor.isActive("highlight"),
      title: "Mark",
      children: /* @__PURE__ */ jsx(IconMark, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapColorPicker, {
      editor,
      colors
    }), /* @__PURE__ */ jsx(Separator, {}), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(toggleLink),
      active: editor.isActive("link"),
      title: "Link",
      children: /* @__PURE__ */ jsx(IconLink, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(clearFormat),
      title: "Clear",
      children: /* @__PURE__ */ jsx(IconClear, {
        size: iconSize
      })
    })]
  });
}
const Toolbar = /* @__PURE__ */ createStyled(BubbleMenu, {
  target: "eopxw882"
})({
  name: "1i1xml5",
  styles: "border-radius:25px;background-color:#444;color:#FFF;height:40px;display:flex;padding:0 1em"
});
const Separator = createStyled("div", {
  target: "eopxw881"
})({
  name: "kfg3zs",
  styles: "width:.5em;flex:none"
});
const LinkInput = createStyled("input", {
  target: "eopxw880"
})({
  name: "o4a0dh",
  styles: "border:none;height:30px;color:inherit;font:inherit;background:transparent;outline:none"
});
const Paragraph = Node2.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const inputRegex$2 = /^(\d+)\.\s$/;
const OrderedList = Node2.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const _a = HTMLAttributes, { start: start4 } = _a, attributesWithoutStart = __objRest(_a, ["start"]);
    return start4 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$2,
        type: this.type,
        getAttributes: (match2) => ({ start: +match2[1] }),
        joinPredicate: (match2, node5) => node5.childCount + node5.attrs.start === +match2[1]
      })
    ];
  }
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node2.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$1,
        type: this.type
      })
    ];
  }
});
const ListItem = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const Document = Node2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
const Heading = Node2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node: node5, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node5.attrs.level);
    const level = hasLevel ? node5.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => __spreadValues(__spreadValues({}, items), {
      [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
const TextAlign$1 = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands }) => {
        return this.options.types.every((type) => commands.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands.unsetMark(this.name);
      }
    };
  }
});
const Color$1 = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => element.style.color.replace(/['"]+/g, ""),
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const HardBreak = Node2.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands, chain, state, editor }) => {
        return commands.first([
          () => commands.exitCode(),
          () => commands.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks2 = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
              if (dispatch2 && marks2 && keepMarks) {
                const filteredMarks = marks2.filter((mark3) => splittableMarks.includes(mark3.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append3(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice4(from5, to) {
  if (from5 === void 0)
    from5 = 0;
  if (to === void 0)
    to = this.length;
  if (from5 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from5), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return void 0;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach5(f2, from5, to) {
  if (from5 === void 0)
    from5 = 0;
  if (to === void 0)
    to = this.length;
  if (from5 <= to) {
    this.forEachInner(f2, from5, to, 0);
  } else {
    this.forEachInvertedInner(f2, from5, to, 0);
  }
};
RopeSequence.prototype.map = function map13(f2, from5, to) {
  if (from5 === void 0)
    from5 = 0;
  if (to === void 0)
    to = this.length;
  var result2 = [];
  this.forEach(function(elt, i2) {
    return result2.push(f2(elt, i2));
  }, from5, to);
  return result2;
};
RopeSequence.from = function from4(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from5, to) {
    if (from5 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from5, to));
  };
  Leaf2.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f2, from5, to, start4) {
    for (var i2 = from5; i2 < to; i2++) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from5, to, start4) {
    for (var i2 = from5 - 1; i2 >= to; i2--) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f2, from5, to, start4) {
    var leftLen = this.left.length;
    if (from5 < leftLen && this.left.forEachInner(f2, from5, Math.min(to, leftLen), start4) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f2, Math.max(from5 - leftLen, 0), Math.min(this.length, to) - leftLen, start4 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from5, to, start4) {
    var leftLen = this.left.length;
    if (from5 > leftLen && this.right.forEachInvertedInner(f2, from5 - leftLen, Math.max(to, leftLen) - leftLen, start4 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f2, Math.min(from5, leftLen), to, start4) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from5, to) {
    if (from5 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from5, to);
    }
    if (from5 >= leftLen) {
      return this.right.slice(from5 - leftLen, to - leftLen);
    }
    return this.left.slice(from5, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end3 = this.items.length;
  for (; ; end3--) {
    var next2 = this.items.get(end3 - 1);
    if (next2.selection) {
      --end3;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end3, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item, i2) {
    if (!item.step) {
      if (!remap) {
        remap = this$1$1.remapping(end3, i2 + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item.map));
      var step2 = item.step.map(remap.slice(mapFrom)), map14;
      if (step2 && transform.maybeStep(step2).doc) {
        map14 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map14, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map14) {
        remap.appendMap(map14, mapFrom);
      }
    } else {
      transform.maybeStep(item.step);
    }
    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1$1.items.slice(0, end3).append(addBefore.reverse().concat(addAfter)), this$1$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i2 = 0; i2 < transform.steps.length; i2++) {
    var step2 = transform.steps[i2].invert(transform.docs[i2]);
    var item = new Item(transform.mapping.maps[i2], step2, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i2) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from5, to) {
  var maps = new Mapping();
  this.items.forEach(function(item, i2) {
    var mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from5 ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from5, to);
  return maps;
};
Branch.prototype.addMaps = function addMaps(array) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array.map(function(map14) {
    return new Item(map14);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start4 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item) {
    if (item.selection) {
      eventCount--;
    }
  }, start4);
  var iRebased = rebasedCount;
  this.items.forEach(function(item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map14 = mapping.maps[pos];
    if (item.step) {
      var step2 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map14, step2, selection));
    } else {
      rebasedItems.push(new Item(map14));
    }
  }, start4);
  var newMaps = [];
  for (var i2 = rebasedCount; i2 < newUntil; i2++) {
    newMaps.push(new Item(mapping.maps[i2]));
  }
  var items = this.items.slice(0, start4).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item) {
    if (!item.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0)
    upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events2 = 0;
  this.items.forEach(function(item, i2) {
    if (i2 >= upto) {
      items.push(item);
      if (item.selection) {
        events2++;
      }
    } else if (item.step) {
      var step2 = item.step.map(remap.slice(mapFrom)), map14 = step2 && step2.getMap();
      mapFrom--;
      if (map14) {
        remap.appendMap(map14, mapFrom);
      }
      if (step2) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) {
          events2++;
        }
        var newItem = new Item(map14.invert(), step2, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem)) {
          items[last] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(ropeSequence.from(items.reverse()), events2);
};
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n2) {
  var cutPoint;
  items.forEach(function(item, i2) {
    if (item.selection && n2-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map14, step2, selection, mirrorOffset) {
  this.map = map14;
  this.step = step2;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge3(other) {
  if (this.step && other.step && !other.selection) {
    var step2 = other.step.merge(this.step);
    if (step2) {
      return new Item(step2.getMap().invert(), step2, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done2, undone, prevRanges, prevTime) {
  this.done = done2;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction2(history2, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased2;
  if (historyTr) {
    return historyTr.historyState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) {
      return new HistoryState(history2.done.addTransform(tr, null, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    } else {
      return new HistoryState(history2.done, history2.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history2.prevTime);
    }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased2), history2.undone.rebased(tr, rebased2), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) {
    return false;
  }
  if (!transform.docChanged) {
    return true;
  }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start4, end3) {
    for (var i2 = 0; i2 < prevRanges.length; i2 += 2) {
      if (start4 <= prevRanges[i2 + 1] && end3 >= prevRanges[i2]) {
        adjacent = true;
      }
    }
  });
  return adjacent;
}
function rangesFor(map14) {
  var result2 = [];
  map14.forEach(function(_from, _to, from5, to) {
    return result2.push(from5, to);
  });
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges) {
    return null;
  }
  var result2 = [];
  for (var i2 = 0; i2 < ranges.length; i2 += 2) {
    var from5 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from5 <= to) {
      result2.push(from5, to);
    }
  }
  return result2;
}
function histTransaction(history2, state, dispatch2, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop) {
    return;
  }
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i2 = 0; i2 < plugins.length; i2++) {
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config) {
  config = {
    depth: config && config.depth || 100,
    newGroupDelay: config && config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init: function init6() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply8(tr, hist, state) {
        return applyTransaction2(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e2) {
          var handled = e2.inputType == "historyUndo" ? undo(view.state, view.dispatch) : e2.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
          if (handled) {
            e2.preventDefault();
          }
          return handled;
        }
      }
    }
  });
}
function undo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, false);
  }
  return true;
}
function redo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, true);
  }
  return true;
}
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});
const inputRegex = /^\s*>\s$/;
const Blockquote = Node2.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  }
});
const SingleDocument = Node2.create({
  name: "doc",
  topNode: true,
  group: "block",
  content: "inline*"
});
function TiptapEditor({
  value,
  onChange,
  multiline = false,
  colors = [],
  defaultAlign = "left",
  backgroundColor,
  color
}) {
  const [isFocused, setFocus] = react.exports.useState(false);
  const onChangeRef = react.exports.useRef(onChange);
  onChangeRef.current = onChange;
  const editor = useEditor({
    extensions: [...multiline ? [Document] : [SingleDocument], Paragraph, OrderedList, BulletList, ListItem, Text$1, Bold, Italic, Highlight, Underline, TextStyle, Color$1, HardBreak, History, Blockquote, Link.configure({
      openOnClick: false
    }), Heading.configure({
      levels: [2, 3, 4, 5, 6]
    }), TextAlign$1.configure({
      types: ["heading", "bulletList", "listItem", "orderedList", "blockquote", "paragraph"],
      defaultAlignment: defaultAlign
    })],
    onUpdate: ({
      editor: editor2
    }) => onChangeRef.current(cleanHTML(editor2.getHTML(), multiline)),
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    content: value
  });
  react.exports.useEffect(() => {
    if (editor) {
      editor.extensionManager.extensions.find((e2) => e2.name === "textAlign").options.defaultAlignment = defaultAlign;
      editor.commands.setContent(value);
    }
  }, [defaultAlign]);
  return /* @__PURE__ */ jsxs(EditorWrapper, {
    focused: isFocused,
    style: {
      textAlign: defaultAlign,
      color,
      backgroundColor
    },
    children: [/* @__PURE__ */ jsx(EditorContent, {
      editor
    }), editor && /* @__PURE__ */ jsx(TiptapToolbar, {
      editor,
      colors
    })]
  });
}
const cleanHTML = (str, multiline) => {
  let content2 = str.replaceAll(/(<[uo]l[^>]*>)(.*?)(<\/[uo]l>)/gi, (_2, openingTag, inner, closingTag) => `${openingTag}${removeParagraphs(inner)}${closingTag}`);
  if (!multiline) {
    content2 = removeParagraphs(content2);
  }
  return content2.trim();
};
function removeParagraphs(str) {
  return str.replaceAll(/<\/p><p[^>]*>/gi, "<br>").replaceAll(/<p[^>]*>/gi, "").replaceAll(/<\/p>/gi, "");
}
const EditorWrapper = createStyled("div", {
  target: "eso0m9e0"
})("color:var(--ve-color);background:transparent;padding:.5rem .75em;line-height:1.25rem;border-radius:.2rem;display:block;width:100%;border:solid 1px var(--ve-field-border);box-shadow:var(--ve-field-shadow);outline:none;p, ul, ol, h2, h3, h4, h5, h1{margin:0 0 1em 0;}li p{margin:0;}.ProseMirror{outline:none;}.ProseMirror > *:last-child{margin:0;}", (props) => __spreadProps(__spreadValues({}, props.focused ? Styles.FocusState : void 0), {
  p: {
    marginBottom: props.singleLine ? "0" : "1em"
  }
}), "");
const Component$8 = ({
  value,
  onChange,
  options,
  backgroundColor,
  textColor,
  defaultAlign
}) => {
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    help: options.help,
    children: /* @__PURE__ */ jsx(TiptapEditor, {
      value,
      onChange,
      backgroundColor,
      color: textColor,
      colors: options.colors,
      multiline: options.multiline,
      defaultAlign
    })
  });
};
const HTMLText = (name, options = {}) => {
  return __spreadValues({
    name,
    options: __spreadValues({
      multiline: true,
      allowHeadings: false,
      default: ""
    }, options),
    extraProps: (data) => ({
      backgroundColor: colorToProperty(options.backgroundColor && data[options.backgroundColor]),
      textColor: colorToProperty(options.textColor && data[options.textColor]),
      defaultAlign: options.defaultAlign ? data[options.defaultAlign] : void 0
    }),
    render: Component$8
  }, defaultFieldProperties());
};
const Arrow$3 = /* @__PURE__ */ react.exports.forwardRef((o2, i2) => {
  const _a = o2, { children: n2, width: s2 = 10, height: m2 = 5 } = _a, p2 = __objRest(_a, ["children", "width", "height"]);
  return react.exports.createElement(Primitive.svg, _extends({}, p2, { ref: i2, width: s2, height: m2, viewBox: "0 0 30 10", preserveAspectRatio: "none" }), o2.asChild ? n2 : /* @__PURE__ */ react.exports.createElement("polygon", { points: "0,0 30,0 15,10" }));
});
const Root$4 = Arrow$3;
function useSize(r2) {
  const [i2, t2] = react.exports.useState(void 0);
  return react.exports.useEffect(() => {
    if (r2) {
      const e2 = new ResizeObserver((e3) => {
        if (!Array.isArray(e3))
          return;
        if (!e3.length)
          return;
        const i3 = e3[0];
        let o2, n2;
        if ("borderBoxSize" in i3) {
          const e4 = i3.borderBoxSize, r3 = Array.isArray(e4) ? e4[0] : e4;
          o2 = r3.inlineSize, n2 = r3.blockSize;
        } else {
          const e4 = r2.getBoundingClientRect();
          o2 = e4.width, n2 = e4.height;
        }
        t2({ width: o2, height: n2 });
      });
      return e2.observe(r2, { box: "border-box" }), () => e2.unobserve(r2);
    }
    t2(void 0);
  }, [r2]), i2;
}
function observeElementRect(n2, o2) {
  const i2 = e$1.get(n2);
  return i2 === void 0 ? (e$1.set(n2, { rect: {}, callbacks: [o2] }), e$1.size === 1 && (t$1 = requestAnimationFrame(c$1))) : (i2.callbacks.push(o2), o2(n2.getBoundingClientRect())), () => {
    const c2 = e$1.get(n2);
    if (c2 === void 0)
      return;
    const i3 = c2.callbacks.indexOf(o2);
    i3 > -1 && c2.callbacks.splice(i3, 1), c2.callbacks.length === 0 && (e$1.delete(n2), e$1.size === 0 && cancelAnimationFrame(t$1));
  };
}
let t$1;
const e$1 = /* @__PURE__ */ new Map();
function c$1() {
  const n2 = [];
  e$1.forEach((t2, e2) => {
    const c2 = e2.getBoundingClientRect();
    var o2, i2;
    o2 = t2.rect, i2 = c2, (o2.width !== i2.width || o2.height !== i2.height || o2.top !== i2.top || o2.right !== i2.right || o2.bottom !== i2.bottom || o2.left !== i2.left) && (t2.rect = c2, n2.push(t2));
  }), n2.forEach((t2) => {
    t2.callbacks.forEach((e2) => e2(t2.rect));
  }), t$1 = requestAnimationFrame(c$1);
}
function useRect(e2) {
  const [o2, c2] = react.exports.useState();
  return react.exports.useEffect(() => {
    if (e2) {
      const r2 = observeElementRect(e2, c2);
      return () => {
        c2(void 0), r2();
      };
    }
  }, [e2]), o2;
}
function getPlacementData({ anchorRect: p2, popperSize: c2, arrowSize: f2, arrowOffset: l2 = 0, side: d2, sideOffset: h2 = 0, align: x2, alignOffset: g2 = 0, shouldAvoidCollisions: u2 = true, collisionBoundariesRect: w2, collisionTolerance: m2 = 0 }) {
  if (!p2 || !c2 || !w2)
    return { popperStyles: o, arrowStyles: n };
  const y2 = function(e2, r2, o2 = 0, n2 = 0, i2) {
    const p3 = i2 ? i2.height : 0, a2 = t(r2, e2, "x"), s2 = t(r2, e2, "y"), c3 = s2.before - o2 - p3, f3 = s2.after + o2 + p3, l3 = a2.before - o2 - p3, d3 = a2.after + o2 + p3;
    return { top: { start: { x: a2.start + n2, y: c3 }, center: { x: a2.center, y: c3 }, end: { x: a2.end - n2, y: c3 } }, right: { start: { x: d3, y: s2.start + n2 }, center: { x: d3, y: s2.center }, end: { x: d3, y: s2.end - n2 } }, bottom: { start: { x: a2.start + n2, y: f3 }, center: { x: a2.center, y: f3 }, end: { x: a2.end - n2, y: f3 } }, left: { start: { x: l3, y: s2.start + n2 }, center: { x: l3, y: s2.center }, end: { x: l3, y: s2.end - n2 } } };
  }(c2, p2, h2, g2, f2), b2 = y2[d2][x2];
  if (u2 === false) {
    const t2 = e(b2);
    let o2 = n;
    f2 && (o2 = i({ popperSize: c2, arrowSize: f2, arrowOffset: l2, side: d2, align: x2 }));
    return { popperStyles: __spreadProps(__spreadValues({}, t2), { "--radix-popper-transform-origin": r$1(c2, d2, x2, l2, f2) }), arrowStyles: o2, placedSide: d2, placedAlign: x2 };
  }
  const S2 = DOMRect.fromRect(__spreadValues(__spreadValues({}, c2), b2)), $ = (O2 = w2, z2 = m2, DOMRect.fromRect({ width: O2.width - 2 * z2, height: O2.height - 2 * z2, x: O2.left + z2, y: O2.top + z2 }));
  var O2, z2;
  const R2 = s(S2, $), M2 = y2[a(d2)][x2], D2 = function(t2, e2, r2) {
    const o2 = a(t2);
    return e2[t2] && !r2[o2] ? o2 : t2;
  }(d2, R2, s(DOMRect.fromRect(__spreadValues(__spreadValues({}, c2), M2)), $)), A2 = function(t2, e2, r2, o2, n2) {
    const i2 = r2 === "top" || r2 === "bottom", p3 = i2 ? "left" : "top", a2 = i2 ? "right" : "bottom", s2 = i2 ? "width" : "height", c3 = e2[s2] > t2[s2];
    if ((o2 === "start" || o2 === "center") && (n2[p3] && c3 || n2[a2] && !c3))
      return "end";
    if ((o2 === "end" || o2 === "center") && (n2[a2] && c3 || n2[p3] && !c3))
      return "start";
    return o2;
  }(c2, p2, d2, x2, R2), I2 = e(y2[D2][A2]);
  let C2 = n;
  f2 && (C2 = i({ popperSize: c2, arrowSize: f2, arrowOffset: l2, side: D2, align: A2 }));
  return { popperStyles: __spreadProps(__spreadValues({}, I2), { "--radix-popper-transform-origin": r$1(c2, D2, A2, l2, f2) }), arrowStyles: C2, placedSide: D2, placedAlign: A2 };
}
function t(t2, e2, r2) {
  const o2 = t2[r2 === "x" ? "left" : "top"], n2 = r2 === "x" ? "width" : "height", i2 = t2[n2], p2 = e2[n2];
  return { before: o2 - p2, start: o2, center: o2 + (i2 - p2) / 2, end: o2 + i2 - p2, after: o2 + i2 };
}
function e(t2) {
  return { position: "absolute", top: 0, left: 0, minWidth: "max-content", willChange: "transform", transform: `translate3d(${Math.round(t2.x + window.scrollX)}px, ${Math.round(t2.y + window.scrollY)}px, 0)` };
}
function r$1(t2, e2, r2, o2, n2) {
  const i2 = e2 === "top" || e2 === "bottom", p2 = n2 ? n2.width : 0, a2 = n2 ? n2.height : 0, s2 = p2 / 2 + o2;
  let c2 = "", f2 = "";
  return i2 ? (c2 = { start: `${s2}px`, center: "center", end: t2.width - s2 + "px" }[r2], f2 = e2 === "top" ? `${t2.height + a2}px` : -a2 + "px") : (c2 = e2 === "left" ? `${t2.width + a2}px` : -a2 + "px", f2 = { start: `${s2}px`, center: "center", end: t2.height - s2 + "px" }[r2]), `${c2} ${f2}`;
}
const o = { position: "fixed", top: 0, left: 0, opacity: 0, transform: "translate3d(0, -200%, 0)" }, n = { position: "absolute", opacity: 0 };
function i({ popperSize: t2, arrowSize: e2, arrowOffset: r2, side: o2, align: n2 }) {
  const i2 = (t2.width - e2.width) / 2, a2 = (t2.height - e2.width) / 2, s2 = { top: 0, right: 90, bottom: 180, left: -90 }[o2], c2 = Math.max(e2.width, e2.height), f2 = { width: `${c2}px`, height: `${c2}px`, transform: `rotate(${s2}deg)`, willChange: "transform", position: "absolute", [o2]: "100%", direction: p$1(o2, n2) };
  return o2 !== "top" && o2 !== "bottom" || (n2 === "start" && (f2.left = `${r2}px`), n2 === "center" && (f2.left = `${i2}px`), n2 === "end" && (f2.right = `${r2}px`)), o2 !== "left" && o2 !== "right" || (n2 === "start" && (f2.top = `${r2}px`), n2 === "center" && (f2.top = `${a2}px`), n2 === "end" && (f2.bottom = `${r2}px`)), f2;
}
function p$1(t2, e2) {
  return (t2 !== "top" && t2 !== "right" || e2 !== "end") && (t2 !== "bottom" && t2 !== "left" || e2 === "end") ? "ltr" : "rtl";
}
function a(t2) {
  return { top: "bottom", right: "left", bottom: "top", left: "right" }[t2];
}
function s(t2, e2) {
  return { top: t2.top < e2.top, right: t2.right > e2.right, bottom: t2.bottom > e2.bottom, left: t2.left < e2.left };
}
const [c, l] = createContextScope("Popper");
const [f$1, d] = c("Popper");
const Popper$1 = (e2) => {
  const { __scopePopper: o2, children: r2 } = e2, [t2, n2] = react.exports.useState(null);
  return react.exports.createElement(f$1, { scope: o2, anchor: t2, onAnchorChange: n2 }, r2);
};
const PopperAnchor = /* @__PURE__ */ react.exports.forwardRef((e2, r2) => {
  const _a = e2, { __scopePopper: t2, virtualRef: n2 } = _a, p2 = __objRest(_a, ["__scopePopper", "virtualRef"]), c2 = d("PopperAnchor", t2), l2 = react.exports.useRef(null), f2 = useComposedRefs(r2, l2);
  return react.exports.useEffect(() => {
    c2.onAnchorChange((n2 == null ? void 0 : n2.current) || l2.current);
  }), n2 ? null : /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({}, p2, { ref: f2 }));
});
const [u, m$1] = c("PopperContent");
const PopperContent = /* @__PURE__ */ react.exports.forwardRef((e2, n2) => {
  const _a = e2, { __scopePopper: c2, side: l2 = "bottom", sideOffset: f2, align: m2 = "center", alignOffset: w2, collisionTolerance: h2, avoidCollisions: x2 = true } = _a, v2 = __objRest(_a, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "collisionTolerance", "avoidCollisions"]), P2 = d("PopperContent", c2), [A2, g2] = react.exports.useState(), E2 = useRect(P2.anchor), [y2, C2] = react.exports.useState(null), S2 = useSize(y2), [R2, O2] = react.exports.useState(null), _2 = useSize(R2), b2 = useComposedRefs(n2, (e3) => C2(e3)), z2 = function() {
    const [e3, o2] = react.exports.useState(void 0);
    return react.exports.useEffect(() => {
      let e4;
      function r2() {
        o2({ width: window.innerWidth, height: window.innerHeight });
      }
      function t2() {
        window.clearTimeout(e4), e4 = window.setTimeout(r2, 100);
      }
      return r2(), window.addEventListener("resize", t2), () => window.removeEventListener("resize", t2);
    }, []), e3;
  }(), T2 = z2 ? DOMRect.fromRect(__spreadProps(__spreadValues({}, z2), { x: 0, y: 0 })) : void 0, { popperStyles: k2, arrowStyles: L2, placedSide: B2, placedAlign: D2 } = getPlacementData({ anchorRect: E2, popperSize: S2, arrowSize: _2, arrowOffset: A2, side: l2, sideOffset: f2, align: m2, alignOffset: w2, shouldAvoidCollisions: x2, collisionBoundariesRect: T2, collisionTolerance: h2 }), H2 = B2 !== void 0;
  return react.exports.createElement("div", { style: k2, "data-radix-popper-content-wrapper": "" }, /* @__PURE__ */ react.exports.createElement(u, { scope: c2, arrowStyles: L2, onArrowChange: O2, onArrowOffsetChange: g2 }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends({ "data-side": B2, "data-align": D2 }, v2, { style: __spreadProps(__spreadValues({}, v2.style), { animation: H2 ? void 0 : "none" }), ref: b2 }))));
});
const PopperArrow = /* @__PURE__ */ react.exports.forwardRef(function(o2, r2) {
  const _a = o2, { __scopePopper: t2, offset: n2 } = _a, i2 = __objRest(_a, ["__scopePopper", "offset"]), p2 = m$1("PopperArrow", t2), { onArrowOffsetChange: c2 } = p2;
  return react.exports.useEffect(() => c2(n2), [c2, n2]), /* @__PURE__ */ react.exports.createElement("span", { style: __spreadProps(__spreadValues({}, p2.arrowStyles), { pointerEvents: "none" }) }, /* @__PURE__ */ react.exports.createElement("span", { ref: p2.onArrowChange, style: { display: "inline-block", verticalAlign: "top", pointerEvents: "auto" } }, /* @__PURE__ */ react.exports.createElement(Root$4, _extends({}, i2, { ref: r2, style: __spreadProps(__spreadValues({}, i2.style), { display: "block" }) }))));
});
const Root$3 = Popper$1;
const Anchor = PopperAnchor;
const Content$1 = PopperContent;
const Arrow$2 = PopperArrow;
const [C, g$1] = createContextScope("Popover", [l]);
const x$1 = l(), [h$1, E$1] = C("Popover");
const Popover = (e2) => {
  const { __scopePopover: o2, children: t2, open: n2, defaultOpen: c2, onOpenChange: a2, modal: s2 = false } = e2, i2 = x$1(o2), u2 = react.exports.useRef(null), [d2, m2] = react.exports.useState(false), [f2 = false, P2] = useControllableState({ prop: n2, defaultProp: c2, onChange: a2 });
  return react.exports.createElement(Root$3, i2, /* @__PURE__ */ react.exports.createElement(h$1, { scope: o2, contentId: useId(), triggerRef: u2, open: f2, onOpenChange: P2, onOpenToggle: react.exports.useCallback(() => P2((e3) => !e3), [P2]), hasCustomAnchor: d2, onCustomAnchorAdd: react.exports.useCallback(() => m2(true), []), onCustomAnchorRemove: react.exports.useCallback(() => m2(false), []), modal: s2 }, t2));
};
const PopoverTrigger = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopePopover: r2 } = _a, n2 = __objRest(_a, ["__scopePopover"]), c2 = E$1("PopoverTrigger", r2), a2 = x$1(r2), s2 = useComposedRefs(o2, c2.triggerRef), i2 = /* @__PURE__ */ react.exports.createElement(Primitive.button, _extends({ type: "button", "aria-haspopup": "dialog", "aria-expanded": c2.open, "aria-controls": c2.contentId, "data-state": w$1(c2.open) }, n2, { ref: s2, onClick: composeEventHandlers(e2.onClick, c2.onOpenToggle) }));
  return c2.hasCustomAnchor ? i2 : /* @__PURE__ */ react.exports.createElement(Anchor, _extends({ asChild: true }, a2), i2);
});
const PopoverContent = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { forceMount: r2 } = _a, t2 = __objRest(_a, ["forceMount"]), c2 = E$1("PopoverContent", e2.__scopePopover);
  return react.exports.createElement(Presence, { present: r2 || c2.open }, c2.modal ? /* @__PURE__ */ react.exports.createElement(A, _extends({}, t2, { ref: o2 })) : /* @__PURE__ */ react.exports.createElement(O, _extends({}, t2, { ref: o2 })));
});
const A = /* @__PURE__ */ react.exports.forwardRef((r2, t2) => {
  const _a = r2, { allowPinchZoom: n2, portalled: c2 = true } = _a, s2 = __objRest(_a, ["allowPinchZoom", "portalled"]), i2 = E$1("PopoverContent", r2.__scopePopover), p2 = react.exports.useRef(null), u2 = useComposedRefs(t2, p2), l2 = react.exports.useRef(false);
  react.exports.useEffect(() => {
    const o2 = p2.current;
    if (o2)
      return hideOthers(o2);
  }, []);
  const d2 = c2 ? Portal : react.exports.Fragment;
  return react.exports.createElement(d2, null, /* @__PURE__ */ react.exports.createElement(o$4, { allowPinchZoom: n2 }, /* @__PURE__ */ react.exports.createElement(R$1, _extends({}, s2, { ref: u2, trapFocus: i2.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(r2.onCloseAutoFocus, (e2) => {
    var o2;
    e2.preventDefault(), l2.current || (o2 = i2.triggerRef.current) === null || o2 === void 0 || o2.focus();
  }), onPointerDownOutside: composeEventHandlers(r2.onPointerDownOutside, (e2) => {
    const o2 = e2.detail.originalEvent, r3 = o2.button === 0 && o2.ctrlKey === true, t3 = o2.button === 2 || r3;
    l2.current = t3;
  }, { checkForDefaultPrevented: false }), onFocusOutside: composeEventHandlers(r2.onFocusOutside, (e2) => e2.preventDefault(), { checkForDefaultPrevented: false }) }))));
}), O = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { portalled: r2 = true } = _a, t2 = __objRest(_a, ["portalled"]), n2 = E$1("PopoverContent", e2.__scopePopover), c2 = react.exports.useRef(false), s2 = r2 ? Portal : react.exports.Fragment;
  return react.exports.createElement(s2, null, /* @__PURE__ */ react.exports.createElement(R$1, _extends({}, t2, { ref: o2, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o3) => {
    var r3, t3;
    ((r3 = e2.onCloseAutoFocus) === null || r3 === void 0 || r3.call(e2, o3), o3.defaultPrevented) || (c2.current || (t3 = n2.triggerRef.current) === null || t3 === void 0 || t3.focus(), o3.preventDefault());
    c2.current = false;
  }, onInteractOutside: (o3) => {
    var r3, t3;
    (r3 = e2.onInteractOutside) === null || r3 === void 0 || r3.call(e2, o3), o3.defaultPrevented || (c2.current = true);
    const a2 = o3.target;
    ((t3 = n2.triggerRef.current) === null || t3 === void 0 ? void 0 : t3.contains(a2)) && o3.preventDefault();
  } })));
}), R$1 = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopePopover: r2, trapFocus: t2, onOpenAutoFocus: n2, onCloseAutoFocus: a2, disableOutsidePointerEvents: u2, onEscapeKeyDown: l2, onPointerDownOutside: d2, onFocusOutside: m2, onInteractOutside: f2 } = _a, C2 = __objRest(_a, ["__scopePopover", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]), g2 = E$1("PopoverContent", r2), h2 = x$1(r2);
  return useFocusGuards(), /* @__PURE__ */ react.exports.createElement(FocusScope, { asChild: true, loop: true, trapped: t2, onMountAutoFocus: n2, onUnmountAutoFocus: a2 }, /* @__PURE__ */ react.exports.createElement(DismissableLayer, { asChild: true, disableOutsidePointerEvents: u2, onInteractOutside: f2, onEscapeKeyDown: l2, onPointerDownOutside: d2, onFocusOutside: m2, onDismiss: () => g2.onOpenChange(false) }, /* @__PURE__ */ react.exports.createElement(Content$1, _extends({ "data-state": w$1(g2.open), role: "dialog", id: g2.contentId }, h2, C2, { ref: o2, style: __spreadProps(__spreadValues({}, C2.style), { "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)" }) }))));
});
const PopoverArrow = /* @__PURE__ */ react.exports.forwardRef((e2, o2) => {
  const _a = e2, { __scopePopover: r2 } = _a, t2 = __objRest(_a, ["__scopePopover"]), n2 = x$1(r2);
  return react.exports.createElement(Arrow$2, _extends({}, n2, t2, { ref: o2 }));
});
function w$1(e2) {
  return e2 ? "open" : "closed";
}
const Root$2 = Popover;
const Trigger = PopoverTrigger;
const Content = PopoverContent;
const Arrow$1 = PopoverArrow;
const Component$7 = ({
  value,
  onChange,
  options
}) => {
  const [isOpen, setOpen] = react.exports.useState(false);
  const changeHandler = (color) => prevent(() => {
    onChange(color);
    setOpen(false);
  });
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsxs(Root$2, {
      open: isOpen,
      onOpenChange: () => setOpen((v2) => !v2),
      children: [/* @__PURE__ */ jsx(Trigger, {
        asChild: true,
        children: /* @__PURE__ */ jsx(Button$2, {
          focused: isOpen || void 0,
          color: value || "",
          style: value ? {
            "--ve-selected-color": colorToProperty(value)
          } : void 0
        })
      }), /* @__PURE__ */ jsxs(Tooltip, {
        side: "top",
        children: [/* @__PURE__ */ jsxs(Palette, {
          style: {
            "--children": options.colors.length + 1
          },
          children: [/* @__PURE__ */ jsx(PaletteItemTransparent, {
            onClick: prevent(() => onChange(null))
          }), options.colors.map((color) => /* @__PURE__ */ jsx(PaletteItem, {
            style: {
              "--ve-color": colorToProperty(color)
            },
            onClick: changeHandler(color)
          }, color))]
        }), /* @__PURE__ */ jsx(Arrow, {})]
      })]
    })
  });
};
const Color = defineField({
  defaultOptions: {
    default: "",
    colors: []
  },
  render: Component$7
});
const Button$2 = /* @__PURE__ */ createStyled(UnstyledButton, {
  target: "eotgg4r5"
})({
  width: "38px",
  height: "38px",
  backgroundColor: "#fff",
  boxShadow: "var(--ve-field-shadow)",
  border: "1px solid var(--ve-field-border)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  cursor: "pointer",
  borderRadius: "3px",
  "&::before": {
    content: "''",
    display: "block",
    width: "28px",
    height: "28px",
    flex: "none",
    background: "var(--ve-selected-color, red)",
    borderRadius: "2px"
  },
  "&:focus": Styles.FocusState
}, (props) => __spreadProps(__spreadValues({}, props.focused ? Styles.FocusState : null), {
  "&::before": props.color ? null : Styles.Mosaic
}), "");
const In = keyframes({
  from: {
    transform: "translateY(-.2em)",
    opacity: 0
  }
});
const Tooltip = /* @__PURE__ */ createStyled(Content, {
  target: "eotgg4r4"
})({
  padding: 3,
  backgroundColor: "white",
  border: "solid 1px rgba(0, 0, 0, 0.1)",
  boxShadow: "rgba(0, 0, 0, 0.1) 0 10px 15px -3px, rgba(0, 0, 0, 0.05) 0 4px 6px -2px",
  borderRadius: "4px",
  animation: `${In} 0.3s ease-out`
}, "");
const Palette = createStyled("div", {
  target: "eotgg4r3"
})({
  name: "ea9use",
  styles: "flex-wrap:wrap;display:flex;width:calc(27px * var(--children) * 0.5)"
});
const PaletteItem = /* @__PURE__ */ createStyled(UnstyledButton, {
  target: "eotgg4r2"
})({
  name: "118g99r",
  styles: "position:relative;background-color:var(--ve-color);width:25px;height:25px;margin:1px;flex:none;z-index:2;cursor:pointer;border-radius:2px;border:1px solid var(--ve-field-border);box-shadow:var(--ve-field-shadow);&:hover{z-index:3;transform:scale(1.2);border-color:var(--ve-primary);outline:0;box-shadow:0 0 0 0.25rem rgb(23 113 230 / 25%);}"
});
const PaletteItemTransparent = /* @__PURE__ */ createStyled(PaletteItem, {
  target: "eotgg4r1"
})(__spreadProps(__spreadValues({}, Styles.Mosaic), {
  position: "relative",
  overflow: "hidden",
  "&::before": {
    position: "absolute",
    top: "-9px",
    left: "calc(50% - 1px)",
    content: "''",
    width: "2px",
    height: "40px",
    background: "red",
    transform: "rotate(45deg)"
  }
}), "");
const Arrow = /* @__PURE__ */ createStyled(Arrow$1, {
  target: "eotgg4r0"
})({
  name: "1b3qpiw",
  styles: "fill:white"
});
const RowComponent = ({
  options,
  children
}) => {
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(Wrapper, {
      columns: options.columns,
      children
    })
  });
};
const Row = defineFieldGroup({
  defaultOptions: {},
  render: RowComponent
});
const Wrapper = /* @__PURE__ */ createStyled(Flex, {
  target: "ez1oo7t0"
})("& > *{width:100%;}", ({
  columns
}) => columns ? {
  display: "grid",
  gridTemplateColumns: columns
} : {}, "");
function AlignmentButton(_u) {
  var _v = _u, {
    value,
    onChange,
    icon: IconComponent
  } = _v, props = __objRest(_v, [
    "value",
    "onChange",
    "icon"
  ]);
  return /* @__PURE__ */ jsxs(Button$1, {
    children: [/* @__PURE__ */ jsx("input", __spreadValues({
      type: "radio",
      value,
      onChange: () => onChange(value),
      title: capitalize(value)
    }, props)), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(IconComponent, {})
    })]
  });
}
const Button$1 = createStyled("div", {
  target: "e1mdcioa0"
})({
  name: "1pu2klx",
  styles: "position:relative;border-right:1px solid var(--ve-field-border);&:last-of-type{border:none;}&:hover{background-color:var(--ve-hover);}& div{cursor:pointer;width:36px;height:36px;display:flex;align-items:center;justify-content:center;z-index:2;transition:.3s;}& input{opacity:0;position:absolute;top:0;left:0;width:100%;height:100%;z-index:3;cursor:pointer;}& input:checked + div{background-color:var(--ve-primary);color:#FFF;box-shadow:0 0 0 1px var(--ve-primary);border-radius:.2em;}& input:focus + div{box-shadow:0 0 0 1px var(--ve-primary), 0 0 0 0.25rem rgb(23 113 230 / 25%);border-radius:.2em;}"
});
const AlignmentButtons = createStyled("div", {
  target: "e1q9zsr00"
})({
  name: "1z5vla",
  styles: "display:inline-flex;border:1px solid var(--ve-field-border);box-shadow:var(--ve-field-shadow);border-radius:.2em"
});
const AlignmentIcons$1 = {
  top: IconAlignTop,
  left: IconAlignLeft,
  bottom: IconAlignBottom,
  right: IconAlignRight
};
const Component$6 = ({
  value,
  onChange,
  options
}) => {
  const alignements = ["left", "right", ...options.vertical ? ["top", "bottom"] : []];
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(AlignmentButtons, {
      children: alignements.map((alignment) => /* @__PURE__ */ jsx(AlignmentButton, {
        value: alignment,
        checked: value === alignment,
        onChange,
        icon: AlignmentIcons$1[alignment]
      }, alignment))
    })
  });
};
const Alignment = defineField({
  defaultOptions: {
    default: "left"
  },
  render: Component$6
});
const Component$5 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("selectinput");
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    label: options.label,
    help: options.help,
    options: options.options,
    value,
    onInput: (e2) => onChange(e2.target.value)
  });
};
const Select = defineField({
  defaultOptions: {
    default: "",
    options: []
  },
  render: Component$5
});
const Component$4 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("numberinput");
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    type: "number",
    id: id2,
    value,
    onInput: (e2) => onChange(e2.target.value),
    help: options.help
  });
};
const Number$1 = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$4
});
function usePrevious(r2) {
  const u2 = react.exports.useRef({ value: r2, previous: r2 });
  return react.exports.useMemo(() => (u2.current.value !== r2 && (u2.current.previous = u2.current.value, u2.current.value = r2), u2.current.previous), [r2]);
}
function useDirection(t2, n2) {
  const [r2, o2] = react.exports.useState("ltr"), [i2, u2] = react.exports.useState(), c2 = react.exports.useRef(0);
  return react.exports.useEffect(() => {
    if (n2 === void 0 && t2 != null && t2.parentElement) {
      const e2 = getComputedStyle(t2.parentElement);
      u2(e2);
    }
  }, [t2, n2]), react.exports.useEffect(() => (n2 === void 0 && function e2() {
    c2.current = requestAnimationFrame(() => {
      const t3 = i2 == null ? void 0 : i2.direction;
      t3 && o2(t3), e2();
    });
  }(), () => cancelAnimationFrame(c2.current)), [i2, n2, o2]), n2 || r2;
}
function clamp(t2, [a2, n2]) {
  return Math.min(n2, Math.max(a2, t2));
}
const m = ["PageUp", "PageDown"], f = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], p = { ltr: ["ArrowDown", "Home", "ArrowLeft", "PageDown"], rtl: ["ArrowDown", "Home", "ArrowRight", "PageDown"] }, [S, h, v] = createCollection("Slider"), [w, g] = createContextScope("Slider", [v]);
const [x, b] = w("Slider");
const Slider = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const _a = e2, { name: n2, min: r2 = 0, max: o2 = 100, step: a2 = 1, orientation: d2 = "horizontal", disabled: p2 = false, minStepsBetweenThumbs: h2 = 0, defaultValue: v2 = [r2], value: w2, onValueChange: g2 = () => {
  } } = _a, b2 = __objRest(_a, ["name", "min", "max", "step", "orientation", "disabled", "minStepsBetweenThumbs", "defaultValue", "value", "onValueChange"]), [E2, y2] = react.exports.useState(null), _2 = useComposedRefs(t2, (e3) => y2(e3)), M2 = react.exports.useRef(/* @__PURE__ */ new Set()), K2 = react.exports.useRef(0), T2 = d2 === "horizontal", k2 = !E2 || Boolean(E2.closest("form")), C2 = T2 ? R : D, [I2 = [], z2] = useControllableState({ prop: w2, defaultProp: v2, onChange: (e3) => {
    var t3;
    (t3 = [...M2.current][K2.current]) === null || t3 === void 0 || t3.focus(), g2(e3);
  } });
  function A2(e3, t3) {
    const n3 = function(e4) {
      return (String(e4).split(".")[1] || "").length;
    }(a2), i2 = function(e4, t4) {
      const n4 = Math.pow(10, t4);
      return Math.round(e4 * n4) / n4;
    }(Math.round((e3 - r2) / a2) * a2 + r2, n3), l2 = clamp(i2, [r2, o2]);
    z2((e4 = []) => {
      const n4 = function(e5 = [], t4, n5) {
        const r3 = [...e5];
        return r3[n5] = t4, r3.sort((e6, t5) => e6 - t5);
      }(e4, l2, t3);
      return function(e5, t4) {
        if (t4 > 0) {
          const n5 = function(e6) {
            return e6.slice(0, -1).map((t5, n6) => e6[n6 + 1] - t5);
          }(e5);
          return Math.min(...n5) >= t4;
        }
        return true;
      }(n4, h2 * a2) ? (K2.current = n4.indexOf(l2), String(n4) === String(e4) ? e4 : n4) : e4;
    });
  }
  return react.exports.createElement(x, { scope: e2.__scopeSlider, disabled: p2, min: r2, max: o2, valueIndexToChangeRef: K2, thumbs: M2.current, values: I2, orientation: d2 }, /* @__PURE__ */ react.exports.createElement(S.Provider, { scope: e2.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(S.Slot, { scope: e2.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(C2, _extends({ "aria-disabled": p2, "data-disabled": p2 ? "" : void 0 }, b2, { ref: _2, min: r2, max: o2, onSlideStart: p2 ? void 0 : function(e3) {
    A2(e3, function(e4, t3) {
      if (e4.length === 1)
        return 0;
      const n3 = e4.map((e5) => Math.abs(e5 - t3)), r3 = Math.min(...n3);
      return n3.indexOf(r3);
    }(I2, e3));
  }, onSlideMove: p2 ? void 0 : function(e3) {
    A2(e3, K2.current);
  }, onHomeKeyDown: () => !p2 && A2(r2, 0), onEndKeyDown: () => !p2 && A2(o2, I2.length - 1), onStepKeyDown: ({ event: e3, direction: t3 }) => {
    if (!p2) {
      const n3 = m.includes(e3.key) || e3.shiftKey && f.includes(e3.key) ? 10 : 1, r3 = K2.current;
      A2(I2[r3] + a2 * n3 * t3, r3);
    }
  } })))), k2 && I2.map((e3, t3) => /* @__PURE__ */ react.exports.createElement(P, { key: t3, name: n2 ? n2 + (I2.length > 1 ? "[]" : "") : void 0, value: e3 })));
});
const [E, y] = w("Slider", { startEdge: "left", endEdge: "right", size: "width", direction: 1 }), R = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const _a = e2, { min: n2, max: r2, dir: i2, onSlideStart: a2, onSlideMove: d2, onStepKeyDown: s2 } = _a, m2 = __objRest(_a, ["min", "max", "dir", "onSlideStart", "onSlideMove", "onStepKeyDown"]), [f2, S2] = react.exports.useState(null), h2 = useComposedRefs(t2, (e3) => S2(e3)), v2 = react.exports.useRef(), w2 = useDirection(f2, i2), g2 = w2 === "ltr";
  function x2(e3) {
    const t3 = v2.current || f2.getBoundingClientRect(), o2 = T([0, t3.width], g2 ? [n2, r2] : [r2, n2]);
    return v2.current = t3, o2(e3 - t3.left);
  }
  return react.exports.createElement(E, { scope: e2.__scopeSlider, startEdge: g2 ? "left" : "right", endEdge: g2 ? "right" : "left", direction: g2 ? 1 : -1, size: "width" }, /* @__PURE__ */ react.exports.createElement(_, _extends({ "data-orientation": "horizontal" }, m2, { ref: h2, style: __spreadProps(__spreadValues({}, m2.style), { "--radix-slider-thumb-transform": "translateX(-50%)" }), onSlideStart: (e3) => {
    const t3 = x2(e3.clientX);
    a2 == null || a2(t3);
  }, onSlideMove: (e3) => {
    const t3 = x2(e3.clientX);
    d2 == null || d2(t3);
  }, onSlideEnd: () => v2.current = void 0, onStepKeyDown: (e3) => {
    const t3 = p[w2].includes(e3.key);
    s2 == null || s2({ event: e3, direction: t3 ? -1 : 1 });
  } })));
}), D = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const _a = e2, { min: n2, max: r2, onSlideStart: o2, onSlideMove: i2, onStepKeyDown: a2 } = _a, d2 = __objRest(_a, ["min", "max", "onSlideStart", "onSlideMove", "onStepKeyDown"]), s2 = react.exports.useRef(null), m2 = useComposedRefs(t2, s2), f2 = react.exports.useRef();
  function S2(e3) {
    const t3 = f2.current || s2.current.getBoundingClientRect(), o3 = T([0, t3.height], [r2, n2]);
    return f2.current = t3, o3(e3 - t3.top);
  }
  return react.exports.createElement(E, { scope: e2.__scopeSlider, startEdge: "bottom", endEdge: "top", size: "height", direction: 1 }, /* @__PURE__ */ react.exports.createElement(_, _extends({ "data-orientation": "vertical" }, d2, { ref: m2, style: __spreadProps(__spreadValues({}, d2.style), { "--radix-slider-thumb-transform": "translateY(50%)" }), onSlideStart: (e3) => {
    const t3 = S2(e3.clientY);
    o2 == null || o2(t3);
  }, onSlideMove: (e3) => {
    const t3 = S2(e3.clientY);
    i2 == null || i2(t3);
  }, onSlideEnd: () => f2.current = void 0, onStepKeyDown: (e3) => {
    const t3 = p.ltr.includes(e3.key);
    a2 == null || a2({ event: e3, direction: t3 ? -1 : 1 });
  } })));
}), _ = /* @__PURE__ */ react.exports.forwardRef((e2, n2) => {
  const _a = e2, { __scopeSlider: r2, onSlideStart: o2, onSlideMove: i2, onSlideEnd: a2, onHomeKeyDown: l2, onEndKeyDown: s2, onStepKeyDown: p2 } = _a, S2 = __objRest(_a, ["__scopeSlider", "onSlideStart", "onSlideMove", "onSlideEnd", "onHomeKeyDown", "onEndKeyDown", "onStepKeyDown"]), h2 = b("Slider", r2);
  return react.exports.createElement(Primitive.span, _extends({}, S2, { ref: n2, onKeyDown: composeEventHandlers(e2.onKeyDown, (e3) => {
    e3.key === "Home" ? (l2(e3), e3.preventDefault()) : e3.key === "End" ? (s2(e3), e3.preventDefault()) : m.concat(f).includes(e3.key) && (p2(e3), e3.preventDefault());
  }), onPointerDown: composeEventHandlers(e2.onPointerDown, (e3) => {
    const t2 = e3.target;
    t2.setPointerCapture(e3.pointerId), e3.preventDefault(), h2.thumbs.has(t2) ? t2.focus() : o2(e3);
  }), onPointerMove: composeEventHandlers(e2.onPointerMove, (e3) => {
    e3.target.hasPointerCapture(e3.pointerId) && i2(e3);
  }), onPointerUp: composeEventHandlers(e2.onPointerUp, (e3) => {
    const t2 = e3.target;
    t2.hasPointerCapture(e3.pointerId) && (t2.releasePointerCapture(e3.pointerId), a2(e3));
  }) }));
});
const SliderTrack = /* @__PURE__ */ react.exports.forwardRef((e2, n2) => {
  const _a = e2, { __scopeSlider: r2 } = _a, o2 = __objRest(_a, ["__scopeSlider"]), i2 = b("SliderTrack", r2);
  return react.exports.createElement(Primitive.span, _extends({ "data-disabled": i2.disabled ? "" : void 0, "data-orientation": i2.orientation }, o2, { ref: n2 }));
});
const SliderRange = /* @__PURE__ */ react.exports.forwardRef((e2, n2) => {
  const _a = e2, { __scopeSlider: r2 } = _a, o2 = __objRest(_a, ["__scopeSlider"]), i2 = b("SliderRange", r2), a2 = y("SliderRange", r2), d2 = react.exports.useRef(null), s2 = useComposedRefs(n2, d2), m2 = i2.values.length, f2 = i2.values.map((e3) => K(e3, i2.min, i2.max)), p2 = m2 > 1 ? Math.min(...f2) : 0, S2 = 100 - Math.max(...f2);
  return react.exports.createElement(Primitive.span, _extends({ "data-orientation": i2.orientation, "data-disabled": i2.disabled ? "" : void 0 }, o2, { ref: s2, style: __spreadProps(__spreadValues({}, e2.style), { [a2.startEdge]: p2 + "%", [a2.endEdge]: S2 + "%" }) }));
});
const SliderThumb = /* @__PURE__ */ react.exports.forwardRef((e2, t2) => {
  const n2 = h(e2.__scopeSlider), [r2, o2] = react.exports.useState(null), i2 = useComposedRefs(t2, (e3) => o2(e3)), a2 = react.exports.useMemo(() => r2 ? n2().findIndex((e3) => e3.ref.current === r2) : -1, [n2, r2]);
  return react.exports.createElement(M, _extends({}, e2, { ref: i2, index: a2 }));
});
const M = /* @__PURE__ */ react.exports.forwardRef((e2, r2) => {
  const _a = e2, { __scopeSlider: o2, index: i2 } = _a, a2 = __objRest(_a, ["__scopeSlider", "index"]), s2 = b("SliderThumb", o2), m2 = y("SliderThumb", o2), [f2, p2] = react.exports.useState(null), h2 = useComposedRefs(r2, (e3) => p2(e3)), v2 = useSize(f2), w2 = s2.values[i2], g2 = w2 === void 0 ? 0 : K(w2, s2.min, s2.max), x2 = function(e3, t2) {
    return t2 > 2 ? `Value ${e3 + 1} of ${t2}` : t2 === 2 ? ["Minimum", "Maximum"][e3] : void 0;
  }(i2, s2.values.length), E2 = v2 == null ? void 0 : v2[m2.size], R2 = E2 ? function(e3, t2, n2) {
    const r3 = e3 / 2, o3 = T([0, 50], [0, r3]);
    return (r3 - o3(t2) * n2) * n2;
  }(E2, g2, m2.direction) : 0;
  return react.exports.useEffect(() => {
    if (f2)
      return s2.thumbs.add(f2), () => {
        s2.thumbs.delete(f2);
      };
  }, [f2, s2.thumbs]), /* @__PURE__ */ react.exports.createElement("span", { style: { transform: "var(--radix-slider-thumb-transform)", position: "absolute", [m2.startEdge]: `calc(${g2}% + ${R2}px)` } }, /* @__PURE__ */ react.exports.createElement(S.ItemSlot, { scope: e2.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(Primitive.span, _extends({ role: "slider", "aria-label": e2["aria-label"] || x2, "aria-valuemin": s2.min, "aria-valuenow": w2, "aria-valuemax": s2.max, "aria-orientation": s2.orientation, "data-orientation": s2.orientation, "data-disabled": s2.disabled ? "" : void 0, tabIndex: s2.disabled ? void 0 : 0 }, a2, { ref: h2, style: w2 === void 0 ? { display: "none" } : e2.style, onFocus: composeEventHandlers(e2.onFocus, () => {
    s2.valueIndexToChangeRef.current = i2;
  }) }))));
}), P = (e2) => {
  const _a = e2, { value: t2 } = _a, n2 = __objRest(_a, ["value"]), o2 = react.exports.useRef(null), i2 = usePrevious(t2);
  return react.exports.useEffect(() => {
    const e3 = o2.current, n3 = window.HTMLInputElement.prototype, r2 = Object.getOwnPropertyDescriptor(n3, "value").set;
    if (i2 !== t2 && r2) {
      const n4 = new Event("input", { bubbles: true });
      r2.call(e3, t2), e3.dispatchEvent(n4);
    }
  }, [i2, t2]), /* @__PURE__ */ react.exports.createElement("input", _extends({ style: { display: "none" } }, n2, { ref: o2, defaultValue: t2 }));
};
function K(e2, t2, n2) {
  return 100 / (n2 - t2) * (e2 - t2);
}
function T(e2, t2) {
  return (n2) => {
    if (e2[0] === e2[1] || t2[0] === t2[1])
      return t2[0];
    const r2 = (t2[1] - t2[0]) / (e2[1] - e2[0]);
    return t2[0] + r2 * (n2 - e2[0]);
  };
}
const Root$1 = Slider;
const Track$1 = SliderTrack;
const Range$1 = SliderRange;
const Thumb = SliderThumb;
const Component$3 = ({
  value,
  onChange,
  options
}) => {
  return /* @__PURE__ */ jsx(Field$1, {
    label: /* @__PURE__ */ jsxs(Fragment$1, {
      children: [options.label, " ", /* @__PURE__ */ jsxs("small", {
        children: ["(", value, ")"]
      })]
    }),
    help: options.help,
    children: /* @__PURE__ */ jsxs(Root, {
      min: options.min,
      max: options.max,
      value: [value === void 0 ? options.default || 0 : value],
      step: options.step,
      onValueChange: (v2) => onChange(v2[0] || 0),
      children: [/* @__PURE__ */ jsx(Track, {
        children: /* @__PURE__ */ jsx(TrackSelected, {})
      }), /* @__PURE__ */ jsx(Cursor, {})]
    })
  });
};
const Range = defineField({
  defaultOptions: {
    default: 0,
    min: 0,
    max: 100,
    step: 1
  },
  render: Component$3
});
const Root = /* @__PURE__ */ createStyled(Root$1, {
  target: "e18z983y3"
})({
  name: "154h4by",
  styles: "position:relative;display:flex;align-items:center;user-select:none;touch-action:none;width:100%;height:20px"
});
const Track = /* @__PURE__ */ createStyled(Track$1, {
  target: "e18z983y2"
})({
  name: "l10cfu",
  styles: "position:relative;display:block;height:5px;background-color:var(--ve-field-border);width:100%;border-radius:5px"
});
const TrackSelected = /* @__PURE__ */ createStyled(Range$1, {
  target: "e18z983y1"
})({
  name: "v9pn8w",
  styles: "position:absolute;left:0;height:100%;display:block;border-radius:5px;background-color:var(--ve-primary)"
});
const Cursor = /* @__PURE__ */ createStyled(Thumb, {
  target: "e18z983y0"
})({
  display: "block",
  backgroundColor: "#FFF",
  width: "20px",
  height: "20px",
  borderRadius: "20px",
  boxShadow: "rgba(0, 0, 0, 0.1) 0 10px 15px -3px, rgba(0, 0, 0, 0.05) 0 4px 6px -2px",
  cursor: "pointer",
  border: "1px solid var(--ve-field-border)",
  "&:focus": Styles.FocusState
}, "");
const Component$2 = ({
  children,
  options
}) => {
  const childrenForTab = (tab) => {
    return react.exports.cloneElement(children, {
      fields: tab.fields
    });
  };
  return /* @__PURE__ */ jsx(Tabs$1, {
    children: options.tabs.map((tab) => /* @__PURE__ */ jsx(Tabs$1.Tab, {
      title: tab.label,
      children: /* @__PURE__ */ jsx(Flex, {
        column: true,
        children: childrenForTab(tab)
      })
    }, tab.label))
  });
};
function Tabs(...tabs) {
  return __spreadProps(__spreadValues({}, defaultFieldProperties()), {
    group: true,
    options: {
      tabs
    },
    render: Component$2,
    fields: tabs.reduce((acc, tab) => [...acc, ...tab.fields], [])
  });
}
var classnames2 = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          } else {
            classes.push(arg.toString());
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames2);
var r = classnames2.exports;
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token2, count, options) {
  var result2;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result2 = tokenValue;
  } else if (count === 1) {
    result2 = tokenValue.one;
  } else {
    result2 = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result2;
    } else {
      return result2 + " ago";
    }
  }
  return result2;
};
var formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index3 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index3];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex2(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex2(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index3) {
      return index3 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$2 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  y: function(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  M: function(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  a: function(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  H: function(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  m: function(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  s: function(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  S: function(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var lightFormatters = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters.y(date, token2);
  },
  Y: function(date, token2, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  R: function(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  u: function(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  Q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token2, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  I: function(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters.d(date, token2);
  },
  D: function(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  E: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters.h(date, token2);
  },
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters.H(date, token2);
  },
  K: function(date, token2, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  k: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters.m(date, token2);
  },
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters.s(date, token2);
  },
  S: function(date, token2) {
    return lightFormatters.S(date, token2);
  },
  X: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  T: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset3, dirtyDelimiter) {
  var sign = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter2 = dirtyDelimiter || "";
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset3, dirtyDelimiter) {
  if (offset3 % 60 === 0) {
    var sign = offset3 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset3) / 60, 2);
  }
  return formatTimezone(offset3, dirtyDelimiter);
}
function formatTimezone(offset3, dirtyDelimiter) {
  var delimiter2 = dirtyDelimiter || "";
  var sign = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}
var formatters$1 = formatters;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format2, input) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result2 = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result2;
}
function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}
var MILLISECONDS_IN_MINUTE$1 = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$1);
}
var MILLISECONDS_IN_HOUR$1 = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$1);
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}
function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return setMonth(date, date.getMonth() + diff * 3);
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function min2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (typeof dirtyDatesArray === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result2;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result2 === void 0 || result2 > currentDate || isNaN(currentDate.getDate())) {
      result2 = currentDate;
    }
  });
  return result2 || new Date(NaN);
}
function max2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (typeof dirtyDatesArray === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result2;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result2 === void 0 || result2 < currentDate || isNaN(Number(currentDate))) {
      result2 = currentDate;
    }
  });
  return result2 || new Date(NaN);
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function isWithinInterval(dirtyDate, interval) {
  requiredArgs(2, arguments);
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time >= startTime && time <= endTime;
}
function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  dirtyObject = dirtyObject || {};
  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }
  return target;
}
function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var MILLISECONDS_IN_SECOND = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n2, string, valueCallback) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), string, valueCallback);
  }
}
function parseNDigitsSigned(n2, string, valueCallback) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result2;
  if (absCurrentYear <= 50) {
    result2 = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result2 = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result2 : 1 - result2;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  G: {
    priority: 140,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(string, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(string, {
            width: "wide"
          }) || match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
      }
    },
    set: function(date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["R", "u", "t", "T"]
  },
  y: {
    priority: 130,
    parse: function(string, token2, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token2 === "yy"
        };
      };
      switch (token2) {
        case "y":
          return parseNDigits(4, string, valueCallback);
        case "yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token2.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
  },
  Y: {
    priority: 130,
    parse: function(string, token2, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token2 === "YY"
        };
      };
      switch (token2) {
        case "Y":
          return parseNDigits(4, string, valueCallback);
        case "Yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token2.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  R: {
    priority: 130,
    parse: function(string, token2, _match, _options) {
      if (token2 === "R") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token2.length, string);
    },
    set: function(_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  u: {
    priority: 130,
    parse: function(string, token2, _match, _options) {
      if (token2 === "u") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token2.length, string);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
  },
  Q: {
    priority: 120,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "Q":
        case "QQ":
          return parseNDigits(token2.length, string);
        case "Qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  q: {
    priority: 120,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "q":
        case "qq":
          return parseNDigits(token2.length, string);
        case "qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  M: {
    priority: 110,
    parse: function(string, token2, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token2) {
        case "M":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "MM":
          return parseNDigits(2, string, valueCallback);
        case "Mo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "MMM":
          return match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(string, {
            width: "wide",
            context: "formatting"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  L: {
    priority: 110,
    parse: function(string, token2, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token2) {
        case "L":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "LL":
          return parseNDigits(2, string, valueCallback);
        case "Lo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "LLL":
          return match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(string, {
            width: "wide",
            context: "standalone"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  w: {
    priority: 100,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "w":
          return parseNumericPattern(numericPatterns.week, string);
        case "wo":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  I: {
    priority: 100,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "I":
          return parseNumericPattern(numericPatterns.week, string);
        case "Io":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  d: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "d":
          return parseNumericPattern(numericPatterns.date, string);
        case "do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  D: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case "Do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
  },
  E: {
    priority: 90,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
  },
  e: {
    priority: 90,
    parse: function(string, token2, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "e":
        case "ee":
          return parseNDigits(token2.length, string, valueCallback);
        case "eo":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "eee":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
  },
  c: {
    priority: 90,
    parse: function(string, token2, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "c":
        case "cc":
          return parseNDigits(token2.length, string, valueCallback);
        case "co":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "ccc":
          return match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(string, {
            width: "wide",
            context: "standalone"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
  },
  i: {
    priority: 90,
    parse: function(string, token2, match2, _options) {
      var valueCallback = function(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token2) {
        case "i":
        case "ii":
          return parseNDigits(token2.length, string);
        case "io":
          return match2.ordinalNumber(string, {
            unit: "day"
          });
        case "iii":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiii":
          return match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiiii":
          return match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiii":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function(date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
  },
  a: {
    priority: 80,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["b", "B", "H", "k", "t", "T"]
  },
  b: {
    priority: 80,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "B", "H", "k", "t", "T"]
  },
  B: {
    priority: 80,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "t", "T"]
  },
  h: {
    priority: 70,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, string);
        case "ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["H", "K", "k", "t", "T"]
  },
  H: {
    priority: 70,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, string);
        case "Ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
  },
  K: {
    priority: 70,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, string);
        case "Ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["h", "H", "k", "t", "T"]
  },
  k: {
    priority: 70,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, string);
        case "ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function(date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
  },
  m: {
    priority: 60,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, string);
        case "mo":
          return match2.ordinalNumber(string, {
            unit: "minute"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  s: {
    priority: 50,
    parse: function(string, token2, match2, _options) {
      switch (token2) {
        case "s":
          return parseNumericPattern(numericPatterns.second, string);
        case "so":
          return match2.ordinalNumber(string, {
            unit: "second"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  S: {
    priority: 30,
    parse: function(string, token2, _match, _options) {
      var valueCallback = function(value) {
        return Math.floor(value * Math.pow(10, -token2.length + 3));
      };
      return parseNDigits(token2.length, string, valueCallback);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  X: {
    priority: 10,
    parse: function(string, token2, _match, _options) {
      switch (token2) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "x"]
  },
  x: {
    priority: 10,
    parse: function(string, token2, _match, _options) {
      switch (token2) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "X"]
  },
  t: {
    priority: 40,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  },
  T: {
    priority: 20,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  }
};
var parsers$1 = parsers;
var TIMEZONE_UNIT_PRIORITY = 10;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse3(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i2;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter2 = substring[0];
    if (firstCharacter2 === "p" || firstCharacter2 === "P") {
      var longFormatter = longFormatters$1[firstCharacter2];
      return longFormatter(substring, locale2.formatLong, subFnOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  for (i2 = 0; i2 < tokens.length; i2++) {
    var token2 = tokens[i2];
    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token2)) {
      throwProtectedError(token2, formatString, dirtyDateString);
    }
    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token2)) {
      throwProtectedError(token2, formatString, dirtyDateString);
    }
    var firstCharacter = token2[0];
    var parser = parsers$1[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;
        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;
          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token2, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token2, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: token2
      });
      var parseResult = parser.parse(dateString, token2, locale2.match, subFnOptions);
      if (!parseResult) {
        return new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      if (token2 === "''") {
        token2 = "'";
      } else if (firstCharacter === "'") {
        token2 = cleanEscapedString(token2);
      }
      if (dateString.indexOf(token2) === 0) {
        dateString = dateString.slice(token2.length);
      } else {
        return new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a2, b2) {
    return b2 - a2;
  }).filter(function(priority, index3, array) {
    return array.indexOf(priority) === index3;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a2, b2) {
      return b2.subPriority - a2.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date)) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (i2 = 0; i2 < uniquePrioritySetters.length; i2++) {
    var setter = uniquePrioritySetters[i2];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }
    var result2 = setter.set(utcDate, flags, setter.value, subFnOptions);
    if (result2[0]) {
      utcDate = result2[0];
      assign(flags, result2[1]);
    } else {
      utcDate = result2;
    }
  }
  return utcDate;
}
function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }
  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
function parseISO(argument, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? 2 : toInteger(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset3;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset3 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset3)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result2 = new Date(0);
    result2.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result2.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result2;
  }
  return new Date(timestamp + time + offset3);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token2 = patterns.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
var testPassiveEventSupport = function testPassiveEventSupport2() {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
    return;
  }
  var passive2 = false;
  var options = Object.defineProperty({}, "passive", {
    get: function get3() {
      passive2 = true;
    }
  });
  var noop2 = function noop3() {
  };
  window.addEventListener("testPassiveEventSupport", noop2, options);
  window.removeEventListener("testPassiveEventSupport", noop2, options);
  return passive2;
};
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
var uid = autoInc();
var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ["touchstart", "touchmove"];
var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = null;
  var isTouchEvent2 = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent2 && passiveEventSupport) {
    handlerOptions = {
      passive: !instance.props.preventDefault
    };
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(onClickOutside2, _Component);
    function onClickOutside2(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config && typeof config.setClickOutsideRef === "function") {
          return config.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return reactDom.exports.findDOMNode(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events2 = _this.props.eventTypes;
        if (!events2.forEach) {
          events2 = [events2];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events2.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn3 = handlersMap[_this._uid];
        if (fn3 && typeof document !== "undefined") {
          var events2 = _this.props.eventTypes;
          if (!events2.forEach) {
            events2 = [events2];
          }
          events2.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn3, getEventHandlerOptions(_assertThisInitialized(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref) {
        return _this.instanceRef = ref;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside2.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config && typeof config.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return react.exports.createElement(WrappedComponent, props);
    };
    return onClickOutside2;
  }(react.exports.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config && config.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var ManagerReferenceNodeContext = react.exports.createContext();
var ManagerReferenceNodeSetterContext = react.exports.createContext();
function Manager(_ref2) {
  var children = _ref2.children;
  var _React$useState = react.exports.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = react.exports.useRef(false);
  react.exports.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = react.exports.useCallback(function(node5) {
    if (!hasUnmounted.current) {
      setReferenceNode(node5);
    }
  }, []);
  return /* @__PURE__ */ react.exports.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /* @__PURE__ */ react.exports.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn3) {
  if (typeof fn3 === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn3.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node5) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node5);
  } else if (ref != null) {
    ref.current = node5;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref2) {
    var key = _ref2[0], value = _ref2[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? react.exports.useLayoutEffect : react.exports.useEffect;
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    var it2;
    if (hasMap && a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size)
        return false;
      it2 = a2.entries();
      while (!(i2 = it2.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      it2 = a2.entries();
      while (!(i2 = it2.next()).done)
        if (!equal(i2.value[1], b2.get(i2.value[0])))
          return false;
      return true;
    }
    if (hasSet && a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size)
        return false;
      it2 = a2.entries();
      while (!(i2 = it2.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    if (hasElementType && a2 instanceof Element)
      return false;
    for (i2 = length2; i2-- !== 0; ) {
      if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
        continue;
      }
      if (!equal(a2[keys2[i2]], b2[keys2[i2]]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function isEqual2(a2, b2) {
  try {
    return equal(a2, b2);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
var EMPTY_MODIFIERS$1 = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = react.exports.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS$1
  };
  var _React$useState = react.exports.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = react.exports.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        var elements = Object.keys(state2.elements);
        setState({
          styles: fromEntries(elements.map(function(element) {
            return [element, state2.styles[element] || {}];
          })),
          attributes: fromEntries(elements.map(function(element) {
            return [element, state2.attributes[element]];
          }))
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = react.exports.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if (reactFastCompare(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = react.exports.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper$1 = options.createPopper || createPopper;
    var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS = [];
function Popper(_ref2) {
  var _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref2.modifiers, modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers, referenceElement = _ref2.referenceElement, onFirstUpdate = _ref2.onFirstUpdate, innerRef = _ref2.innerRef, children = _ref2.children;
  var referenceNode = react.exports.useContext(ManagerReferenceNodeContext);
  var _React$useState = react.exports.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = react.exports.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  react.exports.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = react.exports.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers2, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update2 = _usePopper.update;
  var childrenProps = react.exports.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update2 || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update2, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
function Reference(_ref2) {
  var children = _ref2.children, innerRef = _ref2.innerRef;
  var setReferenceNode = react.exports.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = react.exports.useCallback(function(node5) {
    setRef(innerRef, node5);
    safeInvoke(setReferenceNode, node5);
  }, [innerRef, setReferenceNode]);
  react.exports.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  });
  react.exports.useEffect(function() {
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
function ae(e2, t2) {
  var r2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), r2.push.apply(r2, n2);
  }
  return r2;
}
function se(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = arguments[t2] != null ? arguments[t2] : {};
    t2 % 2 ? ae(Object(r2), true).forEach(function(t3) {
      de(e2, t3, r2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : ae(Object(r2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
    });
  }
  return e2;
}
function ie(e2) {
  return (ie = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
function pe(e2, t2) {
  if (!(e2 instanceof t2))
    throw new TypeError("Cannot call a class as a function");
}
function ce(e2, t2) {
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
  }
}
function le(e2, t2, r2) {
  return t2 && ce(e2.prototype, t2), r2 && ce(e2, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function de(e2, t2, r2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
}
function ue() {
  return (ue = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }).apply(this, arguments);
}
function he(e2, t2) {
  if (typeof t2 != "function" && t2 !== null)
    throw new TypeError("Super expression must either be null or a function");
  Object.defineProperty(e2, "prototype", { value: Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), writable: false }), t2 && fe(e2, t2);
}
function me(e2) {
  return (me = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
    return e3.__proto__ || Object.getPrototypeOf(e3);
  })(e2);
}
function fe(e2, t2) {
  return (fe = Object.setPrototypeOf || function(e3, t3) {
    return e3.__proto__ = t3, e3;
  })(e2, t2);
}
function ye(e2) {
  if (e2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function ve(e2, t2) {
  if (t2 && (typeof t2 == "object" || typeof t2 == "function"))
    return t2;
  if (t2 !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return ye(e2);
}
function De(e2) {
  var t2 = function() {
    if (typeof Reflect == "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var r2, n2 = me(e2);
    if (t2) {
      var o2 = me(this).constructor;
      r2 = Reflect.construct(n2, arguments, o2);
    } else
      r2 = n2.apply(this, arguments);
    return ve(this, r2);
  };
}
function we(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return ge(e3);
  }(e2) || function(e3) {
    if (typeof Symbol != "undefined" && e3[Symbol.iterator] != null || e3["@@iterator"] != null)
      return Array.from(e3);
  }(e2) || function(e3, t2) {
    if (!e3)
      return;
    if (typeof e3 == "string")
      return ge(e3, t2);
    var r2 = Object.prototype.toString.call(e3).slice(8, -1);
    r2 === "Object" && e3.constructor && (r2 = e3.constructor.name);
    if (r2 === "Map" || r2 === "Set")
      return Array.from(e3);
    if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
      return ge(e3, t2);
  }(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function ge(e2, t2) {
  (t2 == null || t2 > e2.length) && (t2 = e2.length);
  for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
    n2[r2] = e2[r2];
  return n2;
}
function ke(e2, t2) {
  switch (e2) {
    case "P":
      return t2.date({ width: "short" });
    case "PP":
      return t2.date({ width: "medium" });
    case "PPP":
      return t2.date({ width: "long" });
    case "PPPP":
    default:
      return t2.date({ width: "full" });
  }
}
function be(e2, t2) {
  switch (e2) {
    case "p":
      return t2.time({ width: "short" });
    case "pp":
      return t2.time({ width: "medium" });
    case "ppp":
      return t2.time({ width: "long" });
    case "pppp":
    default:
      return t2.time({ width: "full" });
  }
}
var Ce = { p: be, P: function(e2, t2) {
  var r2, n2 = e2.match(/(P+)(p+)?/) || [], o2 = n2[1], a2 = n2[2];
  if (!a2)
    return ke(e2, t2);
  switch (o2) {
    case "P":
      r2 = t2.dateTime({ width: "short" });
      break;
    case "PP":
      r2 = t2.dateTime({ width: "medium" });
      break;
    case "PPP":
      r2 = t2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      r2 = t2.dateTime({ width: "full" });
  }
  return r2.replace("{{date}}", ke(o2, t2)).replace("{{time}}", be(a2, t2));
} }, Se = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function _e(e2) {
  var t2 = e2 ? typeof e2 == "string" || e2 instanceof String ? parseISO(e2) : toDate(e2) : new Date();
  return Pe(t2) ? t2 : null;
}
function Me(e2, t2, r2, n2, o2) {
  var a2 = null, s2 = Ue(r2) || Ue(qe()), i2 = true;
  return Array.isArray(t2) ? (t2.forEach(function(t3) {
    var p2 = parse3(e2, t3, new Date(), { locale: s2 });
    n2 && (i2 = Pe(p2, o2) && e2 === Ee(p2, t3, r2)), Pe(p2, o2) && i2 && (a2 = p2);
  }), a2) : (a2 = parse3(e2, t2, new Date(), { locale: s2 }), n2 ? i2 = Pe(a2) && e2 === Ee(a2, t2, r2) : Pe(a2) || (t2 = t2.match(Se).map(function(e3) {
    var t3 = e3[0];
    return t3 === "p" || t3 === "P" ? s2 ? (0, Ce[t3])(e3, s2.formatLong) : t3 : e3;
  }).join(""), e2.length > 0 && (a2 = parse3(e2, t2.slice(0, e2.length), new Date())), Pe(a2) || (a2 = new Date(e2))), Pe(a2) && i2 ? a2 : null);
}
function Pe(e2, t2) {
  return t2 = t2 || new Date("1/1/1000"), isValid(e2) && !isBefore(e2, t2);
}
function Ee(e2, t2, r2) {
  if (r2 === "en")
    return format(e2, t2, { awareOfUnicodeTokens: true });
  var n2 = Ue(r2);
  return r2 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), !n2 && qe() && Ue(qe()) && (n2 = Ue(qe())), format(e2, t2, { locale: n2 || null, awareOfUnicodeTokens: true });
}
function Ne(e2, t2) {
  var r2 = t2.dateFormat, n2 = t2.locale;
  return e2 && Ee(e2, Array.isArray(r2) ? r2[0] : r2, n2) || "";
}
function xe(e2, t2) {
  var r2 = t2.hour, n2 = r2 === void 0 ? 0 : r2, o2 = t2.minute, a2 = o2 === void 0 ? 0 : o2, s2 = t2.second;
  return setHours(setMinutes(setSeconds(e2, s2 === void 0 ? 0 : s2), a2), n2);
}
function Ye(e2, t2) {
  var r2 = t2 && Ue(t2) || qe() && Ue(qe());
  return getISOWeek(e2, r2 ? { locale: r2 } : null);
}
function Oe(e2, t2) {
  return Ee(e2, "ddd", t2);
}
function Ie(e2) {
  return startOfDay(e2);
}
function Te(e2, t2, r2) {
  var n2 = Ue(t2 || qe());
  return startOfWeek(e2, { locale: n2, weekStartsOn: r2 });
}
function Le(e2) {
  return startOfMonth(e2);
}
function Re(e2) {
  return startOfYear(e2);
}
function Fe(e2) {
  return startOfQuarter(e2);
}
function Ae(e2, t2) {
  return e2 && t2 ? isSameYear(e2, t2) : !e2 && !t2;
}
function Be(e2, t2) {
  return e2 && t2 ? isSameMonth(e2, t2) : !e2 && !t2;
}
function Ke(e2, t2) {
  return e2 && t2 ? isSameQuarter(e2, t2) : !e2 && !t2;
}
function We(e2, t2) {
  return e2 && t2 ? isSameDay(e2, t2) : !e2 && !t2;
}
function je(e2, t2) {
  return e2 && t2 ? isEqual(e2, t2) : !e2 && !t2;
}
function He(e2, t2, r2) {
  var n2, o2 = startOfDay(t2), a2 = endOfDay(r2);
  try {
    n2 = isWithinInterval(e2, { start: o2, end: a2 });
  } catch (e3) {
    n2 = false;
  }
  return n2;
}
function qe() {
  return (typeof window != "undefined" ? window : globalThis).__localeId__;
}
function Ue(e2) {
  if (typeof e2 == "string") {
    var t2 = typeof window != "undefined" ? window : globalThis;
    return t2.__localeData__ ? t2.__localeData__[e2] : null;
  }
  return e2;
}
function $e(e2, t2) {
  return Ee(setMonth(_e(), e2), "LLLL", t2);
}
function ze(e2, t2) {
  return Ee(setMonth(_e(), e2), "LLL", t2);
}
function Ge(e2, t2) {
  return Ee(setQuarter(_e(), e2), "QQQ", t2);
}
function Je(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.excludeDateIntervals, s2 = t2.includeDates, i2 = t2.includeDateIntervals, p2 = t2.filterDate;
  return ot(e2, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t3) {
    return We(e2, t3);
  }) || a2 && a2.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) || s2 && !s2.some(function(t3) {
    return We(e2, t3);
  }) || i2 && !i2.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) || p2 && !p2(_e(e2)) || false;
}
function Xe(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.excludeDates, n2 = t2.excludeDateIntervals;
  return n2 && n2.length > 0 ? n2.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) : r2 && r2.some(function(t3) {
    return We(e2, t3);
  }) || false;
}
function Ze(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.includeDates, s2 = t2.filterDate;
  return ot(e2, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t3) {
    return Be(e2, t3);
  }) || a2 && !a2.some(function(t3) {
    return Be(e2, t3);
  }) || s2 && !s2(_e(e2)) || false;
}
function et(e2, t2, r2, n2) {
  var o2 = getYear(e2), a2 = getMonth(e2), s2 = getYear(t2), i2 = getMonth(t2), p2 = getYear(n2);
  return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
}
function tt2(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.includeDates, s2 = t2.filterDate;
  return ot(e2, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t3) {
    return Ke(e2, t3);
  }) || a2 && !a2.some(function(t3) {
    return Ke(e2, t3);
  }) || s2 && !s2(_e(e2)) || false;
}
function rt(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = new Date(e2, 0, 1);
  return ot(o2, { minDate: r2, maxDate: n2 }) || false;
}
function nt(e2, t2, r2, n2) {
  var o2 = getYear(e2), a2 = getQuarter(e2), s2 = getYear(t2), i2 = getQuarter(t2), p2 = getYear(n2);
  return o2 === s2 && o2 === p2 ? a2 <= r2 && r2 <= i2 : o2 < s2 ? p2 === o2 && a2 <= r2 || p2 === s2 && i2 >= r2 || p2 < s2 && p2 > o2 : void 0;
}
function ot(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate;
  return r2 && differenceInCalendarDays(e2, r2) < 0 || n2 && differenceInCalendarDays(e2, n2) > 0;
}
function at(e2, t2) {
  return t2.some(function(t3) {
    return getHours(t3) === getHours(e2) && getMinutes(t3) === getMinutes(e2);
  });
}
function st(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.excludeTimes, n2 = t2.includeTimes, o2 = t2.filterTime;
  return r2 && at(e2, r2) || n2 && !at(e2, n2) || o2 && !o2(e2) || false;
}
function it(e2, t2) {
  var r2 = t2.minTime, n2 = t2.maxTime;
  if (!r2 || !n2)
    throw new Error("Both minTime and maxTime props required");
  var o2, a2 = _e(), s2 = setHours(setMinutes(a2, getMinutes(e2)), getHours(e2)), i2 = setHours(setMinutes(a2, getMinutes(r2)), getHours(r2)), p2 = setHours(setMinutes(a2, getMinutes(n2)), getHours(n2));
  try {
    o2 = !isWithinInterval(s2, { start: i2, end: p2 });
  } catch (e3) {
    o2 = false;
  }
  return o2;
}
function pt(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.includeDates, o2 = subMonths(e2, 1);
  return r2 && differenceInCalendarMonths(r2, o2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarMonths(e3, o2) > 0;
  }) || false;
}
function ct(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.maxDate, n2 = t2.includeDates, o2 = addMonths(e2, 1);
  return r2 && differenceInCalendarMonths(o2, r2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarMonths(o2, e3) > 0;
  }) || false;
}
function lt(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.includeDates, o2 = subYears(e2, 1);
  return r2 && differenceInCalendarYears(r2, o2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarYears(e3, o2) > 0;
  }) || false;
}
function dt(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t2.maxDate, n2 = t2.includeDates, o2 = addYears(e2, 1);
  return r2 && differenceInCalendarYears(o2, r2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarYears(o2, e3) > 0;
  }) || false;
}
function ut(e2) {
  var t2 = e2.minDate, r2 = e2.includeDates;
  if (r2 && t2) {
    var n2 = r2.filter(function(e3) {
      return differenceInCalendarDays(e3, t2) >= 0;
    });
    return min2(n2);
  }
  return r2 ? min2(r2) : t2;
}
function ht(e2) {
  var t2 = e2.maxDate, r2 = e2.includeDates;
  if (r2 && t2) {
    var n2 = r2.filter(function(e3) {
      return differenceInCalendarDays(e3, t2) <= 0;
    });
    return max2(n2);
  }
  return r2 ? max2(r2) : t2;
}
function mt() {
  for (var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o2 = 0, a2 = e2.length; o2 < a2; o2++) {
    var s2 = e2[o2];
    if (isDate(s2)) {
      var i2 = Ee(s2, "MM.dd.yyyy"), p2 = r2.get(i2) || [];
      p2.includes(t2) || (p2.push(t2), r2.set(i2, p2));
    } else if (ie(s2) === "object") {
      var c2 = Object.keys(s2), l2 = c2[0], d2 = s2[c2[0]];
      if (typeof l2 == "string" && d2.constructor === Array)
        for (var u2 = 0, h2 = d2.length; u2 < h2; u2++) {
          var m2 = Ee(d2[u2], "MM.dd.yyyy"), f2 = r2.get(m2) || [];
          f2.includes(l2) || (f2.push(l2), r2.set(m2, f2));
        }
    }
  }
  return r2;
}
function ft(e2, t2, r2, n2, o2) {
  for (var a2 = o2.length, p2 = [], c2 = 0; c2 < a2; c2++) {
    var l2 = addMinutes(addHours(e2, getHours(o2[c2])), getMinutes(o2[c2])), d2 = addMinutes(e2, (r2 + 1) * n2);
    isAfter(l2, t2) && isBefore(l2, d2) && p2.push(o2[c2]);
  }
  return p2;
}
function yt(e2) {
  return e2 < 10 ? "0".concat(e2) : "".concat(e2);
}
function vt(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12, r2 = Math.ceil(getYear(e2) / t2) * t2, n2 = r2 - (t2 - 1);
  return { startPeriod: n2, endPeriod: r2 };
}
function Dt(e2, t2, r2, n2) {
  for (var o2 = [], a2 = 0; a2 < 2 * t2 + 1; a2++) {
    var s2 = e2 + t2 - a2, i2 = true;
    r2 && (i2 = getYear(r2) <= s2), n2 && i2 && (i2 = getYear(n2) >= s2), i2 && o2.push(s2);
  }
  return o2;
}
var wt = onClickOutsideHOC(function(n2) {
  he(a2, e$3.Component);
  var o2 = De(a2);
  function a2(r2) {
    var n3;
    pe(this, a2), de(ye(n3 = o2.call(this, r2)), "renderOptions", function() {
      var t2 = n3.props.year, r3 = n3.state.yearsList.map(function(r4) {
        return e$3.createElement("div", { className: t2 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: r4, onClick: n3.onChange.bind(ye(n3), r4), "aria-selected": t2 === r4 ? "true" : void 0 }, t2 === r4 ? e$3.createElement("span", { className: "react-datepicker__year-option--selected" }, "\u2713") : "", r4);
      }), o3 = n3.props.minDate ? getYear(n3.props.minDate) : null, a3 = n3.props.maxDate ? getYear(n3.props.maxDate) : null;
      return a3 && n3.state.yearsList.find(function(e2) {
        return e2 === a3;
      }) || r3.unshift(e$3.createElement("div", { className: "react-datepicker__year-option", key: "upcoming", onClick: n3.incrementYears }, e$3.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }))), o3 && n3.state.yearsList.find(function(e2) {
        return e2 === o3;
      }) || r3.push(e$3.createElement("div", { className: "react-datepicker__year-option", key: "previous", onClick: n3.decrementYears }, e$3.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }))), r3;
    }), de(ye(n3), "onChange", function(e2) {
      n3.props.onChange(e2);
    }), de(ye(n3), "handleClickOutside", function() {
      n3.props.onCancel();
    }), de(ye(n3), "shiftYears", function(e2) {
      var t2 = n3.state.yearsList.map(function(t3) {
        return t3 + e2;
      });
      n3.setState({ yearsList: t2 });
    }), de(ye(n3), "incrementYears", function() {
      return n3.shiftYears(1);
    }), de(ye(n3), "decrementYears", function() {
      return n3.shiftYears(-1);
    });
    var s2 = r2.yearDropdownItemNumber, i2 = r2.scrollableYearDropdown, p2 = s2 || (i2 ? 10 : 5);
    return n3.state = { yearsList: Dt(n3.props.year, p2, n3.props.minDate, n3.props.maxDate) }, n3.dropdownRef = react.exports.createRef(), n3;
  }
  return le(a2, [{ key: "componentDidMount", value: function() {
    var e2 = this.dropdownRef.current;
    e2 && (e2.scrollTop = e2.scrollHeight / 2 - e2.clientHeight / 2);
  } }, { key: "render", value: function() {
    var t2 = r({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
    return e$3.createElement("div", { className: t2, ref: this.dropdownRef }, this.renderOptions());
  } }]), a2;
}()), gt = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
      a2[s2] = arguments[s2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), de(ye(t3), "renderSelectOptions", function() {
      for (var r3 = t3.props.minDate ? getYear(t3.props.minDate) : 1900, n3 = t3.props.maxDate ? getYear(t3.props.maxDate) : 2100, o3 = [], a3 = r3; a3 <= n3; a3++)
        o3.push(e$3.createElement("option", { key: a3, value: a3 }, a3));
      return o3;
    }), de(ye(t3), "onSelectChange", function(e2) {
      t3.onChange(e2.target.value);
    }), de(ye(t3), "renderSelectMode", function() {
      return e$3.createElement("select", { value: t3.props.year, className: "react-datepicker__year-select", onChange: t3.onSelectChange }, t3.renderSelectOptions());
    }), de(ye(t3), "renderReadView", function(r3) {
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(e2) {
        return t3.toggleDropdown(e2);
      } }, e$3.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, t3.props.year));
    }), de(ye(t3), "renderDropdown", function() {
      return e$3.createElement(wt, { key: "dropdown", year: t3.props.year, onChange: t3.onChange, onCancel: t3.toggleDropdown, minDate: t3.props.minDate, maxDate: t3.props.maxDate, scrollableYearDropdown: t3.props.scrollableYearDropdown, yearDropdownItemNumber: t3.props.yearDropdownItemNumber });
    }), de(ye(t3), "renderScrollMode", function() {
      var e2 = t3.state.dropdownVisible, r3 = [t3.renderReadView(!e2)];
      return e2 && r3.unshift(t3.renderDropdown()), r3;
    }), de(ye(t3), "onChange", function(e2) {
      t3.toggleDropdown(), e2 !== t3.props.year && t3.props.onChange(e2);
    }), de(ye(t3), "toggleDropdown", function(e2) {
      t3.setState({ dropdownVisible: !t3.state.dropdownVisible }, function() {
        t3.props.adjustDateOnChange && t3.handleYearChange(t3.props.date, e2);
      });
    }), de(ye(t3), "handleYearChange", function(e2, r3) {
      t3.onSelect(e2, r3), t3.setOpen();
    }), de(ye(t3), "onSelect", function(e2, r3) {
      t3.props.onSelect && t3.props.onSelect(e2, r3);
    }), de(ye(t3), "setOpen", function() {
      t3.props.setOpen && t3.props.setOpen(true);
    }), t3;
  }
  return le(n2, [{ key: "render", value: function() {
    var t3;
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode();
        break;
      case "select":
        t3 = this.renderSelectMode();
    }
    return e$3.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}(), kt = onClickOutsideHOC(function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
      a2[s2] = arguments[s2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "isSelectedMonth", function(e2) {
      return t3.props.month === e2;
    }), de(ye(t3), "renderOptions", function() {
      return t3.props.monthNames.map(function(r3, n3) {
        return e$3.createElement("div", { className: t3.isSelectedMonth(n3) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: r3, onClick: t3.onChange.bind(ye(t3), n3), "aria-selected": t3.isSelectedMonth(n3) ? "true" : void 0 }, t3.isSelectedMonth(n3) ? e$3.createElement("span", { className: "react-datepicker__month-option--selected" }, "\u2713") : "", r3);
      });
    }), de(ye(t3), "onChange", function(e2) {
      return t3.props.onChange(e2);
    }), de(ye(t3), "handleClickOutside", function() {
      return t3.props.onCancel();
    }), t3;
  }
  return le(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__month-dropdown" }, this.renderOptions());
  } }]), n2;
}()), bt = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
      a2[s2] = arguments[s2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), de(ye(t3), "renderSelectOptions", function(t4) {
      return t4.map(function(t5, r3) {
        return e$3.createElement("option", { key: r3, value: r3 }, t5);
      });
    }), de(ye(t3), "renderSelectMode", function(r3) {
      return e$3.createElement("select", { value: t3.props.month, className: "react-datepicker__month-select", onChange: function(e2) {
        return t3.onChange(e2.target.value);
      } }, t3.renderSelectOptions(r3));
    }), de(ye(t3), "renderReadView", function(r3, n3) {
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: t3.toggleDropdown }, e$3.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, n3[t3.props.month]));
    }), de(ye(t3), "renderDropdown", function(r3) {
      return e$3.createElement(kt, { key: "dropdown", month: t3.props.month, monthNames: r3, onChange: t3.onChange, onCancel: t3.toggleDropdown });
    }), de(ye(t3), "renderScrollMode", function(e2) {
      var r3 = t3.state.dropdownVisible, n3 = [t3.renderReadView(!r3, e2)];
      return r3 && n3.unshift(t3.renderDropdown(e2)), n3;
    }), de(ye(t3), "onChange", function(e2) {
      t3.toggleDropdown(), e2 !== t3.props.month && t3.props.onChange(e2);
    }), de(ye(t3), "toggleDropdown", function() {
      return t3.setState({ dropdownVisible: !t3.state.dropdownVisible });
    }), t3;
  }
  return le(n2, [{ key: "render", value: function() {
    var t3, r3 = this, n3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e2) {
      return ze(e2, r3.props.locale);
    } : function(e2) {
      return $e(e2, r3.props.locale);
    });
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode(n3);
        break;
      case "select":
        t3 = this.renderSelectMode(n3);
    }
    return e$3.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}();
function Ct(e2, t2) {
  for (var r2 = [], n2 = Le(e2), o2 = Le(t2); !isAfter(n2, o2); )
    r2.push(_e(n2)), n2 = addMonths(n2, 1);
  return r2;
}
var St = onClickOutsideHOC(function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2(t3) {
    var r2;
    return pe(this, o2), de(ye(r2 = n2.call(this, t3)), "renderOptions", function() {
      return r2.state.monthYearsList.map(function(t4) {
        var n3 = getTime(t4), o3 = Ae(r2.props.date, t4) && Be(r2.props.date, t4);
        return e$3.createElement("div", { className: o3 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: n3, onClick: r2.onChange.bind(ye(r2), n3), "aria-selected": o3 ? "true" : void 0 }, o3 ? e$3.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "\u2713") : "", Ee(t4, r2.props.dateFormat, r2.props.locale));
      });
    }), de(ye(r2), "onChange", function(e2) {
      return r2.props.onChange(e2);
    }), de(ye(r2), "handleClickOutside", function() {
      r2.props.onCancel();
    }), r2.state = { monthYearsList: Ct(r2.props.minDate, r2.props.maxDate) }, r2;
  }
  return le(o2, [{ key: "render", value: function() {
    var t3 = r({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
    return e$3.createElement("div", { className: t3 }, this.renderOptions());
  } }]), o2;
}()), _t = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
      a2[s2] = arguments[s2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), de(ye(t3), "renderSelectOptions", function() {
      for (var r3 = Le(t3.props.minDate), n3 = Le(t3.props.maxDate), o3 = []; !isAfter(r3, n3); ) {
        var a3 = getTime(r3);
        o3.push(e$3.createElement("option", { key: a3, value: a3 }, Ee(r3, t3.props.dateFormat, t3.props.locale))), r3 = addMonths(r3, 1);
      }
      return o3;
    }), de(ye(t3), "onSelectChange", function(e2) {
      t3.onChange(e2.target.value);
    }), de(ye(t3), "renderSelectMode", function() {
      return e$3.createElement("select", { value: getTime(Le(t3.props.date)), className: "react-datepicker__month-year-select", onChange: t3.onSelectChange }, t3.renderSelectOptions());
    }), de(ye(t3), "renderReadView", function(r3) {
      var n3 = Ee(t3.props.date, t3.props.dateFormat, t3.props.locale);
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: function(e2) {
        return t3.toggleDropdown(e2);
      } }, e$3.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, n3));
    }), de(ye(t3), "renderDropdown", function() {
      return e$3.createElement(St, { key: "dropdown", date: t3.props.date, dateFormat: t3.props.dateFormat, onChange: t3.onChange, onCancel: t3.toggleDropdown, minDate: t3.props.minDate, maxDate: t3.props.maxDate, scrollableMonthYearDropdown: t3.props.scrollableMonthYearDropdown, locale: t3.props.locale });
    }), de(ye(t3), "renderScrollMode", function() {
      var e2 = t3.state.dropdownVisible, r3 = [t3.renderReadView(!e2)];
      return e2 && r3.unshift(t3.renderDropdown()), r3;
    }), de(ye(t3), "onChange", function(e2) {
      t3.toggleDropdown();
      var r3 = _e(parseInt(e2));
      Ae(t3.props.date, r3) && Be(t3.props.date, r3) || t3.props.onChange(r3);
    }), de(ye(t3), "toggleDropdown", function() {
      return t3.setState({ dropdownVisible: !t3.state.dropdownVisible });
    }), t3;
  }
  return le(n2, [{ key: "render", value: function() {
    var t3;
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode();
        break;
      case "select":
        t3 = this.renderSelectMode();
    }
    return e$3.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}(), Mt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2() {
    var t3;
    pe(this, o2);
    for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
      s2[i2] = arguments[i2];
    return de(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "dayEl", e$3.createRef()), de(ye(t3), "handleClick", function(e2) {
      !t3.isDisabled() && t3.props.onClick && t3.props.onClick(e2);
    }), de(ye(t3), "handleMouseEnter", function(e2) {
      !t3.isDisabled() && t3.props.onMouseEnter && t3.props.onMouseEnter(e2);
    }), de(ye(t3), "handleOnKeyDown", function(e2) {
      e2.key === " " && (e2.preventDefault(), e2.key = "Enter"), t3.props.handleOnKeyDown(e2);
    }), de(ye(t3), "isSameDay", function(e2) {
      return We(t3.props.day, e2);
    }), de(ye(t3), "isKeyboardSelected", function() {
      return !t3.props.disabledKeyboardNavigation && !t3.isSameDay(t3.props.selected) && t3.isSameDay(t3.props.preSelection);
    }), de(ye(t3), "isDisabled", function() {
      return Je(t3.props.day, t3.props);
    }), de(ye(t3), "isExcluded", function() {
      return Xe(t3.props.day, t3.props);
    }), de(ye(t3), "getHighLightedClass", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.highlightDates;
      if (!o3)
        return false;
      var a3 = Ee(n3, "MM.dd.yyyy");
      return o3.get(a3);
    }), de(ye(t3), "isInRange", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && He(r2, n3, o3);
    }), de(ye(t3), "isInSelectingRange", function() {
      var e2, r2 = t3.props, n3 = r2.day, o3 = r2.selectsStart, a3 = r2.selectsEnd, s3 = r2.selectsRange, i3 = r2.selectsDisabledDaysInRange, p2 = r2.startDate, c2 = r2.endDate, l2 = (e2 = t3.props.selectingDate) !== null && e2 !== void 0 ? e2 : t3.props.preSelection;
      return !(!(o3 || a3 || s3) || !l2 || !i3 && t3.isDisabled()) && (o3 && c2 && (isBefore(l2, c2) || je(l2, c2)) ? He(n3, l2, c2) : (a3 && p2 && (isAfter(l2, p2) || je(l2, p2)) || !(!s3 || !p2 || c2 || !isAfter(l2, p2) && !je(l2, p2))) && He(n3, p2, l2));
    }), de(ye(t3), "isSelectingRangeStart", function() {
      var e2;
      if (!t3.isInSelectingRange())
        return false;
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.selectsStart, s3 = (e2 = t3.props.selectingDate) !== null && e2 !== void 0 ? e2 : t3.props.preSelection;
      return We(n3, a3 ? s3 : o3);
    }), de(ye(t3), "isSelectingRangeEnd", function() {
      var e2;
      if (!t3.isInSelectingRange())
        return false;
      var r2 = t3.props, n3 = r2.day, o3 = r2.endDate, a3 = r2.selectsEnd, s3 = (e2 = t3.props.selectingDate) !== null && e2 !== void 0 ? e2 : t3.props.preSelection;
      return We(n3, a3 ? s3 : o3);
    }), de(ye(t3), "isRangeStart", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && We(n3, r2);
    }), de(ye(t3), "isRangeEnd", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && We(o3, r2);
    }), de(ye(t3), "isWeekend", function() {
      var e2 = getDay(t3.props.day);
      return e2 === 0 || e2 === 6;
    }), de(ye(t3), "isAfterMonth", function() {
      return t3.props.month !== void 0 && (t3.props.month + 1) % 12 === getMonth(t3.props.day);
    }), de(ye(t3), "isBeforeMonth", function() {
      return t3.props.month !== void 0 && (getMonth(t3.props.day) + 1) % 12 === t3.props.month;
    }), de(ye(t3), "isCurrentDay", function() {
      return t3.isSameDay(_e());
    }), de(ye(t3), "isSelected", function() {
      return t3.isSameDay(t3.props.selected);
    }), de(ye(t3), "getClassNames", function(e2) {
      var n3 = t3.props.dayClassName ? t3.props.dayClassName(e2) : void 0;
      return r("react-datepicker__day", n3, "react-datepicker__day--" + Oe(t3.props.day), { "react-datepicker__day--disabled": t3.isDisabled(), "react-datepicker__day--excluded": t3.isExcluded(), "react-datepicker__day--selected": t3.isSelected(), "react-datepicker__day--keyboard-selected": t3.isKeyboardSelected(), "react-datepicker__day--range-start": t3.isRangeStart(), "react-datepicker__day--range-end": t3.isRangeEnd(), "react-datepicker__day--in-range": t3.isInRange(), "react-datepicker__day--in-selecting-range": t3.isInSelectingRange(), "react-datepicker__day--selecting-range-start": t3.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": t3.isSelectingRangeEnd(), "react-datepicker__day--today": t3.isCurrentDay(), "react-datepicker__day--weekend": t3.isWeekend(), "react-datepicker__day--outside-month": t3.isAfterMonth() || t3.isBeforeMonth() }, t3.getHighLightedClass("react-datepicker__day--highlighted"));
    }), de(ye(t3), "getAriaLabel", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.ariaLabelPrefixWhenEnabled, o3 = n3 === void 0 ? "Choose" : n3, a3 = e2.ariaLabelPrefixWhenDisabled, s3 = a3 === void 0 ? "Not available" : a3, i3 = t3.isDisabled() || t3.isExcluded() ? s3 : o3;
      return "".concat(i3, " ").concat(Ee(r2, "PPPP", t3.props.locale));
    }), de(ye(t3), "getTabIndex", function(e2, r2) {
      var n3 = e2 || t3.props.selected, o3 = r2 || t3.props.preSelection;
      return t3.isKeyboardSelected() || t3.isSameDay(n3) && We(o3, n3) ? 0 : -1;
    }), de(ye(t3), "handleFocusDay", function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r2 = false;
      t3.getTabIndex() === 0 && !e2.isInputFocused && t3.isSameDay(t3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r2 = true), t3.props.inline && !t3.props.shouldFocusDayInline && (r2 = false), t3.props.containerRef && t3.props.containerRef.current && t3.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (r2 = true)), r2 && t3.dayEl.current.focus({ preventScroll: true });
    }), de(ye(t3), "renderDayContents", function() {
      return t3.props.monthShowsDuplicateDaysEnd && t3.isAfterMonth() || t3.props.monthShowsDuplicateDaysStart && t3.isBeforeMonth() ? null : t3.props.renderDayContents ? t3.props.renderDayContents(getDate(t3.props.day), t3.props.day) : getDate(t3.props.day);
    }), de(ye(t3), "render", function() {
      return e$3.createElement("div", { ref: t3.dayEl, className: t3.getClassNames(t3.props.day), onKeyDown: t3.handleOnKeyDown, onClick: t3.handleClick, onMouseEnter: t3.handleMouseEnter, tabIndex: t3.getTabIndex(), "aria-label": t3.getAriaLabel(), role: "option", "aria-disabled": t3.isDisabled(), "aria-current": t3.isCurrentDay() ? "date" : void 0, "aria-selected": t3.isSelected() }, t3.renderDayContents());
    }), t3;
  }
  return le(o2, [{ key: "componentDidMount", value: function() {
    this.handleFocusDay();
  } }, { key: "componentDidUpdate", value: function(e2) {
    this.handleFocusDay(e2);
  } }]), o2;
}(), Pt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2() {
    var e2;
    pe(this, o2);
    for (var t3 = arguments.length, r2 = new Array(t3), a2 = 0; a2 < t3; a2++)
      r2[a2] = arguments[a2];
    return de(ye(e2 = n2.call.apply(n2, [this].concat(r2))), "handleClick", function(t4) {
      e2.props.onClick && e2.props.onClick(t4);
    }), e2;
  }
  return le(o2, [{ key: "render", value: function() {
    var t3 = this.props, n3 = t3.weekNumber, o3 = t3.ariaLabelPrefix, a2 = o3 === void 0 ? "week " : o3, s2 = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!t3.onClick };
    return e$3.createElement("div", { className: r(s2), "aria-label": "".concat(a2, " ").concat(this.props.weekNumber), onClick: this.handleClick }, n3);
  } }]), o2;
}(), Et = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s2 = 0; s2 < o2; s2++)
      a2[s2] = arguments[s2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "handleDayClick", function(e2, r3) {
      t3.props.onDayClick && t3.props.onDayClick(e2, r3);
    }), de(ye(t3), "handleDayMouseEnter", function(e2) {
      t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e2);
    }), de(ye(t3), "handleWeekClick", function(e2, r3, n3) {
      typeof t3.props.onWeekSelect == "function" && t3.props.onWeekSelect(e2, r3, n3), t3.props.shouldCloseOnSelect && t3.props.setOpen(false);
    }), de(ye(t3), "formatWeekNumber", function(e2) {
      return t3.props.formatWeekNumber ? t3.props.formatWeekNumber(e2) : Ye(e2);
    }), de(ye(t3), "renderDays", function() {
      var r3 = Te(t3.props.day, t3.props.locale, t3.props.calendarStartDay), n3 = [], o3 = t3.formatWeekNumber(r3);
      if (t3.props.showWeekNumber) {
        var a3 = t3.props.onWeekSelect ? t3.handleWeekClick.bind(ye(t3), r3, o3) : void 0;
        n3.push(e$3.createElement(Pt, { key: "W", weekNumber: o3, onClick: a3, ariaLabelPrefix: t3.props.ariaLabelPrefix }));
      }
      return n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
        var o4 = addDays(r3, n4);
        return e$3.createElement(Mt, { ariaLabelPrefixWhenEnabled: t3.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: t3.props.disabledDayAriaLabelPrefix, key: o4.valueOf(), day: o4, month: t3.props.month, onClick: t3.handleDayClick.bind(ye(t3), o4), onMouseEnter: t3.handleDayMouseEnter.bind(ye(t3), o4), minDate: t3.props.minDate, maxDate: t3.props.maxDate, excludeDates: t3.props.excludeDates, excludeDateIntervals: t3.props.excludeDateIntervals, includeDates: t3.props.includeDates, includeDateIntervals: t3.props.includeDateIntervals, highlightDates: t3.props.highlightDates, selectingDate: t3.props.selectingDate, filterDate: t3.props.filterDate, preSelection: t3.props.preSelection, selected: t3.props.selected, selectsStart: t3.props.selectsStart, selectsEnd: t3.props.selectsEnd, selectsRange: t3.props.selectsRange, selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange, startDate: t3.props.startDate, endDate: t3.props.endDate, dayClassName: t3.props.dayClassName, renderDayContents: t3.props.renderDayContents, disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation, handleOnKeyDown: t3.props.handleOnKeyDown, isInputFocused: t3.props.isInputFocused, containerRef: t3.props.containerRef, inline: t3.props.inline, shouldFocusDayInline: t3.props.shouldFocusDayInline, monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart, locale: t3.props.locale });
      }));
    }), t3;
  }
  return le(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__week" }, this.renderDays());
  } }], [{ key: "defaultProps", get: function() {
    return { shouldCloseOnSelect: true };
  } }]), n2;
}(), Nt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2() {
    var t3;
    pe(this, o2);
    for (var a2 = arguments.length, s2 = new Array(a2), i2 = 0; i2 < a2; i2++)
      s2[i2] = arguments[i2];
    return de(ye(t3 = n2.call.apply(n2, [this].concat(s2))), "MONTH_REFS", we(Array(12)).map(function() {
      return e$3.createRef();
    })), de(ye(t3), "isDisabled", function(e2) {
      return Je(e2, t3.props);
    }), de(ye(t3), "isExcluded", function(e2) {
      return Xe(e2, t3.props);
    }), de(ye(t3), "handleDayClick", function(e2, r2) {
      t3.props.onDayClick && t3.props.onDayClick(e2, r2, t3.props.orderInDisplay);
    }), de(ye(t3), "handleDayMouseEnter", function(e2) {
      t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e2);
    }), de(ye(t3), "handleMouseLeave", function() {
      t3.props.onMouseLeave && t3.props.onMouseLeave();
    }), de(ye(t3), "isRangeStartMonth", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && Be(setMonth(n3, e2), o3);
    }), de(ye(t3), "isRangeStartQuarter", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && Ke(setQuarter(n3, e2), o3);
    }), de(ye(t3), "isRangeEndMonth", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && Be(setMonth(n3, e2), a3);
    }), de(ye(t3), "isRangeEndQuarter", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && Ke(setQuarter(n3, e2), a3);
    }), de(ye(t3), "isWeekInMonth", function(e2) {
      var r2 = t3.props.day, n3 = addDays(e2, 6);
      return Be(e2, r2) || Be(n3, r2);
    }), de(ye(t3), "isCurrentMonth", function(e2, t4) {
      return getYear(e2) === getYear(_e()) && t4 === getMonth(_e());
    }), de(ye(t3), "isSelectedMonth", function(e2, t4, r2) {
      return getMonth(e2) === t4 && getYear(e2) === getYear(r2);
    }), de(ye(t3), "isSelectedQuarter", function(e2, t4, r2) {
      return getQuarter(e2) === t4 && getYear(e2) === getYear(r2);
    }), de(ye(t3), "renderWeeks", function() {
      for (var r2 = [], n3 = t3.props.fixedHeight, o3 = 0, a3 = false, s3 = Te(Le(t3.props.day), t3.props.locale, t3.props.calendarStartDay); r2.push(e$3.createElement(Et, { ariaLabelPrefix: t3.props.weekAriaLabelPrefix, chooseDayAriaLabelPrefix: t3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: t3.props.disabledDayAriaLabelPrefix, key: o3, day: s3, month: getMonth(t3.props.day), onDayClick: t3.handleDayClick, onDayMouseEnter: t3.handleDayMouseEnter, onWeekSelect: t3.props.onWeekSelect, formatWeekNumber: t3.props.formatWeekNumber, locale: t3.props.locale, minDate: t3.props.minDate, maxDate: t3.props.maxDate, excludeDates: t3.props.excludeDates, excludeDateIntervals: t3.props.excludeDateIntervals, includeDates: t3.props.includeDates, includeDateIntervals: t3.props.includeDateIntervals, inline: t3.props.inline, shouldFocusDayInline: t3.props.shouldFocusDayInline, highlightDates: t3.props.highlightDates, selectingDate: t3.props.selectingDate, filterDate: t3.props.filterDate, preSelection: t3.props.preSelection, selected: t3.props.selected, selectsStart: t3.props.selectsStart, selectsEnd: t3.props.selectsEnd, selectsRange: t3.props.selectsRange, selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange, showWeekNumber: t3.props.showWeekNumbers, startDate: t3.props.startDate, endDate: t3.props.endDate, dayClassName: t3.props.dayClassName, setOpen: t3.props.setOpen, shouldCloseOnSelect: t3.props.shouldCloseOnSelect, disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation, renderDayContents: t3.props.renderDayContents, handleOnKeyDown: t3.props.handleOnKeyDown, isInputFocused: t3.props.isInputFocused, containerRef: t3.props.containerRef, calendarStartDay: t3.props.calendarStartDay, monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart })), !a3; ) {
        o3++, s3 = addWeeks(s3, 1);
        var i3 = n3 && o3 >= 6, p2 = !n3 && !t3.isWeekInMonth(s3);
        if (i3 || p2) {
          if (!t3.props.peekNextMonth)
            break;
          a3 = true;
        }
      }
      return r2;
    }), de(ye(t3), "onMonthClick", function(e2, r2) {
      t3.handleDayClick(Le(setMonth(t3.props.day, r2)), e2);
    }), de(ye(t3), "handleMonthNavigation", function(e2, r2) {
      t3.isDisabled(r2) || t3.isExcluded(r2) || (t3.props.setPreSelection(r2), t3.MONTH_REFS[e2].current && t3.MONTH_REFS[e2].current.focus());
    }), de(ye(t3), "onMonthKeyDown", function(e2, r2) {
      var n3 = e2.key;
      if (!t3.props.disabledKeyboardNavigation)
        switch (n3) {
          case "Enter":
            t3.onMonthClick(e2, r2), t3.props.setPreSelection(t3.props.selected);
            break;
          case "ArrowRight":
            t3.handleMonthNavigation(r2 === 11 ? 0 : r2 + 1, addMonths(t3.props.preSelection, 1));
            break;
          case "ArrowLeft":
            t3.handleMonthNavigation(r2 === 0 ? 11 : r2 - 1, subMonths(t3.props.preSelection, 1));
        }
    }), de(ye(t3), "onQuarterClick", function(e2, r2) {
      t3.handleDayClick(Fe(setQuarter(t3.props.day, r2)), e2);
    }), de(ye(t3), "getMonthClassNames", function(e2) {
      var n3 = t3.props, o3 = n3.day, a3 = n3.startDate, s3 = n3.endDate, i3 = n3.selected, p2 = n3.minDate, c2 = n3.maxDate, l2 = n3.preSelection, d2 = n3.monthClassName, u2 = d2 ? d2(o3) : void 0;
      return r("react-datepicker__month-text", "react-datepicker__month-".concat(e2), u2, { "react-datepicker__month--disabled": (p2 || c2) && Ze(setMonth(o3, e2), t3.props), "react-datepicker__month--selected": t3.isSelectedMonth(o3, e2, i3), "react-datepicker__month-text--keyboard-selected": getMonth(l2) === e2, "react-datepicker__month--in-range": et(a3, s3, e2, o3), "react-datepicker__month--range-start": t3.isRangeStartMonth(e2), "react-datepicker__month--range-end": t3.isRangeEndMonth(e2), "react-datepicker__month-text--today": t3.isCurrentMonth(o3, e2) });
    }), de(ye(t3), "getTabIndex", function(e2) {
      var r2 = getMonth(t3.props.preSelection);
      return t3.props.disabledKeyboardNavigation || e2 !== r2 ? "-1" : "0";
    }), de(ye(t3), "getAriaLabel", function(e2) {
      var r2 = t3.props, n3 = r2.ariaLabelPrefix, o3 = n3 === void 0 ? "Choose" : n3, a3 = r2.disabledDayAriaLabelPrefix, s3 = a3 === void 0 ? "Not available" : a3, i3 = r2.day, p2 = setMonth(i3, e2), c2 = t3.isDisabled(p2) || t3.isExcluded(p2) ? s3 : o3;
      return "".concat(c2, " ").concat(Ee(p2, "MMMM yyyy"));
    }), de(ye(t3), "getQuarterClassNames", function(e2) {
      var n3 = t3.props, o3 = n3.day, a3 = n3.startDate, s3 = n3.endDate, i3 = n3.selected, p2 = n3.minDate, c2 = n3.maxDate;
      return r("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e2), { "react-datepicker__quarter--disabled": (p2 || c2) && tt2(setQuarter(o3, e2), t3.props), "react-datepicker__quarter--selected": t3.isSelectedQuarter(o3, e2, i3), "react-datepicker__quarter--in-range": nt(a3, s3, e2, o3), "react-datepicker__quarter--range-start": t3.isRangeStartQuarter(e2), "react-datepicker__quarter--range-end": t3.isRangeEndQuarter(e2) });
    }), de(ye(t3), "renderMonths", function() {
      var r2 = t3.props, n3 = r2.showFullMonthYearPicker, o3 = r2.showTwoColumnMonthYearPicker, a3 = r2.showFourColumnMonthYearPicker, s3 = r2.locale, i3 = r2.day, p2 = r2.selected;
      return (a3 ? [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]] : o3 ? [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]] : [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]).map(function(r3, o4) {
        return e$3.createElement("div", { className: "react-datepicker__month-wrapper", key: o4 }, r3.map(function(r4, o5) {
          return e$3.createElement("div", { ref: t3.MONTH_REFS[r4], key: o5, onClick: function(e2) {
            t3.onMonthClick(e2, r4);
          }, onKeyDown: function(e2) {
            t3.onMonthKeyDown(e2, r4);
          }, tabIndex: t3.getTabIndex(r4), className: t3.getMonthClassNames(r4), role: "option", "aria-label": t3.getAriaLabel(r4), "aria-current": t3.isCurrentMonth(i3, r4) ? "date" : void 0, "aria-selected": t3.isSelectedMonth(i3, r4, p2) }, n3 ? $e(r4, s3) : ze(r4, s3));
        }));
      });
    }), de(ye(t3), "renderQuarters", function() {
      var r2 = t3.props, n3 = r2.day, o3 = r2.selected;
      return e$3.createElement("div", { className: "react-datepicker__quarter-wrapper" }, [1, 2, 3, 4].map(function(r3, a3) {
        return e$3.createElement("div", { key: a3, role: "option", onClick: function(e2) {
          t3.onQuarterClick(e2, r3);
        }, className: t3.getQuarterClassNames(r3), "aria-selected": t3.isSelectedQuarter(n3, r3, o3) }, Ge(r3, t3.props.locale));
      }));
    }), de(ye(t3), "getClassNames", function() {
      var e2 = t3.props;
      e2.day;
      var n3 = e2.selectingDate, o3 = e2.selectsStart, a3 = e2.selectsEnd, s3 = e2.showMonthYearPicker, i3 = e2.showQuarterYearPicker;
      return r("react-datepicker__month", { "react-datepicker__month--selecting-range": n3 && (o3 || a3) }, { "react-datepicker__monthPicker": s3 }, { "react-datepicker__quarterPicker": i3 });
    }), t3;
  }
  return le(o2, [{ key: "render", value: function() {
    var t3 = this.props, r2 = t3.showMonthYearPicker, n3 = t3.showQuarterYearPicker, o3 = t3.day, a2 = t3.ariaLabelPrefix, s2 = a2 === void 0 ? "month " : a2;
    return e$3.createElement("div", { className: this.getClassNames(), onMouseLeave: this.handleMouseLeave, "aria-label": "".concat(s2, " ").concat(Ee(o3, "yyyy-MM")), role: "listbox" }, r2 ? this.renderMonths() : n3 ? this.renderQuarters() : this.renderWeeks());
  } }]), o2;
}(), xt = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2() {
    var t3;
    pe(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), i2 = 0; i2 < o2; i2++)
      a2[i2] = arguments[i2];
    return de(ye(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { height: null }), de(ye(t3), "handleClick", function(e2) {
      (t3.props.minTime || t3.props.maxTime) && it(e2, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st(e2, t3.props) || t3.props.onChange(e2);
    }), de(ye(t3), "isSelectedTime", function(e2, r3, n3) {
      return t3.props.selected && r3 === getHours(e2) && n3 === getMinutes(e2);
    }), de(ye(t3), "liClasses", function(e2, r3, n3) {
      var o3 = ["react-datepicker__time-list-item", t3.props.timeClassName ? t3.props.timeClassName(e2, r3, n3) : void 0];
      return t3.isSelectedTime(e2, r3, n3) && o3.push("react-datepicker__time-list-item--selected"), ((t3.props.minTime || t3.props.maxTime) && it(e2, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && st(e2, t3.props)) && o3.push("react-datepicker__time-list-item--disabled"), t3.props.injectTimes && (60 * getHours(e2) + getMinutes(e2)) % t3.props.intervals != 0 && o3.push("react-datepicker__time-list-item--injected"), o3.join(" ");
    }), de(ye(t3), "handleOnKeyDown", function(e2, r3) {
      e2.key === " " && (e2.preventDefault(), e2.key = "Enter"), e2.key === "Enter" && t3.handleClick(r3), t3.props.handleOnKeyDown(e2);
    }), de(ye(t3), "renderTimes", function() {
      for (var r3 = [], n3 = t3.props.format ? t3.props.format : "p", o3 = t3.props.intervals, a3 = Ie(_e(t3.props.selected)), i3 = 1440 / o3, p2 = t3.props.injectTimes && t3.props.injectTimes.sort(function(e2, t4) {
        return e2 - t4;
      }), c2 = t3.props.selected || t3.props.openToDate || _e(), l2 = getHours(c2), d2 = getMinutes(c2), u2 = setHours(setMinutes(a3, d2), l2), h2 = 0; h2 < i3; h2++) {
        var m2 = addMinutes(a3, h2 * o3);
        if (r3.push(m2), p2) {
          var f2 = ft(a3, m2, h2, o3, p2);
          r3 = r3.concat(f2);
        }
      }
      return r3.map(function(r4, o4) {
        return e$3.createElement("li", { key: o4, onClick: t3.handleClick.bind(ye(t3), r4), className: t3.liClasses(r4, l2, d2), ref: function(e2) {
          (isBefore(r4, u2) || je(r4, u2)) && (t3.centerLi = e2);
        }, onKeyDown: function(e2) {
          t3.handleOnKeyDown(e2, r4);
        }, tabIndex: "0", "aria-selected": t3.isSelectedTime(r4, l2, d2) ? "true" : void 0 }, Ee(r4, n3, t3.props.locale));
      });
    }), t3;
  }
  return le(n2, [{ key: "componentDidMount", value: function() {
    this.list.scrollTop = n2.calcCenterPosition(this.props.monthRef ? this.props.monthRef.clientHeight - this.header.clientHeight : this.list.clientHeight, this.centerLi), this.props.monthRef && this.header && this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
  } }, { key: "render", value: function() {
    var t3 = this, r3 = this.state.height;
    return e$3.createElement("div", { className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "") }, e$3.createElement("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(e2) {
      t3.header = e2;
    } }, e$3.createElement("div", { className: "react-datepicker-time__header" }, this.props.timeCaption)), e$3.createElement("div", { className: "react-datepicker__time" }, e$3.createElement("div", { className: "react-datepicker__time-box" }, e$3.createElement("ul", { className: "react-datepicker__time-list", ref: function(e2) {
      t3.list = e2;
    }, style: r3 ? { height: r3 } : {}, tabIndex: "0" }, this.renderTimes()))));
  } }], [{ key: "defaultProps", get: function() {
    return { intervals: 30, onTimeChange: function() {
    }, todayButton: null, timeCaption: "Time" };
  } }]), n2;
}();
de(xt, "calcCenterPosition", function(e2, t2) {
  return t2.offsetTop - (e2 / 2 - t2.clientHeight / 2);
});
var Yt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2(t3) {
    var a2;
    return pe(this, o2), de(ye(a2 = n2.call(this, t3)), "YEAR_REFS", we(Array(a2.props.yearItemNumber)).map(function() {
      return e$3.createRef();
    })), de(ye(a2), "isDisabled", function(e2) {
      return Je(e2, a2.props);
    }), de(ye(a2), "isExcluded", function(e2) {
      return Xe(e2, a2.props);
    }), de(ye(a2), "updateFocusOnPaginate", function(e2) {
      var t4 = function() {
        this.YEAR_REFS[e2].current.focus();
      }.bind(ye(a2));
      window.requestAnimationFrame(t4);
    }), de(ye(a2), "handleYearClick", function(e2, t4) {
      a2.props.onDayClick && a2.props.onDayClick(e2, t4);
    }), de(ye(a2), "handleYearNavigation", function(e2, t4) {
      var r2 = a2.props, n3 = r2.date, o3 = r2.yearItemNumber, s2 = vt(n3, o3).startPeriod;
      a2.isDisabled(t4) || a2.isExcluded(t4) || (a2.props.setPreSelection(t4), e2 - s2 == -1 ? a2.updateFocusOnPaginate(o3 - 1) : e2 - s2 === o3 ? a2.updateFocusOnPaginate(0) : a2.YEAR_REFS[e2 - s2].current.focus());
    }), de(ye(a2), "isSameDay", function(e2, t4) {
      return We(e2, t4);
    }), de(ye(a2), "isCurrentYear", function(e2) {
      return e2 === getYear(_e());
    }), de(ye(a2), "isKeyboardSelected", function(e2) {
      var t4 = Re(setYear(a2.props.date, e2));
      return !a2.props.disabledKeyboardNavigation && !a2.props.inline && !We(t4, Re(a2.props.selected)) && We(t4, Re(a2.props.preSelection));
    }), de(ye(a2), "onYearClick", function(e2, t4) {
      var r2 = a2.props.date;
      a2.handleYearClick(Re(setYear(r2, t4)), e2);
    }), de(ye(a2), "onYearKeyDown", function(e2, t4) {
      var r2 = e2.key;
      if (!a2.props.disabledKeyboardNavigation)
        switch (r2) {
          case "Enter":
            a2.onYearClick(e2, t4), a2.props.setPreSelection(a2.props.selected);
            break;
          case "ArrowRight":
            a2.handleYearNavigation(t4 + 1, addYears(a2.props.preSelection, 1));
            break;
          case "ArrowLeft":
            a2.handleYearNavigation(t4 - 1, subYears(a2.props.preSelection, 1));
        }
    }), de(ye(a2), "getYearClassNames", function(e2) {
      var t4 = a2.props, n3 = t4.minDate, o3 = t4.maxDate, s2 = t4.selected;
      return r("react-datepicker__year-text", { "react-datepicker__year-text--selected": e2 === getYear(s2), "react-datepicker__year-text--disabled": (n3 || o3) && rt(e2, a2.props), "react-datepicker__year-text--keyboard-selected": a2.isKeyboardSelected(e2), "react-datepicker__year-text--today": a2.isCurrentYear(e2) });
    }), de(ye(a2), "getYearTabIndex", function(e2) {
      return a2.props.disabledKeyboardNavigation ? "-1" : e2 === getYear(a2.props.preSelection) ? "0" : "-1";
    }), a2;
  }
  return le(o2, [{ key: "render", value: function() {
    for (var t3 = this, r2 = [], n3 = this.props, o3 = vt(n3.date, n3.yearItemNumber), a2 = o3.startPeriod, s2 = o3.endPeriod, i2 = function(n4) {
      r2.push(e$3.createElement("div", { ref: t3.YEAR_REFS[n4 - a2], onClick: function(e2) {
        t3.onYearClick(e2, n4);
      }, onKeyDown: function(e2) {
        t3.onYearKeyDown(e2, n4);
      }, tabIndex: t3.getYearTabIndex(n4), className: t3.getYearClassNames(n4), key: n4, "aria-current": t3.isCurrentYear(n4) ? "date" : void 0 }, n4));
    }, p2 = a2; p2 <= s2; p2++)
      i2(p2);
    return e$3.createElement("div", { className: "react-datepicker__year" }, e$3.createElement("div", { className: "react-datepicker__year-wrapper" }, r2));
  } }]), o2;
}(), Ot = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2(t3) {
    var o2;
    return pe(this, n2), de(ye(o2 = r2.call(this, t3)), "onTimeChange", function(e2) {
      o2.setState({ time: e2 });
      var t4 = new Date();
      t4.setHours(e2.split(":")[0]), t4.setMinutes(e2.split(":")[1]), o2.props.onChange(t4);
    }), de(ye(o2), "renderTimeInput", function() {
      var t4 = o2.state.time, r3 = o2.props, n3 = r3.date, a2 = r3.timeString, s2 = r3.customTimeInput;
      return s2 ? e$3.cloneElement(s2, { date: n3, value: t4, onChange: o2.onTimeChange }) : e$3.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", required: true, value: t4, onChange: function(e2) {
        o2.onTimeChange(e2.target.value || a2);
      } });
    }), o2.state = { time: o2.props.timeString }, o2;
  }
  return le(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__input-time-container" }, e$3.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel), e$3.createElement("div", { className: "react-datepicker-time__input-container" }, e$3.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())));
  } }], [{ key: "getDerivedStateFromProps", value: function(e2, t3) {
    return e2.timeString !== t3.time ? { time: e2.timeString } : null;
  } }]), n2;
}();
function It(t2) {
  var r2 = t2.className, n2 = t2.children, o2 = t2.showPopperArrow, a2 = t2.arrowProps, s2 = a2 === void 0 ? {} : a2;
  return e$3.createElement("div", { className: r2 }, o2 && e$3.createElement("div", ue({ className: "react-datepicker__triangle" }, s2)), n2);
}
var Tt = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"], Lt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2(t3) {
    var a2;
    return pe(this, o2), de(ye(a2 = n2.call(this, t3)), "handleClickOutside", function(e2) {
      a2.props.onClickOutside(e2);
    }), de(ye(a2), "setClickOutsideRef", function() {
      return a2.containerRef.current;
    }), de(ye(a2), "handleDropdownFocus", function(e2) {
      (function() {
        var e3 = ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).className || "").split(/\s+/);
        return Tt.some(function(t4) {
          return e3.indexOf(t4) >= 0;
        });
      })(e2.target) && a2.props.onDropdownFocus();
    }), de(ye(a2), "getDateInView", function() {
      var e2 = a2.props, t4 = e2.preSelection, r2 = e2.selected, n3 = e2.openToDate, o3 = ut(a2.props), s2 = ht(a2.props), i2 = _e(), p2 = n3 || r2 || t4;
      return p2 || (o3 && isBefore(i2, o3) ? o3 : s2 && isAfter(i2, s2) ? s2 : i2);
    }), de(ye(a2), "increaseMonth", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: addMonths(t4, 1) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), de(ye(a2), "decreaseMonth", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: subMonths(t4, 1) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), de(ye(a2), "handleDayClick", function(e2, t4, r2) {
      a2.props.onSelect(e2, t4, r2), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), de(ye(a2), "handleDayMouseEnter", function(e2) {
      a2.setState({ selectingDate: e2 }), a2.props.onDayMouseEnter && a2.props.onDayMouseEnter(e2);
    }), de(ye(a2), "handleMonthMouseLeave", function() {
      a2.setState({ selectingDate: null }), a2.props.onMonthMouseLeave && a2.props.onMonthMouseLeave();
    }), de(ye(a2), "handleYearChange", function(e2) {
      a2.props.onYearChange && a2.props.onYearChange(e2), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e2), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), de(ye(a2), "handleMonthChange", function(e2) {
      a2.props.onMonthChange && a2.props.onMonthChange(e2), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e2), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), de(ye(a2), "handleMonthYearChange", function(e2) {
      a2.handleYearChange(e2), a2.handleMonthChange(e2);
    }), de(ye(a2), "changeYear", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setYear(r2, e2) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), de(ye(a2), "changeMonth", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setMonth(r2, e2) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), de(ye(a2), "changeMonthYear", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setYear(setMonth(r2, getMonth(e2)), getYear(e2)) };
      }, function() {
        return a2.handleMonthYearChange(a2.state.date);
      });
    }), de(ye(a2), "header", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a2.state.date, n3 = Te(t4, a2.props.locale, a2.props.calendarStartDay), o3 = [];
      return a2.props.showWeekNumbers && o3.push(e$3.createElement("div", { key: "W", className: "react-datepicker__day-name" }, a2.props.weekLabel || "#")), o3.concat([0, 1, 2, 3, 4, 5, 6].map(function(t5) {
        var o4 = addDays(n3, t5), s2 = a2.formatWeekday(o4, a2.props.locale), i2 = a2.props.weekDayClassName ? a2.props.weekDayClassName(o4) : void 0;
        return e$3.createElement("div", { key: t5, className: r("react-datepicker__day-name", i2) }, s2);
      }));
    }), de(ye(a2), "formatWeekday", function(e2, t4) {
      return a2.props.formatWeekDay ? function(e3, t5, r2) {
        return t5(Ee(e3, "EEEE", r2));
      }(e2, a2.props.formatWeekDay, t4) : a2.props.useWeekdaysShort ? function(e3, t5) {
        return Ee(e3, "EEE", t5);
      }(e2, t4) : function(e3, t5) {
        return Ee(e3, "EEEEEE", t5);
      }(e2, t4);
    }), de(ye(a2), "decreaseYear", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: subYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), de(ye(a2), "renderPreviousButton", function() {
      if (!a2.props.renderCustomHeader) {
        var t4;
        switch (true) {
          case a2.props.showMonthYearPicker:
            t4 = lt(a2.state.date, a2.props);
            break;
          case a2.props.showYearPicker:
            t4 = function(e2) {
              var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r3 = t5.minDate, n4 = t5.yearItemNumber, o4 = n4 === void 0 ? 12 : n4, a3 = vt(Re(subYears(e2, o4)), o4).endPeriod, s3 = r3 && getYear(r3);
              return s3 && s3 > a3 || false;
            }(a2.state.date, a2.props);
            break;
          default:
            t4 = pt(a2.state.date, a2.props);
        }
        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], n3 = a2.decreaseMonth;
          (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.decreaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n3 = null);
          var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker, s2 = a2.props, i2 = s2.previousMonthButtonLabel, p2 = s2.previousYearButtonLabel, c2 = a2.props, l2 = c2.previousMonthAriaLabel, d2 = l2 === void 0 ? typeof i2 == "string" ? i2 : "Previous Month" : l2, u2 = c2.previousYearAriaLabel, h2 = u2 === void 0 ? typeof p2 == "string" ? p2 : "Previous Year" : u2;
          return e$3.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a2.props.handleOnKeyDown, "aria-label": o3 ? h2 : d2 }, e$3.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ") }, o3 ? a2.props.previousYearButtonLabel : a2.props.previousMonthButtonLabel));
        }
      }
    }), de(ye(a2), "increaseYear", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: addYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), de(ye(a2), "renderNextButton", function() {
      if (!a2.props.renderCustomHeader) {
        var t4;
        switch (true) {
          case a2.props.showMonthYearPicker:
            t4 = dt(a2.state.date, a2.props);
            break;
          case a2.props.showYearPicker:
            t4 = function(e2) {
              var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r3 = t5.maxDate, n4 = t5.yearItemNumber, o4 = n4 === void 0 ? 12 : n4, a3 = vt(addYears(e2, o4), o4).startPeriod, s3 = r3 && getYear(r3);
              return s3 && s3 < a3 || false;
            }(a2.state.date, a2.props);
            break;
          default:
            t4 = ct(a2.state.date, a2.props);
        }
        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
          a2.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a2.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
          var n3 = a2.increaseMonth;
          (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.increaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n3 = null);
          var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker, s2 = a2.props, i2 = s2.nextMonthButtonLabel, p2 = s2.nextYearButtonLabel, c2 = a2.props, l2 = c2.nextMonthAriaLabel, u2 = l2 === void 0 ? typeof i2 == "string" ? i2 : "Next Month" : l2, h2 = c2.nextYearAriaLabel, m2 = h2 === void 0 ? typeof p2 == "string" ? p2 : "Next Year" : h2;
          return e$3.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a2.props.handleOnKeyDown, "aria-label": o3 ? m2 : u2 }, e$3.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ") }, o3 ? a2.props.nextYearButtonLabel : a2.props.nextMonthButtonLabel));
        }
      }
    }), de(ye(a2), "renderCurrentMonth", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a2.state.date, r2 = ["react-datepicker__current-month"];
      return a2.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a2.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a2.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), e$3.createElement("div", { className: r2.join(" ") }, Ee(t4, a2.props.dateFormat, a2.props.locale));
    }), de(ye(a2), "renderYearDropdown", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
      if (a2.props.showYearDropdown && !t4)
        return e$3.createElement(gt, { adjustDateOnChange: a2.props.adjustDateOnChange, date: a2.state.date, onSelect: a2.props.onSelect, setOpen: a2.props.setOpen, dropdownMode: a2.props.dropdownMode, onChange: a2.changeYear, minDate: a2.props.minDate, maxDate: a2.props.maxDate, year: getYear(a2.state.date), scrollableYearDropdown: a2.props.scrollableYearDropdown, yearDropdownItemNumber: a2.props.yearDropdownItemNumber });
    }), de(ye(a2), "renderMonthDropdown", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
      if (a2.props.showMonthDropdown && !t4)
        return e$3.createElement(bt, { dropdownMode: a2.props.dropdownMode, locale: a2.props.locale, onChange: a2.changeMonth, month: getMonth(a2.state.date), useShortMonthInDropdown: a2.props.useShortMonthInDropdown });
    }), de(ye(a2), "renderMonthYearDropdown", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
      if (a2.props.showMonthYearDropdown && !t4)
        return e$3.createElement(_t, { dropdownMode: a2.props.dropdownMode, locale: a2.props.locale, dateFormat: a2.props.dateFormat, onChange: a2.changeMonthYear, minDate: a2.props.minDate, maxDate: a2.props.maxDate, date: a2.state.date, scrollableMonthYearDropdown: a2.props.scrollableMonthYearDropdown });
    }), de(ye(a2), "renderTodayButton", function() {
      if (a2.props.todayButton && !a2.props.showTimeSelectOnly)
        return e$3.createElement("div", { className: "react-datepicker__today-button", onClick: function(e2) {
          return a2.props.onSelect(startOfDay(_e()), e2);
        } }, a2.props.todayButton);
    }), de(ye(a2), "renderDefaultHeader", function(t4) {
      var r2 = t4.monthDate, n3 = t4.i;
      return e$3.createElement("div", { className: "react-datepicker__header ".concat(a2.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") }, a2.renderCurrentMonth(r2), e$3.createElement("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a2.props.dropdownMode), onFocus: a2.handleDropdownFocus }, a2.renderMonthDropdown(n3 !== 0), a2.renderMonthYearDropdown(n3 !== 0), a2.renderYearDropdown(n3 !== 0)), e$3.createElement("div", { className: "react-datepicker__day-names" }, a2.header(r2)));
    }), de(ye(a2), "renderCustomHeader", function() {
      var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r2 = t4.monthDate, n3 = t4.i;
      if (a2.props.showTimeSelect && !a2.state.monthContainer || a2.props.showTimeSelectOnly)
        return null;
      var o3 = pt(a2.state.date, a2.props), s2 = ct(a2.state.date, a2.props), i2 = lt(a2.state.date, a2.props), p2 = dt(a2.state.date, a2.props), c2 = !a2.props.showMonthYearPicker && !a2.props.showQuarterYearPicker && !a2.props.showYearPicker;
      return e$3.createElement("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: a2.props.onDropdownFocus }, a2.props.renderCustomHeader(se(se({}, a2.state), {}, { customHeaderCount: n3, monthDate: r2, changeMonth: a2.changeMonth, changeYear: a2.changeYear, decreaseMonth: a2.decreaseMonth, increaseMonth: a2.increaseMonth, decreaseYear: a2.decreaseYear, increaseYear: a2.increaseYear, prevMonthButtonDisabled: o3, nextMonthButtonDisabled: s2, prevYearButtonDisabled: i2, nextYearButtonDisabled: p2 })), c2 && e$3.createElement("div", { className: "react-datepicker__day-names" }, a2.header(r2)));
    }), de(ye(a2), "renderYearHeader", function() {
      var t4 = a2.state.date, r2 = a2.props, n3 = r2.showYearPicker, o3 = vt(t4, r2.yearItemNumber), s2 = o3.startPeriod, i2 = o3.endPeriod;
      return e$3.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, n3 ? "".concat(s2, " - ").concat(i2) : getYear(t4));
    }), de(ye(a2), "renderHeader", function(e2) {
      switch (true) {
        case a2.props.renderCustomHeader !== void 0:
          return a2.renderCustomHeader(e2);
        case (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker):
          return a2.renderYearHeader(e2);
        default:
          return a2.renderDefaultHeader(e2);
      }
    }), de(ye(a2), "renderMonths", function() {
      if (!a2.props.showTimeSelectOnly && !a2.props.showYearPicker) {
        for (var t4 = [], r2 = a2.props.showPreviousMonths ? a2.props.monthsShown - 1 : 0, n3 = subMonths(a2.state.date, r2), o3 = 0; o3 < a2.props.monthsShown; ++o3) {
          var s2 = o3 - a2.props.monthSelectedIn, i2 = addMonths(n3, s2), p2 = "month-".concat(o3), c2 = o3 < a2.props.monthsShown - 1, d2 = o3 > 0;
          t4.push(e$3.createElement("div", { key: p2, ref: function(e2) {
            a2.monthContainer = e2;
          }, className: "react-datepicker__month-container" }, a2.renderHeader({ monthDate: i2, i: o3 }), e$3.createElement(Nt, { chooseDayAriaLabelPrefix: a2.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: a2.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: a2.props.weekAriaLabelPrefix, onChange: a2.changeMonthYear, day: i2, dayClassName: a2.props.dayClassName, calendarStartDay: a2.props.calendarStartDay, monthClassName: a2.props.monthClassName, onDayClick: a2.handleDayClick, handleOnKeyDown: a2.props.handleOnDayKeyDown, onDayMouseEnter: a2.handleDayMouseEnter, onMouseLeave: a2.handleMonthMouseLeave, onWeekSelect: a2.props.onWeekSelect, orderInDisplay: o3, formatWeekNumber: a2.props.formatWeekNumber, locale: a2.props.locale, minDate: a2.props.minDate, maxDate: a2.props.maxDate, excludeDates: a2.props.excludeDates, excludeDateIntervals: a2.props.excludeDateIntervals, highlightDates: a2.props.highlightDates, selectingDate: a2.state.selectingDate, includeDates: a2.props.includeDates, includeDateIntervals: a2.props.includeDateIntervals, inline: a2.props.inline, shouldFocusDayInline: a2.props.shouldFocusDayInline, fixedHeight: a2.props.fixedHeight, filterDate: a2.props.filterDate, preSelection: a2.props.preSelection, setPreSelection: a2.props.setPreSelection, selected: a2.props.selected, selectsStart: a2.props.selectsStart, selectsEnd: a2.props.selectsEnd, selectsRange: a2.props.selectsRange, selectsDisabledDaysInRange: a2.props.selectsDisabledDaysInRange, showWeekNumbers: a2.props.showWeekNumbers, startDate: a2.props.startDate, endDate: a2.props.endDate, peekNextMonth: a2.props.peekNextMonth, setOpen: a2.props.setOpen, shouldCloseOnSelect: a2.props.shouldCloseOnSelect, renderDayContents: a2.props.renderDayContents, disabledKeyboardNavigation: a2.props.disabledKeyboardNavigation, showMonthYearPicker: a2.props.showMonthYearPicker, showFullMonthYearPicker: a2.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: a2.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: a2.props.showFourColumnMonthYearPicker, showYearPicker: a2.props.showYearPicker, showQuarterYearPicker: a2.props.showQuarterYearPicker, isInputFocused: a2.props.isInputFocused, containerRef: a2.containerRef, monthShowsDuplicateDaysEnd: c2, monthShowsDuplicateDaysStart: d2 })));
        }
        return t4;
      }
    }), de(ye(a2), "renderYears", function() {
      if (!a2.props.showTimeSelectOnly)
        return a2.props.showYearPicker ? e$3.createElement("div", { className: "react-datepicker__year--container" }, a2.renderHeader(), e$3.createElement(Yt, ue({ onDayClick: a2.handleDayClick, date: a2.state.date }, a2.props))) : void 0;
    }), de(ye(a2), "renderTimeSection", function() {
      if (a2.props.showTimeSelect && (a2.state.monthContainer || a2.props.showTimeSelectOnly))
        return e$3.createElement(xt, { selected: a2.props.selected, openToDate: a2.props.openToDate, onChange: a2.props.onTimeChange, timeClassName: a2.props.timeClassName, format: a2.props.timeFormat, includeTimes: a2.props.includeTimes, intervals: a2.props.timeIntervals, minTime: a2.props.minTime, maxTime: a2.props.maxTime, excludeTimes: a2.props.excludeTimes, filterTime: a2.props.filterTime, timeCaption: a2.props.timeCaption, todayButton: a2.props.todayButton, showMonthDropdown: a2.props.showMonthDropdown, showMonthYearDropdown: a2.props.showMonthYearDropdown, showYearDropdown: a2.props.showYearDropdown, withPortal: a2.props.withPortal, monthRef: a2.state.monthContainer, injectTimes: a2.props.injectTimes, locale: a2.props.locale, handleOnKeyDown: a2.props.handleOnKeyDown, showTimeSelectOnly: a2.props.showTimeSelectOnly });
    }), de(ye(a2), "renderInputTimeSection", function() {
      var t4 = new Date(a2.props.selected), r2 = Pe(t4) && Boolean(a2.props.selected) ? "".concat(yt(t4.getHours()), ":").concat(yt(t4.getMinutes())) : "";
      if (a2.props.showTimeInput)
        return e$3.createElement(Ot, { date: t4, timeString: r2, timeInputLabel: a2.props.timeInputLabel, onChange: a2.props.onTimeChange, customTimeInput: a2.props.customTimeInput });
    }), a2.containerRef = e$3.createRef(), a2.state = { date: a2.getDateInView(), selectingDate: null, monthContainer: null }, a2;
  }
  return le(o2, [{ key: "componentDidMount", value: function() {
    var e2 = this;
    this.props.showTimeSelect && (this.assignMonthContainer = void e2.setState({ monthContainer: e2.monthContainer }));
  } }, { key: "componentDidUpdate", value: function(e2) {
    this.props.preSelection && !We(this.props.preSelection, e2.preSelection) ? this.setState({ date: this.props.preSelection }) : this.props.openToDate && !We(this.props.openToDate, e2.openToDate) && this.setState({ date: this.props.openToDate });
  } }, { key: "render", value: function() {
    var t3 = this.props.container || It;
    return e$3.createElement("div", { ref: this.containerRef }, e$3.createElement(t3, { className: r("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }), showPopperArrow: this.props.showPopperArrow, arrowProps: this.props.arrowProps }, this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.props.children));
  } }], [{ key: "defaultProps", get: function() {
    return { onDropdownFocus: function() {
    }, monthsShown: 1, monthSelectedIn: 0, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", customTimeInput: null, yearItemNumber: 12 };
  } }]), o2;
}(), Rt = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2(e2) {
    var t3;
    return pe(this, n2), (t3 = r2.call(this, e2)).el = document.createElement("div"), t3;
  }
  return le(n2, [{ key: "componentDidMount", value: function() {
    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
  } }, { key: "componentWillUnmount", value: function() {
    this.portalRoot.removeChild(this.el);
  } }, { key: "render", value: function() {
    return te.createPortal(this.props.children, this.el);
  } }]), n2;
}(), Ft = function(e2) {
  return !e2.disabled && e2.tabIndex !== -1;
}, At = function(t2) {
  he(n2, e$3.Component);
  var r2 = De(n2);
  function n2(t3) {
    var o2;
    return pe(this, n2), de(ye(o2 = r2.call(this, t3)), "getTabChildren", function() {
      return Array.prototype.slice.call(o2.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(Ft);
    }), de(ye(o2), "handleFocusStart", function(e2) {
      var t4 = o2.getTabChildren();
      t4 && t4.length > 1 && t4[t4.length - 1].focus();
    }), de(ye(o2), "handleFocusEnd", function(e2) {
      var t4 = o2.getTabChildren();
      t4 && t4.length > 1 && t4[0].focus();
    }), o2.tabLoopRef = e$3.createRef(), o2;
  }
  return le(n2, [{ key: "render", value: function() {
    return this.props.enableTabLoop ? e$3.createElement("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef }, e$3.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: "0", onFocus: this.handleFocusStart }), this.props.children, e$3.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: "0", onFocus: this.handleFocusEnd })) : this.props.children;
  } }], [{ key: "defaultProps", get: function() {
    return { enableTabLoop: true };
  } }]), n2;
}(), Bt = function(t2) {
  he(o2, e$3.Component);
  var n2 = De(o2);
  function o2() {
    return pe(this, o2), n2.apply(this, arguments);
  }
  return le(o2, [{ key: "render", value: function() {
    var t3, n3 = this.props, o3 = n3.className, a2 = n3.wrapperClassName, s2 = n3.hidePopper, i2 = n3.popperComponent, p2 = n3.popperModifiers, c2 = n3.popperPlacement, l2 = n3.popperProps, d2 = n3.targetComponent, u2 = n3.enableTabLoop, h2 = n3.popperOnKeyDown, m2 = n3.portalId, f2 = n3.portalHost;
    if (!s2) {
      var y2 = r("react-datepicker-popper", o3);
      t3 = e$3.createElement(Popper, ue({ modifiers: p2, placement: c2 }, l2), function(t4) {
        var r2 = t4.ref, n4 = t4.style, o4 = t4.placement, a3 = t4.arrowProps;
        return e$3.createElement(At, { enableTabLoop: u2 }, e$3.createElement("div", { ref: r2, style: n4, className: y2, "data-placement": o4, onKeyDown: h2 }, e$3.cloneElement(i2, { arrowProps: a3 })));
      });
    }
    this.props.popperContainer && (t3 = e$3.createElement(this.props.popperContainer, {}, t3)), m2 && !s2 && (t3 = e$3.createElement(Rt, { portalId: m2, portalHost: f2 }, t3));
    var v2 = r("react-datepicker-wrapper", a2);
    return e$3.createElement(Manager, { className: "react-datepicker-manager" }, e$3.createElement(Reference, null, function(t4) {
      var r2 = t4.ref;
      return e$3.createElement("div", { ref: r2, className: v2 }, d2);
    }), t3);
  } }], [{ key: "defaultProps", get: function() {
    return { hidePopper: true, popperModifiers: [], popperProps: {}, popperPlacement: "bottom-start" };
  } }]), o2;
}(), Kt = onClickOutsideHOC(Lt);
var Wt = function(t2) {
  he(a2, e$3.Component);
  var o2 = De(a2);
  function a2(t3) {
    var s2;
    return pe(this, a2), de(ye(s2 = o2.call(this, t3)), "getPreSelection", function() {
      return s2.props.openToDate ? s2.props.openToDate : s2.props.selectsEnd && s2.props.startDate ? s2.props.startDate : s2.props.selectsStart && s2.props.endDate ? s2.props.endDate : _e();
    }), de(ye(s2), "calcInitialState", function() {
      var e2, t4 = s2.getPreSelection(), r2 = ut(s2.props), n2 = ht(s2.props), o3 = r2 && isBefore(t4, startOfDay(r2)) ? r2 : n2 && isAfter(t4, endOfDay(n2)) ? n2 : t4;
      return { open: s2.props.startOpen || false, preventFocus: false, preSelection: (e2 = s2.props.selectsRange ? s2.props.startDate : s2.props.selected) !== null && e2 !== void 0 ? e2 : o3, highlightDates: mt(s2.props.highlightDates), focused: false, shouldFocusDayInline: false };
    }), de(ye(s2), "clearPreventFocusTimeout", function() {
      s2.preventFocusTimeout && clearTimeout(s2.preventFocusTimeout);
    }), de(ye(s2), "setFocus", function() {
      s2.input && s2.input.focus && s2.input.focus({ preventScroll: true });
    }), de(ye(s2), "setBlur", function() {
      s2.input && s2.input.blur && s2.input.blur(), s2.cancelFocusInput();
    }), de(ye(s2), "setOpen", function(e2) {
      var t4 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
      s2.setState({ open: e2, preSelection: e2 && s2.state.open ? s2.state.preSelection : s2.calcInitialState().preSelection, lastPreSelectChange: Ht }, function() {
        e2 || s2.setState(function(e3) {
          return { focused: !!t4 && e3.focused };
        }, function() {
          !t4 && s2.setBlur(), s2.setState({ inputValue: null });
        });
      });
    }), de(ye(s2), "inputOk", function() {
      return isDate(s2.state.preSelection);
    }), de(ye(s2), "isCalendarOpen", function() {
      return s2.props.open === void 0 ? s2.state.open && !s2.props.disabled && !s2.props.readOnly : s2.props.open;
    }), de(ye(s2), "handleFocus", function(e2) {
      s2.state.preventFocus || (s2.props.onFocus(e2), s2.props.preventOpenOnFocus || s2.props.readOnly || s2.setOpen(true)), s2.setState({ focused: true });
    }), de(ye(s2), "cancelFocusInput", function() {
      clearTimeout(s2.inputFocusTimeout), s2.inputFocusTimeout = null;
    }), de(ye(s2), "deferFocusInput", function() {
      s2.cancelFocusInput(), s2.inputFocusTimeout = setTimeout(function() {
        return s2.setFocus();
      }, 1);
    }), de(ye(s2), "handleDropdownFocus", function() {
      s2.cancelFocusInput();
    }), de(ye(s2), "handleBlur", function(e2) {
      (!s2.state.open || s2.props.withPortal || s2.props.showTimeInput) && s2.props.onBlur(e2), s2.setState({ focused: false });
    }), de(ye(s2), "handleCalendarClickOutside", function(e2) {
      s2.props.inline || s2.setOpen(false), s2.props.onClickOutside(e2), s2.props.withPortal && e2.preventDefault();
    }), de(ye(s2), "handleChange", function() {
      for (var e2 = arguments.length, t4 = new Array(e2), r2 = 0; r2 < e2; r2++)
        t4[r2] = arguments[r2];
      var n2 = t4[0];
      if (!s2.props.onChangeRaw || (s2.props.onChangeRaw.apply(ye(s2), t4), typeof n2.isDefaultPrevented == "function" && !n2.isDefaultPrevented())) {
        s2.setState({ inputValue: n2.target.value, lastPreSelectChange: jt });
        var o3 = Me(n2.target.value, s2.props.dateFormat, s2.props.locale, s2.props.strictParsing, s2.props.minDate);
        !o3 && n2.target.value || s2.setSelected(o3, n2, true);
      }
    }), de(ye(s2), "handleSelect", function(e2, t4, r2) {
      if (s2.setState({ preventFocus: true }, function() {
        return s2.preventFocusTimeout = setTimeout(function() {
          return s2.setState({ preventFocus: false });
        }, 50), s2.preventFocusTimeout;
      }), s2.props.onChangeRaw && s2.props.onChangeRaw(t4), s2.setSelected(e2, t4, false, r2), !s2.props.shouldCloseOnSelect || s2.props.showTimeSelect)
        s2.setPreSelection(e2);
      else if (!s2.props.inline) {
        s2.props.selectsRange || s2.setOpen(false);
        var n2 = s2.props, o3 = n2.startDate, a3 = n2.endDate;
        !o3 || a3 || isBefore(e2, o3) || s2.setOpen(false);
      }
    }), de(ye(s2), "setSelected", function(e2, t4, r2, n2) {
      var o3 = e2;
      if (o3 === null || !Je(o3, s2.props)) {
        var a3 = s2.props, i2 = a3.onChange, p2 = a3.selectsRange, c2 = a3.startDate, l2 = a3.endDate;
        if (!je(s2.props.selected, o3) || s2.props.allowSameDay || p2)
          if (o3 !== null && (!s2.props.selected || r2 && (s2.props.showTimeSelect || s2.props.showTimeSelectOnly || s2.props.showTimeInput) || (o3 = xe(o3, { hour: getHours(s2.props.selected), minute: getMinutes(s2.props.selected), second: getSeconds(s2.props.selected) })), s2.props.inline || s2.setState({ preSelection: o3 }), s2.props.focusSelectedMonth || s2.setState({ monthSelectedIn: n2 })), p2) {
            var d2 = c2 && !l2, u2 = c2 && l2;
            !c2 && !l2 ? i2([o3, null], t4) : d2 && (isBefore(o3, c2) ? i2([o3, null], t4) : i2([c2, o3], t4)), u2 && i2([o3, null], t4);
          } else
            i2(o3, t4);
        r2 || (s2.props.onSelect(o3, t4), s2.setState({ inputValue: null }));
      }
    }), de(ye(s2), "setPreSelection", function(e2) {
      var t4 = s2.props.minDate !== void 0, r2 = s2.props.maxDate !== void 0, n2 = true;
      if (e2) {
        var o3 = startOfDay(e2);
        if (t4 && r2)
          n2 = He(e2, s2.props.minDate, s2.props.maxDate);
        else if (t4) {
          var a3 = startOfDay(s2.props.minDate);
          n2 = isAfter(e2, a3) || je(o3, a3);
        } else if (r2) {
          var i2 = endOfDay(s2.props.maxDate);
          n2 = isBefore(e2, i2) || je(o3, i2);
        }
      }
      n2 && s2.setState({ preSelection: e2 });
    }), de(ye(s2), "handleTimeChange", function(e2) {
      var t4 = xe(s2.props.selected ? s2.props.selected : s2.getPreSelection(), { hour: getHours(e2), minute: getMinutes(e2) });
      s2.setState({ preSelection: t4 }), s2.props.onChange(t4), s2.props.shouldCloseOnSelect && s2.setOpen(false), s2.props.showTimeInput && s2.setOpen(true), s2.setState({ inputValue: null });
    }), de(ye(s2), "onInputClick", function() {
      s2.props.disabled || s2.props.readOnly || s2.setOpen(true), s2.props.onInputClick();
    }), de(ye(s2), "onInputKeyDown", function(e2) {
      s2.props.onKeyDown(e2);
      var t4 = e2.key;
      if (s2.state.open || s2.props.inline || s2.props.preventOpenOnFocus) {
        if (s2.state.open) {
          if (t4 === "ArrowDown" || t4 === "ArrowUp") {
            e2.preventDefault();
            var r2 = s2.calendar.componentNode && s2.calendar.componentNode.querySelector('.react-datepicker__day[tabindex="0"]');
            return void (r2 && r2.focus({ preventScroll: true }));
          }
          var n2 = _e(s2.state.preSelection);
          t4 === "Enter" ? (e2.preventDefault(), s2.inputOk() && s2.state.lastPreSelectChange === Ht ? (s2.handleSelect(n2, e2), !s2.props.shouldCloseOnSelect && s2.setPreSelection(n2)) : s2.setOpen(false)) : t4 === "Escape" && (e2.preventDefault(), s2.setOpen(false)), s2.inputOk() || s2.props.onInputError({ code: 1, msg: "Date input not valid." });
        }
      } else
        t4 !== "ArrowDown" && t4 !== "ArrowUp" && t4 !== "Enter" || s2.onInputClick();
    }), de(ye(s2), "onDayKeyDown", function(e2) {
      s2.props.onKeyDown(e2);
      var t4 = e2.key, r2 = _e(s2.state.preSelection);
      if (t4 === "Enter")
        e2.preventDefault(), s2.handleSelect(r2, e2), !s2.props.shouldCloseOnSelect && s2.setPreSelection(r2);
      else if (t4 === "Escape")
        e2.preventDefault(), s2.setOpen(false), s2.inputOk() || s2.props.onInputError({ code: 1, msg: "Date input not valid." });
      else if (!s2.props.disabledKeyboardNavigation) {
        var n2;
        switch (t4) {
          case "ArrowLeft":
            n2 = subDays(r2, 1);
            break;
          case "ArrowRight":
            n2 = addDays(r2, 1);
            break;
          case "ArrowUp":
            n2 = subWeeks(r2, 1);
            break;
          case "ArrowDown":
            n2 = addWeeks(r2, 1);
            break;
          case "PageUp":
            n2 = subMonths(r2, 1);
            break;
          case "PageDown":
            n2 = addMonths(r2, 1);
            break;
          case "Home":
            n2 = subYears(r2, 1);
            break;
          case "End":
            n2 = addYears(r2, 1);
        }
        if (!n2)
          return void (s2.props.onInputError && s2.props.onInputError({ code: 1, msg: "Date input not valid." }));
        if (e2.preventDefault(), s2.setState({ lastPreSelectChange: Ht }), s2.props.adjustDateOnChange && s2.setSelected(n2), s2.setPreSelection(n2), s2.props.inline) {
          var o3 = getMonth(r2), a3 = getMonth(n2), i2 = getYear(r2), y2 = getYear(n2);
          o3 !== a3 || i2 !== y2 ? s2.setState({ shouldFocusDayInline: true }) : s2.setState({ shouldFocusDayInline: false });
        }
      }
    }), de(ye(s2), "onPopperKeyDown", function(e2) {
      e2.key === "Escape" && (e2.preventDefault(), s2.setState({ preventFocus: true }, function() {
        s2.setOpen(false), setTimeout(function() {
          s2.setFocus(), s2.setState({ preventFocus: false });
        });
      }));
    }), de(ye(s2), "onClearClick", function(e2) {
      e2 && e2.preventDefault && e2.preventDefault(), s2.props.selectsRange ? s2.props.onChange([null, null], e2) : s2.props.onChange(null, e2), s2.setState({ inputValue: null });
    }), de(ye(s2), "clear", function() {
      s2.onClearClick();
    }), de(ye(s2), "onScroll", function(e2) {
      typeof s2.props.closeOnScroll == "boolean" && s2.props.closeOnScroll ? e2.target !== document && e2.target !== document.documentElement && e2.target !== document.body || s2.setOpen(false) : typeof s2.props.closeOnScroll == "function" && s2.props.closeOnScroll(e2) && s2.setOpen(false);
    }), de(ye(s2), "renderCalendar", function() {
      return s2.props.inline || s2.isCalendarOpen() ? e$3.createElement(Kt, { ref: function(e2) {
        s2.calendar = e2;
      }, locale: s2.props.locale, calendarStartDay: s2.props.calendarStartDay, chooseDayAriaLabelPrefix: s2.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: s2.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: s2.props.weekAriaLabelPrefix, adjustDateOnChange: s2.props.adjustDateOnChange, setOpen: s2.setOpen, shouldCloseOnSelect: s2.props.shouldCloseOnSelect, dateFormat: s2.props.dateFormatCalendar, useWeekdaysShort: s2.props.useWeekdaysShort, formatWeekDay: s2.props.formatWeekDay, dropdownMode: s2.props.dropdownMode, selected: s2.props.selected, preSelection: s2.state.preSelection, onSelect: s2.handleSelect, onWeekSelect: s2.props.onWeekSelect, openToDate: s2.props.openToDate, minDate: s2.props.minDate, maxDate: s2.props.maxDate, selectsStart: s2.props.selectsStart, selectsEnd: s2.props.selectsEnd, selectsRange: s2.props.selectsRange, startDate: s2.props.startDate, endDate: s2.props.endDate, excludeDates: s2.props.excludeDates, excludeDateIntervals: s2.props.excludeDateIntervals, filterDate: s2.props.filterDate, onClickOutside: s2.handleCalendarClickOutside, formatWeekNumber: s2.props.formatWeekNumber, highlightDates: s2.state.highlightDates, includeDates: s2.props.includeDates, includeDateIntervals: s2.props.includeDateIntervals, includeTimes: s2.props.includeTimes, injectTimes: s2.props.injectTimes, inline: s2.props.inline, shouldFocusDayInline: s2.state.shouldFocusDayInline, peekNextMonth: s2.props.peekNextMonth, showMonthDropdown: s2.props.showMonthDropdown, showPreviousMonths: s2.props.showPreviousMonths, useShortMonthInDropdown: s2.props.useShortMonthInDropdown, showMonthYearDropdown: s2.props.showMonthYearDropdown, showWeekNumbers: s2.props.showWeekNumbers, showYearDropdown: s2.props.showYearDropdown, withPortal: s2.props.withPortal, forceShowMonthNavigation: s2.props.forceShowMonthNavigation, showDisabledMonthNavigation: s2.props.showDisabledMonthNavigation, scrollableYearDropdown: s2.props.scrollableYearDropdown, scrollableMonthYearDropdown: s2.props.scrollableMonthYearDropdown, todayButton: s2.props.todayButton, weekLabel: s2.props.weekLabel, outsideClickIgnoreClass: "react-datepicker-ignore-onclickoutside", fixedHeight: s2.props.fixedHeight, monthsShown: s2.props.monthsShown, monthSelectedIn: s2.state.monthSelectedIn, onDropdownFocus: s2.handleDropdownFocus, onMonthChange: s2.props.onMonthChange, onYearChange: s2.props.onYearChange, dayClassName: s2.props.dayClassName, weekDayClassName: s2.props.weekDayClassName, monthClassName: s2.props.monthClassName, timeClassName: s2.props.timeClassName, showTimeSelect: s2.props.showTimeSelect, showTimeSelectOnly: s2.props.showTimeSelectOnly, onTimeChange: s2.handleTimeChange, timeFormat: s2.props.timeFormat, timeIntervals: s2.props.timeIntervals, minTime: s2.props.minTime, maxTime: s2.props.maxTime, excludeTimes: s2.props.excludeTimes, filterTime: s2.props.filterTime, timeCaption: s2.props.timeCaption, className: s2.props.calendarClassName, container: s2.props.calendarContainer, yearItemNumber: s2.props.yearItemNumber, yearDropdownItemNumber: s2.props.yearDropdownItemNumber, previousMonthAriaLabel: s2.props.previousMonthAriaLabel, previousMonthButtonLabel: s2.props.previousMonthButtonLabel, nextMonthAriaLabel: s2.props.nextMonthAriaLabel, nextMonthButtonLabel: s2.props.nextMonthButtonLabel, previousYearAriaLabel: s2.props.previousYearAriaLabel, previousYearButtonLabel: s2.props.previousYearButtonLabel, nextYearAriaLabel: s2.props.nextYearAriaLabel, nextYearButtonLabel: s2.props.nextYearButtonLabel, timeInputLabel: s2.props.timeInputLabel, disabledKeyboardNavigation: s2.props.disabledKeyboardNavigation, renderCustomHeader: s2.props.renderCustomHeader, popperProps: s2.props.popperProps, renderDayContents: s2.props.renderDayContents, onDayMouseEnter: s2.props.onDayMouseEnter, onMonthMouseLeave: s2.props.onMonthMouseLeave, selectsDisabledDaysInRange: s2.props.selectsDisabledDaysInRange, showTimeInput: s2.props.showTimeInput, showMonthYearPicker: s2.props.showMonthYearPicker, showFullMonthYearPicker: s2.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: s2.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: s2.props.showFourColumnMonthYearPicker, showYearPicker: s2.props.showYearPicker, showQuarterYearPicker: s2.props.showQuarterYearPicker, showPopperArrow: s2.props.showPopperArrow, excludeScrollbar: s2.props.excludeScrollbar, handleOnKeyDown: s2.props.onKeyDown, handleOnDayKeyDown: s2.onDayKeyDown, isInputFocused: s2.state.focused, customTimeInput: s2.props.customTimeInput, setPreSelection: s2.setPreSelection }, s2.props.children) : null;
    }), de(ye(s2), "renderDateInput", function() {
      var t4, n2 = r(s2.props.className, de({}, "react-datepicker-ignore-onclickoutside", s2.state.open)), o3 = s2.props.customInput || e$3.createElement("input", { type: "text" }), a3 = s2.props.customInputRef || "ref", i2 = typeof s2.props.value == "string" ? s2.props.value : typeof s2.state.inputValue == "string" ? s2.state.inputValue : s2.props.selectsRange ? function(e2, t5, r2) {
        if (!e2)
          return "";
        var n3 = Ne(e2, r2), o4 = t5 ? Ne(t5, r2) : "";
        return "".concat(n3, " - ").concat(o4);
      }(s2.props.startDate, s2.props.endDate, s2.props) : Ne(s2.props.selected, s2.props);
      return e$3.cloneElement(o3, (de(t4 = {}, a3, function(e2) {
        s2.input = e2;
      }), de(t4, "value", i2), de(t4, "onBlur", s2.handleBlur), de(t4, "onChange", s2.handleChange), de(t4, "onClick", s2.onInputClick), de(t4, "onFocus", s2.handleFocus), de(t4, "onKeyDown", s2.onInputKeyDown), de(t4, "id", s2.props.id), de(t4, "name", s2.props.name), de(t4, "autoFocus", s2.props.autoFocus), de(t4, "placeholder", s2.props.placeholderText), de(t4, "disabled", s2.props.disabled), de(t4, "autoComplete", s2.props.autoComplete), de(t4, "className", r(o3.props.className, n2)), de(t4, "title", s2.props.title), de(t4, "readOnly", s2.props.readOnly), de(t4, "required", s2.props.required), de(t4, "tabIndex", s2.props.tabIndex), de(t4, "aria-describedby", s2.props.ariaDescribedBy), de(t4, "aria-invalid", s2.props.ariaInvalid), de(t4, "aria-labelledby", s2.props.ariaLabelledBy), de(t4, "aria-required", s2.props.ariaRequired), t4));
    }), de(ye(s2), "renderClearButton", function() {
      var t4 = s2.props, r2 = t4.isClearable, n2 = t4.selected, o3 = t4.startDate, a3 = t4.endDate, i2 = t4.clearButtonTitle, p2 = t4.clearButtonClassName, c2 = p2 === void 0 ? "" : p2, l2 = t4.ariaLabelClose, d2 = l2 === void 0 ? "Close" : l2;
      return !r2 || n2 == null && o3 == null && a3 == null ? null : e$3.createElement("button", { type: "button", className: "react-datepicker__close-icon ".concat(c2).trim(), "aria-label": d2, onClick: s2.onClearClick, title: i2, tabIndex: -1 });
    }), s2.state = s2.calcInitialState(), s2;
  }
  return le(a2, [{ key: "componentDidMount", value: function() {
    window.addEventListener("scroll", this.onScroll, true);
  } }, { key: "componentDidUpdate", value: function(e2, t3) {
    var r2, n2;
    e2.inline && (r2 = e2.selected, n2 = this.props.selected, r2 && n2 ? getMonth(r2) !== getMonth(n2) || getYear(r2) !== getYear(n2) : r2 !== n2) && this.setPreSelection(this.props.selected), this.state.monthSelectedIn !== void 0 && e2.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), e2.highlightDates !== this.props.highlightDates && this.setState({ highlightDates: mt(this.props.highlightDates) }), t3.focused || je(e2.selected, this.props.selected) || this.setState({ inputValue: null }), t3.open !== this.state.open && (t3.open === false && this.state.open === true && this.props.onCalendarOpen(), t3.open === true && this.state.open === false && this.props.onCalendarClose());
  } }, { key: "componentWillUnmount", value: function() {
    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
  } }, { key: "renderInputContainer", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__input-container" }, this.renderDateInput(), this.renderClearButton());
  } }, { key: "render", value: function() {
    var t3 = this.renderCalendar();
    if (this.props.inline)
      return t3;
    if (this.props.withPortal) {
      var r2 = this.state.open ? e$3.createElement("div", { className: "react-datepicker__portal" }, t3) : null;
      return this.state.open && this.props.portalId && (r2 = e$3.createElement(Rt, { portalId: this.props.portalId, portalHost: this.props.portalHost }, r2)), e$3.createElement("div", null, this.renderInputContainer(), r2);
    }
    return e$3.createElement(Bt, { className: this.props.popperClassName, wrapperClassName: this.props.wrapperClassName, hidePopper: !this.isCalendarOpen(), portalId: this.props.portalId, portalHost: this.props.portalHost, popperModifiers: this.props.popperModifiers, targetComponent: this.renderInputContainer(), popperContainer: this.props.popperContainer, popperComponent: t3, popperPlacement: this.props.popperPlacement, popperProps: this.props.popperProps, popperOnKeyDown: this.onPopperKeyDown, enableTabLoop: this.props.enableTabLoop });
  } }], [{ key: "defaultProps", get: function() {
    return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", onChange: function() {
    }, disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", onFocus: function() {
    }, onBlur: function() {
    }, onKeyDown: function() {
    }, onInputClick: function() {
    }, onSelect: function() {
    }, onClickOutside: function() {
    }, onMonthChange: function() {
    }, onCalendarOpen: function() {
    }, onCalendarClose: function() {
    }, preventOpenOnFocus: false, onYearChange: function() {
    }, onInputError: function() {
    }, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, strictParsing: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: 12, renderDayContents: function(e2) {
      return e2;
    }, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0 };
  } }]), a2;
}(), jt = "input", Ht = "navigate";
const DatePickerCss = {
  name: "1b2vhat",
  styles: ".react-datepicker__year-read-view--down-arrow,.react-datepicker__month-read-view--down-arrow,.react-datepicker__month-year-read-view--down-arrow,.react-datepicker__navigation-icon::before{border-color:#ccc;border-style:solid;border-width:3px 3px 0 0;content:'';display:block;height:9px;position:absolute;top:6px;width:9px;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle,.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle{margin-left:-4px;position:absolute;width:0;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::before,.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::before,.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::after,.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::after{box-sizing:content-box;position:absolute;border:8px solid transparent;height:0;width:1px;content:'';z-index:-1;border-width:8px;left:-8px;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::before,.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::before{border-bottom-color:#aeaeae;}.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle{top:0;margin-top:-8px;}.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::before,.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::after{border-top:none;border-bottom-color:#f0f0f0;}.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::after{top:0;}.react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle::before{top:-1px;border-bottom-color:#aeaeae;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle{bottom:0;margin-bottom:-8px;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::before,.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::after{border-bottom:none;border-top-color:#fff;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::after{bottom:0;}.react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle::before{bottom:-1px;border-top-color:#aeaeae;}.react-datepicker-wrapper{display:inline-block;padding:0;border:0;width:100%;}.react-datepicker{font-family:'Helvetica Neue',helvetica,arial,sans-serif;font-size:0.8rem;background-color:#fff;color:#000;border:1px solid #aeaeae;border-radius:0.3rem;display:inline-block;position:relative;}.react-datepicker--time-only .react-datepicker__triangle{left:35px;}.react-datepicker--time-only .react-datepicker__time-container{border-left:0;}.react-datepicker--time-only .react-datepicker__time,.react-datepicker--time-only .react-datepicker__time-box{border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;}.react-datepicker__triangle{position:absolute;left:50px;}.react-datepicker-popper{z-index:1;}.react-datepicker-popper[data-placement^='bottom']{padding-top:10px;}.react-datepicker-popper[data-placement='bottom-end'] .react-datepicker__triangle,.react-datepicker-popper[data-placement='top-end'] .react-datepicker__triangle{left:auto;right:50px;}.react-datepicker-popper[data-placement^='top']{padding-bottom:10px;}.react-datepicker-popper[data-placement^='right']{padding-left:8px;}.react-datepicker-popper[data-placement^='right'] .react-datepicker__triangle{left:auto;right:42px;}.react-datepicker-popper[data-placement^='left']{padding-right:8px;}.react-datepicker-popper[data-placement^='left'] .react-datepicker__triangle{left:42px;right:auto;}.react-datepicker__header{text-align:center;background-color:#f0f0f0;border-bottom:1px solid #aeaeae;border-top-left-radius:0.3rem;padding:8px 0;position:relative;}.react-datepicker__header--time{padding-bottom:8px;padding-left:5px;padding-right:5px;}.react-datepicker__header--time:not(.react-datepicker__header--time--only){border-top-left-radius:0;}.react-datepicker__header:not(.react-datepicker__header--has-time-select){border-top-right-radius:0.3rem;}.react-datepicker__year-dropdown-container--select,.react-datepicker__month-dropdown-container--select,.react-datepicker__month-year-dropdown-container--select,.react-datepicker__year-dropdown-container--scroll,.react-datepicker__month-dropdown-container--scroll,.react-datepicker__month-year-dropdown-container--scroll{display:inline-block;margin:0 2px;}.react-datepicker__current-month,.react-datepicker-time__header,.react-datepicker-year-header{margin-top:0;color:#000;font-weight:bold;font-size:0.944rem;}.react-datepicker-time__header{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}.react-datepicker__navigation{align-items:center;background:none;display:flex;justify-content:center;text-align:center;cursor:pointer;position:absolute;top:2px;padding:0;border:none;z-index:1;height:32px;width:32px;text-indent:-999em;overflow:hidden;}.react-datepicker__navigation--previous{left:2px;}.react-datepicker__navigation--next{right:2px;}.react-datepicker__navigation--next--with-time:not(.react-datepicker__navigation--next--with-today-button){right:85px;}.react-datepicker__navigation--years{position:relative;top:0;display:block;margin-left:auto;margin-right:auto;}.react-datepicker__navigation--years-previous{top:4px;}.react-datepicker__navigation--years-upcoming{top:-4px;}.react-datepicker__navigation:hover *::before{border-color:#a6a6a6;}.react-datepicker__navigation-icon{position:relative;top:-1px;font-size:20px;width:0;}.react-datepicker__navigation-icon--next{left:-2px;}.react-datepicker__navigation-icon--next::before{transform:rotate(45deg);left:-7px;}.react-datepicker__navigation-icon--previous{right:-2px;}.react-datepicker__navigation-icon--previous::before{transform:rotate(225deg);right:-7px;}.react-datepicker__month-container{float:left;}.react-datepicker__year{margin:0.4rem;text-align:center;}.react-datepicker__year-wrapper{display:flex;flex-wrap:wrap;max-width:180px;}.react-datepicker__year .react-datepicker__year-text{display:inline-block;width:4rem;margin:2px;}.react-datepicker__month{margin:0.4rem;text-align:center;}.react-datepicker__month .react-datepicker__month-text,.react-datepicker__month .react-datepicker__quarter-text{display:inline-block;width:4rem;margin:2px;}.react-datepicker__input-time-container{clear:both;width:100%;float:left;margin:5px 0 10px 15px;text-align:left;}.react-datepicker__input-time-container .react-datepicker-time__caption{display:inline-block;}.react-datepicker__input-time-container .react-datepicker-time__input-container{display:inline-block;}.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__input{display:inline-block;margin-left:10px;}.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__input input{width:auto;}.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__input input[type='time']::-webkit-inner-spin-button,.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__input input[type='time']::-webkit-outer-spin-button{-webkit-appearance:none;margin:0;}.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__input input[type='time']{-moz-appearance:textfield;}.react-datepicker__input-time-container .react-datepicker-time__input-container .react-datepicker-time__delimiter{margin-left:5px;display:inline-block;}.react-datepicker__time-container{float:right;border-left:1px solid #aeaeae;width:85px;}.react-datepicker__time-container--with-today-button{display:inline;border:1px solid #aeaeae;border-radius:0.3rem;position:absolute;right:-72px;top:0;}.react-datepicker__time-container .react-datepicker__time{position:relative;background:white;border-bottom-right-radius:0.3rem;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box{width:85px;overflow-x:hidden;margin:0 auto;text-align:center;border-bottom-right-radius:0.3rem;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list{list-style:none;margin:0;height:calc(195px + (1.7rem / 2));overflow-y:scroll;padding-right:0;padding-left:0;width:100%;box-sizing:content-box;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item{height:30px;padding:5px 10px;white-space:nowrap;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item:hover{cursor:pointer;background-color:#f0f0f0;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item--selected{background-color:#216ba5;color:white;font-weight:bold;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item--selected:hover{background-color:#216ba5;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item--disabled{color:#ccc;}.react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list li.react-datepicker__time-list-item--disabled:hover{cursor:default;background-color:transparent;}.react-datepicker__week-number{color:#ccc;display:inline-block;width:1.7rem;line-height:1.7rem;text-align:center;margin:0.166rem;}.react-datepicker__week-number.react-datepicker__week-number--clickable{cursor:pointer;}.react-datepicker__week-number.react-datepicker__week-number--clickable:hover{border-radius:0.3rem;background-color:#f0f0f0;}.react-datepicker__day-names,.react-datepicker__week{white-space:nowrap;}.react-datepicker__day-names{margin-bottom:-8px;}.react-datepicker__day-name,.react-datepicker__day,.react-datepicker__time-name{color:#000;display:inline-block;width:1.7rem;line-height:1.7rem;text-align:center;margin:0.166rem;}.react-datepicker__month--selected,.react-datepicker__month--in-selecting-range,.react-datepicker__month--in-range,.react-datepicker__quarter--selected,.react-datepicker__quarter--in-selecting-range,.react-datepicker__quarter--in-range{border-radius:0.3rem;background-color:#216ba5;color:#fff;}.react-datepicker__month--selected:hover,.react-datepicker__month--in-selecting-range:hover,.react-datepicker__month--in-range:hover,.react-datepicker__quarter--selected:hover,.react-datepicker__quarter--in-selecting-range:hover,.react-datepicker__quarter--in-range:hover{background-color:#1d5d90;}.react-datepicker__month--disabled,.react-datepicker__quarter--disabled{color:#ccc;pointer-events:none;}.react-datepicker__month--disabled:hover,.react-datepicker__quarter--disabled:hover{cursor:default;background-color:transparent;}.react-datepicker__day,.react-datepicker__month-text,.react-datepicker__quarter-text,.react-datepicker__year-text{cursor:pointer;}.react-datepicker__day:hover,.react-datepicker__month-text:hover,.react-datepicker__quarter-text:hover,.react-datepicker__year-text:hover{border-radius:0.3rem;background-color:#f0f0f0;}.react-datepicker__day--today,.react-datepicker__month-text--today,.react-datepicker__quarter-text--today,.react-datepicker__year-text--today{font-weight:bold;}.react-datepicker__day--highlighted,.react-datepicker__month-text--highlighted,.react-datepicker__quarter-text--highlighted,.react-datepicker__year-text--highlighted{border-radius:0.3rem;background-color:#3dcc4a;color:#fff;}.react-datepicker__day--highlighted:hover,.react-datepicker__month-text--highlighted:hover,.react-datepicker__quarter-text--highlighted:hover,.react-datepicker__year-text--highlighted:hover{background-color:#32be3f;}.react-datepicker__day--highlighted-custom-1,.react-datepicker__month-text--highlighted-custom-1,.react-datepicker__quarter-text--highlighted-custom-1,.react-datepicker__year-text--highlighted-custom-1{color:magenta;}.react-datepicker__day--highlighted-custom-2,.react-datepicker__month-text--highlighted-custom-2,.react-datepicker__quarter-text--highlighted-custom-2,.react-datepicker__year-text--highlighted-custom-2{color:green;}.react-datepicker__day--selected,.react-datepicker__day--in-selecting-range,.react-datepicker__day--in-range,.react-datepicker__month-text--selected,.react-datepicker__month-text--in-selecting-range,.react-datepicker__month-text--in-range,.react-datepicker__quarter-text--selected,.react-datepicker__quarter-text--in-selecting-range,.react-datepicker__quarter-text--in-range,.react-datepicker__year-text--selected,.react-datepicker__year-text--in-selecting-range,.react-datepicker__year-text--in-range{border-radius:0.3rem;background-color:#216ba5;color:#fff;}.react-datepicker__day--selected:hover,.react-datepicker__day--in-selecting-range:hover,.react-datepicker__day--in-range:hover,.react-datepicker__month-text--selected:hover,.react-datepicker__month-text--in-selecting-range:hover,.react-datepicker__month-text--in-range:hover,.react-datepicker__quarter-text--selected:hover,.react-datepicker__quarter-text--in-selecting-range:hover,.react-datepicker__quarter-text--in-range:hover,.react-datepicker__year-text--selected:hover,.react-datepicker__year-text--in-selecting-range:hover,.react-datepicker__year-text--in-range:hover{background-color:#1d5d90;}.react-datepicker__day--keyboard-selected,.react-datepicker__month-text--keyboard-selected,.react-datepicker__quarter-text--keyboard-selected,.react-datepicker__year-text--keyboard-selected{border-radius:0.3rem;background-color:#2a87d0;color:#fff;}.react-datepicker__day--keyboard-selected:hover,.react-datepicker__month-text--keyboard-selected:hover,.react-datepicker__quarter-text--keyboard-selected:hover,.react-datepicker__year-text--keyboard-selected:hover{background-color:#1d5d90;}.react-datepicker__day--in-selecting-range:not(.react-datepicker__day--in-range, .react-datepicker__month-text--in-range, .react-datepicker__quarter-text--in-range, .react-datepicker__year-text--in-range),.react-datepicker__month-text--in-selecting-range:not(.react-datepicker__day--in-range, .react-datepicker__month-text--in-range, .react-datepicker__quarter-text--in-range, .react-datepicker__year-text--in-range),.react-datepicker__quarter-text--in-selecting-range:not(.react-datepicker__day--in-range, .react-datepicker__month-text--in-range, .react-datepicker__quarter-text--in-range, .react-datepicker__year-text--in-range),.react-datepicker__year-text--in-selecting-range:not(.react-datepicker__day--in-range, .react-datepicker__month-text--in-range, .react-datepicker__quarter-text--in-range, .react-datepicker__year-text--in-range){background-color:rgba(33, 107, 165, 0.5);}.react-datepicker__month--selecting-range .react-datepicker__day--in-range:not(.react-datepicker__day--in-selecting-range, .react-datepicker__month-text--in-selecting-range, .react-datepicker__quarter-text--in-selecting-range, .react-datepicker__year-text--in-selecting-range),.react-datepicker__month--selecting-range .react-datepicker__month-text--in-range:not(.react-datepicker__day--in-selecting-range, .react-datepicker__month-text--in-selecting-range, .react-datepicker__quarter-text--in-selecting-range, .react-datepicker__year-text--in-selecting-range),.react-datepicker__month--selecting-range .react-datepicker__quarter-text--in-range:not(.react-datepicker__day--in-selecting-range, .react-datepicker__month-text--in-selecting-range, .react-datepicker__quarter-text--in-selecting-range, .react-datepicker__year-text--in-selecting-range),.react-datepicker__month--selecting-range .react-datepicker__year-text--in-range:not(.react-datepicker__day--in-selecting-range, .react-datepicker__month-text--in-selecting-range, .react-datepicker__quarter-text--in-selecting-range, .react-datepicker__year-text--in-selecting-range){background-color:#f0f0f0;color:#000;}.react-datepicker__day--disabled,.react-datepicker__month-text--disabled,.react-datepicker__quarter-text--disabled,.react-datepicker__year-text--disabled{cursor:default;color:#ccc;}.react-datepicker__day--disabled:hover,.react-datepicker__month-text--disabled:hover,.react-datepicker__quarter-text--disabled:hover,.react-datepicker__year-text--disabled:hover{background-color:transparent;}.react-datepicker__month-text.react-datepicker__month--selected:hover,.react-datepicker__month-text.react-datepicker__month--in-range:hover,.react-datepicker__month-text.react-datepicker__quarter--selected:hover,.react-datepicker__month-text.react-datepicker__quarter--in-range:hover,.react-datepicker__quarter-text.react-datepicker__month--selected:hover,.react-datepicker__quarter-text.react-datepicker__month--in-range:hover,.react-datepicker__quarter-text.react-datepicker__quarter--selected:hover,.react-datepicker__quarter-text.react-datepicker__quarter--in-range:hover{background-color:#216ba5;}.react-datepicker__month-text:hover,.react-datepicker__quarter-text:hover{background-color:#f0f0f0;}.react-datepicker__input-container{position:relative;display:inline-block;width:100%;}.react-datepicker__year-read-view,.react-datepicker__month-read-view,.react-datepicker__month-year-read-view{border:1px solid transparent;border-radius:0.3rem;position:relative;}.react-datepicker__year-read-view:hover,.react-datepicker__month-read-view:hover,.react-datepicker__month-year-read-view:hover{cursor:pointer;}.react-datepicker__year-read-view:hover .react-datepicker__year-read-view--down-arrow,.react-datepicker__year-read-view:hover .react-datepicker__month-read-view--down-arrow,.react-datepicker__month-read-view:hover .react-datepicker__year-read-view--down-arrow,.react-datepicker__month-read-view:hover .react-datepicker__month-read-view--down-arrow,.react-datepicker__month-year-read-view:hover .react-datepicker__year-read-view--down-arrow,.react-datepicker__month-year-read-view:hover .react-datepicker__month-read-view--down-arrow{border-top-color:#b3b3b3;}.react-datepicker__year-read-view--down-arrow,.react-datepicker__month-read-view--down-arrow,.react-datepicker__month-year-read-view--down-arrow{transform:rotate(135deg);right:-16px;top:0;}.react-datepicker__year-dropdown,.react-datepicker__month-dropdown,.react-datepicker__month-year-dropdown{background-color:#f0f0f0;position:absolute;width:50%;left:25%;top:30px;z-index:1;text-align:center;border-radius:0.3rem;border:1px solid #aeaeae;}.react-datepicker__year-dropdown:hover,.react-datepicker__month-dropdown:hover,.react-datepicker__month-year-dropdown:hover{cursor:pointer;}.react-datepicker__year-dropdown--scrollable,.react-datepicker__month-dropdown--scrollable,.react-datepicker__month-year-dropdown--scrollable{height:150px;overflow-y:scroll;}.react-datepicker__year-option,.react-datepicker__month-option,.react-datepicker__month-year-option{line-height:20px;width:100%;display:block;margin-left:auto;margin-right:auto;}.react-datepicker__year-option:first-of-type,.react-datepicker__month-option:first-of-type,.react-datepicker__month-year-option:first-of-type{border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;}.react-datepicker__year-option:last-of-type,.react-datepicker__month-option:last-of-type,.react-datepicker__month-year-option:last-of-type{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;}.react-datepicker__year-option:hover,.react-datepicker__month-option:hover,.react-datepicker__month-year-option:hover{background-color:#ccc;}.react-datepicker__year-option:hover .react-datepicker__navigation--years-upcoming,.react-datepicker__month-option:hover .react-datepicker__navigation--years-upcoming,.react-datepicker__month-year-option:hover .react-datepicker__navigation--years-upcoming{border-bottom-color:#b3b3b3;}.react-datepicker__year-option:hover .react-datepicker__navigation--years-previous,.react-datepicker__month-option:hover .react-datepicker__navigation--years-previous,.react-datepicker__month-year-option:hover .react-datepicker__navigation--years-previous{border-top-color:#b3b3b3;}.react-datepicker__year-option--selected,.react-datepicker__month-option--selected,.react-datepicker__month-year-option--selected{position:absolute;left:15px;}.react-datepicker__close-icon{cursor:pointer;background-color:transparent;border:0;outline:0;padding:0 6px 0 0;position:absolute;top:0;right:0;height:100%;display:table-cell;vertical-align:middle;}.react-datepicker__close-icon::after{cursor:pointer;background-color:#216ba5;color:#fff;border-radius:50%;height:16px;width:16px;padding:2px;font-size:12px;line-height:1;text-align:center;display:table-cell;vertical-align:middle;content:'\xD7';}.react-datepicker__today-button{background:#f0f0f0;border-top:1px solid #aeaeae;cursor:pointer;text-align:center;font-weight:bold;padding:5px 0;clear:left;}.react-datepicker__portal{position:fixed;width:100vw;height:100vh;background-color:rgba(0, 0, 0, 0.8);left:0;top:0;justify-content:center;align-items:center;display:flex;z-index:2147483647;}.react-datepicker__portal .react-datepicker__day-name,.react-datepicker__portal .react-datepicker__day,.react-datepicker__portal .react-datepicker__time-name{width:3rem;line-height:3rem;}@media (max-width: 400px),(max-height: 550px){.react-datepicker__portal .react-datepicker__day-name,.react-datepicker__portal .react-datepicker__day,.react-datepicker__portal .react-datepicker__time-name{width:2rem;line-height:2rem;}}.react-datepicker__portal .react-datepicker__current-month,.react-datepicker__portal .react-datepicker-time__header{font-size:1.44rem;}"
};
var _ref = {
  name: "1epaze0",
  styles: "position:absolute;z-index:4"
};
const Component$1 = ({
  value,
  onChange,
  options
}) => {
  const date = value ? new Date(value * 1e3) : null;
  const [open, setOpen] = react.exports.useState(false);
  const formattedDate = date ? new Intl.DateTimeFormat(void 0, {
    dateStyle: "long",
    timeStyle: options.time ? "short" : void 0
  }).format(date) : "";
  const handleChange = (date2) => {
    onChange(date2.getTime() / 1e3);
    if (!options.time) {
      setOpen(false);
    }
  };
  const ReactDatePickerComponent = typeof Wt === "function" ? Wt : Wt.default;
  const id2 = useUniqId("datepickerinput");
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    label: options.label,
    help: options.help,
    icon: /* @__PURE__ */ jsx(Button, {
      onClick: prevent(() => setOpen(true)),
      children: /* @__PURE__ */ jsx(IconCalendar, {
        size: 16
      })
    }),
    children: /* @__PURE__ */ jsxs("div", {
      css: DatePickerCss,
      children: [/* @__PURE__ */ jsx(Input$2, {
        id: id2,
        onFocus: () => setOpen(true),
        value: formattedDate,
        readOnly: true
      }), open && /* @__PURE__ */ jsx("div", {
        css: _ref,
        children: /* @__PURE__ */ jsx(ReactDatePickerComponent, {
          selected: date,
          showTimeInput: options.time,
          inline: true,
          onChange: handleChange,
          onClickOutside: () => setOpen(false)
        })
      })]
    })
  });
};
const Button = /* @__PURE__ */ createStyled(ButtonIcon, {
  target: "elsvpmt0"
})({
  name: "fcl53z",
  styles: "width:32px;height:32px;color:var(--ve-color-light)"
});
const DatePicker = defineField({
  defaultOptions: {
    default: "",
    time: false
  },
  render: Component$1
});
const AlignmentIcons = {
  left: IconTextLeft,
  center: IconTextCenter,
  right: IconTextRight
};
const Component = ({
  value,
  onChange,
  options
}) => {
  const alignements = Object.keys(AlignmentIcons);
  const id2 = useUniqId();
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(AlignmentButtons, {
      children: alignements.map((alignment) => /* @__PURE__ */ jsx(AlignmentButton, {
        name: id2,
        value: alignment,
        checked: value === alignment,
        onChange,
        icon: AlignmentIcons[alignment]
      }, alignment))
    })
  });
};
const TextAlign = defineField({
  defaultOptions: {
    default: "left"
  },
  render: Component
});
const Translations = {
  copyPage: "Copier le code de la page",
  deleteComponent: "Supprimer le bloc",
  copyComponent: "Copier le  bloc",
  searchComponent: "Rechercher un bloc",
  copySuccess: "Le code a bi\xE9n \xE9t\xE9 copi\xE9",
  copyInstructions: "vous pouvez le coller sur une autre page (CTRL + V)",
  addComponent: "Ajouter un bloc",
  responsiveView: "Vue responsive",
  addItem: "Ajouter un \xE9l\xE9ment",
  deleteItem: "Supprimer l'\xE9l\xE9ment",
  rollback: "R\xE9tablir",
  deleteItemConfirm: "Le bloc a bien \xE9t\xE9 supprim\xE9",
  unknownComponent: "Bloc inconnu",
  save: "Sauvegarder",
  close: "Fermer",
  poweredBy: "Propuls\xE9 par",
  noContent: `Vous n'avez pas encore de contenu`,
  useTemplate: "Utilisez un template"
};
const components = {};
const templates = [];
const _VisualEditor = class {
  constructor(options = {}) {
    var _a, _b;
    _VisualEditor.i18n = (_a = options.lang) != null ? _a : Translations$1;
    _VisualEditor.postMessagePreview = (_b = options.postMessagePreview) != null ? _b : false;
  }
  registerComponent(name, definition) {
    components[name] = __spreadValues({
      label: "title"
    }, definition);
  }
  registerTemplate(template) {
    templates.push(template);
  }
  defineElement(elementName = "visual-editor") {
    class VisualEditorElement extends HTMLElement {
      constructor() {
        super(...arguments);
        __publicField(this, "_mounted", false);
        __publicField(this, "_data", null);
        __publicField(this, "_value", "");
      }
      static get observedAttributes() {
        return ["hidden", "value"];
      }
      get value() {
        return this._value;
      }
      set value(v2) {
        if (v2 === this._value) {
          return;
        }
        this._value = v2;
        this._data = null;
        this.render();
      }
      connectedCallback() {
        this._value = this.getAttribute("value") || "[]";
        this.render();
        this._mounted = true;
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (!this._mounted) {
          return false;
        }
        if (name === "value") {
          if (newValue === this._value) {
            return;
          }
          this._value = newValue;
        }
        this.render();
      }
      disconnectedCallback() {
        this._mounted = false;
      }
      parseValue(value) {
        if (this._data === null) {
          try {
            const json = JSON.parse(value);
            this._data = indexify(json).map((value2) => {
              var _a, _b;
              return fillDefaults(value2, (_b = (_a = components[value2._name]) == null ? void 0 : _a.fields) != null ? _b : []);
            });
          } catch (e2) {
            console.error("Impossible de parser les donn\xE9es", value, e2);
            alert("Impossible de parser les donn\xE9es de l'\xE9diteur visuel");
            this._data = [];
          }
        }
        return this._data;
      }
      render() {
        var _a, _b, _c, _d, _e2, _f;
        const data = this.parseValue(this._value);
        const hiddenCategories = (_b = (_a = this.getAttribute("hidden-categories")) == null ? void 0 : _a.split(";")) != null ? _b : [];
        createRoot(this).render(/* @__PURE__ */ jsx(StoreProvider, {
          data,
          definitions: components,
          templates,
          hiddenCategories,
          rootElement: this,
          insertPosition: (_c = this.getAttribute("insertPosition")) != null ? _c : InsertPosition.Start,
          children: /* @__PURE__ */ jsx(VisualEditorComponent, {
            element: this,
            value: data,
            previewUrl: (_d = this.getAttribute("preview")) != null ? _d : "",
            iconsUrl: (_e2 = this.getAttribute("iconsUrl")) != null ? _e2 : "/",
            name: (_f = this.getAttribute("name")) != null ? _f : "",
            visible: this.getAttribute("hidden") === null,
            onChange: (value) => {
              if (this._value === value) {
                return;
              }
              this._value = value;
              this.dispatchEvent(new CustomEvent("change", {
                detail: value
              }));
            }
          })
        }));
      }
    }
    __publicField(VisualEditorElement, "changeEventName", "change");
    customElements.define(elementName, VisualEditorElement);
  }
};
let VisualEditor = _VisualEditor;
__publicField(VisualEditor, "i18n", Translations$1);
__publicField(VisualEditor, "postMessagePreview", false);
function VisualEditorComponent({
  value,
  previewUrl,
  name,
  element,
  iconsUrl,
  visible: visibleProps,
  onChange
}) {
  const skipNextChange = react.exports.useRef(true);
  const updateData = useUpdateData();
  const data = useData();
  const visible = useStateDelayed(visibleProps);
  const handleClose = () => {
    element.dispatchEvent(new Event("close"));
  };
  const doNothing = () => null;
  const cleanedData = react.exports.useMemo(() => stringifyFields(data), [data]);
  useUpdateEffect(() => {
    skipNextChange.current = true;
    updateData(value);
  }, [value]);
  useClipboardPaste(visible);
  react.exports.useEffect(() => {
    if (skipNextChange.current) {
      skipNextChange.current = false;
    } else {
      onChange(cleanedData);
    }
  }, [cleanedData]);
  const div2 = react.exports.useRef(null);
  useStopPropagation(div2, ["change", "close"]);
  if (!visible) {
    return /* @__PURE__ */ jsx("textarea", {
      hidden: true,
      name,
      value: cleanedData,
      onChange: doNothing
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    ref: div2,
    children: [/* @__PURE__ */ jsx(BaseStyles, {
      children: /* @__PURE__ */ jsx(Layout, {
        data,
        onClose: handleClose,
        previewUrl,
        iconsUrl
      })
    }), /* @__PURE__ */ jsx("textarea", {
      hidden: true,
      name,
      value: cleanedData,
      onChange: doNothing
    })]
  });
}
export { AddButton, Alignment, BaseStyles, Checkbox, Color, DatePicker, Translations$1 as EN, Translations as FR, Field$1 as Field, FieldsRenderer, HTMLText, ImageUrl, Number$1 as Number, PreviewWrapper, Range, e$3 as React, Repeater, Row, Select, Tabs, Text$2 as Text, TextAlign, VisualEditor, VisualEditorComponent, defineField, defineFieldGroup };
